<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Kiss]]></title>
  <subtitle><![CDATA[less is more]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-04-15T06:01:52.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[yankang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[shell脚本学习笔记]]></title>
    <link href="http://yoursite.com/year/04/12/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/year/04/12/shell脚本学习笔记/</id>
    <published>2016-04-12T11:51:43.000Z</published>
    <updated>2016-04-15T06:01:52.000Z</updated>
    <content type="html"><![CDATA[<h3 id="set_u547D_u4EE4"><a href="#set_u547D_u4EE4" class="headerlink" title="set命令"></a>set命令</h3><p>set -x: 该代码以后的代码都开启调试输出，直到遇到set +x取消<br>set +x: 关闭调试输出<br>set -e: 该代码以后的代码如果返回一个非0的值，那么整个脚本立即退出，遇到set +e取消该功能<br>set +e: 取消set -e的功能</p>
<h3 id="if_u8BED_u53E5"><a href="#if_u8BED_u53E5" class="headerlink" title="if语句"></a>if语句</h3><p>-n: 表示不为空<br>-z: 表示长度为0<br>-eq: 等于<br>-lt: 小于<br>-gt: 大于<br>-ge: 不小于<br>-ne: 不等于<br>-le: 不大于<br>-r: 如果文件存在且可读<br>-w: 如果文件存在且可写<br>-x: 如果文件存在且可执行</p>
<p>不为空的时候输出hello world!<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"$1"</span> ]; then</span><br><span class="line">	echo <span class="string">"hello world!"</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>为空的时候执行/bin/bash, 不为空输出( \$@ 表示输出所有内容, \$1 表示第一个参数)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"$1"</span> ]; then</span><br><span class="line">  /bin/bash</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  echo $@</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<h3 id="while_u8BED_u53E5"><a href="#while_u8BED_u53E5" class="headerlink" title="while语句"></a>while语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> [ $i -le <span class="number">256</span> ]</span><br><span class="line">do </span><br><span class="line">	echo <span class="string">"$i times hello world"</span></span><br><span class="line">	i=$(expr $i + <span class="number">1</span>)</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="for_u8BED_u53E5"><a href="#for_u8BED_u53E5" class="headerlink" title="for语句"></a>for语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">i=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq <span class="number">1</span> <span class="number">256</span>)</span><br><span class="line">do </span><br><span class="line">	echo <span class="string">"$i times hello world"</span></span><br><span class="line">	i=$(expr $i + <span class="number">1</span>)</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="u82E5_u5E72_u7528_u6CD5_u603B_u7ED3"><a href="#u82E5_u5E72_u7528_u6CD5_u603B_u7ED3" class="headerlink" title="若干用法总结"></a>若干用法总结</h3><p>将第一个参数装换成小写，upper和lower对调即是大写<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">"$1"</span> ]; then</span><br><span class="line">	echo $<span class="number">1</span> |tr <span class="string">'[:upper:]'</span> <span class="string">'[:lower:]'</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>查找/home/yankang/shell/test/是否为空<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"$(find /home/yankang/shell/test/ -prune -empty)"</span> ]; then</span><br><span class="line">	echo <span class="string">"hello world"</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>如果第一个参数后面是0～9之间的数字则后面加上”p\${2}”,否则直接后面加上”\${2}”<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function dev_part &#123;</span><br><span class="line">	<span class="keyword">if</span> [[ <span class="string">"$&#123;1:0-1:1&#125;"</span> == [<span class="number">0</span>-<span class="number">9</span>] ]]; then </span><br><span class="line">		echo <span class="string">"$&#123;1&#125;p$&#123;2&#125;"</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		echo <span class="string">"$&#123;1&#125;$&#123;2&#125;"</span></span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo $(dev_part $<span class="number">1</span> $<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>奇怪的用法,后面的‘exec complete’没有输出<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat ./test &lt;&lt; EOF</span><br><span class="line">&gt; echo <span class="string">"something right"</span></span><br><span class="line">&gt; <span class="keyword">exec</span> ./hello</span><br><span class="line">&gt; echo <span class="string">"exec complete"</span></span><br><span class="line">&gt; EOF</span><br><span class="line">chmod +x test</span><br><span class="line">./test</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="set_u547D_u4EE4"><a href="#set_u547D_u4EE4" class="headerlink" title="set命令"></a>set命令</h3><p>set -x: 该代码以后的代码都开启调试输出，直到遇到set +x取消<b]]>
    </summary>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[改变docker容器存储配置]]></title>
    <link href="http://yoursite.com/year/04/11/%E6%94%B9%E5%8F%98docker%E5%AE%B9%E5%99%A8%E5%AD%98%E5%82%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/year/04/11/改变docker容器存储配置/</id>
    <published>2016-04-11T15:31:37.000Z</published>
    <updated>2016-04-12T03:03:38.000Z</updated>
    <content type="html"><![CDATA[<p>本文主要针对centOS7的docker存储插件devicemapper。</p>
<h3 id="u64CD_u4F5C_u6D41_u7A0B"><a href="#u64CD_u4F5C_u6D41_u7A0B" class="headerlink" title="操作流程"></a>操作流程</h3><p>操作之前将容器或镜像保存下来,(e.g.)如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># save</span></span><br><span class="line">docker save ceph/daemon &gt; ceph.tar </span><br><span class="line"><span class="comment"># load</span></span><br><span class="line">docker load --input ceph.tar</span><br></pre></td></tr></table></figure></p>
<p>停止docker服务<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker stop</span><br></pre></td></tr></table></figure></p>
<p>删除docker所有的存储镜像和容器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure></p>
<p>创建LVM物理卷,如果出现warning删除ext4标签<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/sdb</span><br><span class="line">pvcreate /dev/sdb</span><br></pre></td></tr></table></figure></p>
<p>创建新的卷组vg-docker<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vgcreate vg-docker /dev/sdb</span><br></pre></td></tr></table></figure></p>
<p>在vg-docker中创建data逻辑卷和metadata逻辑卷,用于docker容器和镜像存储(大小根据自己实际设置)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lvcreate -L <span class="number">90</span>G -n data vg-docker</span><br><span class="line">lvcreate -L <span class="number">4</span>G -n metadata vg-docker</span><br></pre></td></tr></table></figure></p>
<p>在/usr/lib/systemd/system/docker.service的/usr/bin/docker daemon -H fd://后面添加如下内容指定docker的数据池和元数据池<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--storage-driver=devicemapper --storage-opt dm.basesize=<span class="number">90</span>G --storage-opt dm.datadev=/dev/vg-docker/data --storage-opt dm.metadatadev=/dev/vg-docker/metadata</span><br></pre></td></tr></table></figure></p>
<p>dm.basesize表示每个容器运行时配置的容量大小。</p>
<p>重启docker服务<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon_reload</span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure></p>
<h3 id="u53C2_u8003_u6587_u6863"><a href="#u53C2_u8003_u6587_u6863" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://docs.docker.com/engine/userguide/storagedriver/device-mapper-driver/" target="_blank" rel="external">Docker and the Device Mapper storage driver</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要针对centOS7的docker存储插件devicemapper。</p>
<h3 id="u64CD_u4F5C_u6D41_u7A0B"><a href="#u64CD_u4F5C_u6D41_u7A0B" class="headerlink" title="操]]>
    </summary>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[武当之行]]></title>
    <link href="http://yoursite.com/year/04/03/%E6%AD%A6%E5%BD%93%E4%B9%8B%E8%A1%8C/"/>
    <id>http://yoursite.com/year/04/03/武当之行/</id>
    <published>2016-04-03T06:55:43.000Z</published>
    <updated>2016-04-03T08:06:09.000Z</updated>
    <content type="html"><![CDATA[<p>清明节前几天和室友一起来了一场说走就走的旅行，目的地就是武当山，之所以选择去武当山当然有很多理由，其中之一就是没去过。在清明节前去主要也是考虑到清明节会下雨，只是室友没想到为什么去的那么匆忙，因为我们当晚十一点半就乘坐武昌到武当山的火车出发了，回来的时候果然武汉也刚刚下起了雨。</p>
<p>武当山每个景点之间相隔的距离比较远，但是有很方便的巴士在各个景点之间来回跑。</p>
<h4 id="u592A_u5B50_u5761"><a href="#u592A_u5B50_u5761" class="headerlink" title="太子坡"></a>太子坡</h4><p>我们的第一站就是太子坡，这里的建筑都是红墙绿瓦<br><img src="/about/lifestyle/wudang/1.jpeg" alt="logo"></p>
<p>比较有名的就是<strong>一柱十二梁</strong>和<strong>十里桂花香</strong>，可是在我看来导游讲的风水玄学还是很有意思的，比如领导人来都会选择先到太子坡而不是上金顶，因为有种寓意。。。然后被导游带去见<strong>无量天尊</strong>，有缘送你几句，无缘送你平安福；）<br><img src="/about/lifestyle/wudang/2.JPG" alt="logo"></p>
<h4 id="u900D_u9065_u8C37"><a href="#u900D_u9065_u8C37" class="headerlink" title="逍遥谷"></a>逍遥谷</h4><p>这里主要看风水：）<br><img src="/about/lifestyle/wudang/3.jpeg" alt="logo"><br>上图是室友蹲在地上很用心的拍的，在这里感谢他</p>
<p><img src="/about/lifestyle/wudang/4.JPG" alt="logo"></p>
<p>在这里我们也看到了著名演(dou)员(bi)邓超先生演张无忌的图片<br><img src="/about/lifestyle/wudang/5.JPG" alt="logo"></p>
<h4 id="u5357_u5CA9_u5BAB"><a href="#u5357_u5CA9_u5BAB" class="headerlink" title="南岩宫"></a>南岩宫</h4><p>玄帝殿<br><img src="/about/lifestyle/wudang/6.JPG" alt="logo"></p>
<p>龙头香<br><img src="/about/lifestyle/wudang/7.JPG" alt="logo"><br>仔细看看还真是挺像龙头的，从不同角度–&gt;<br><img src="/about/lifestyle/wudang/8.JPG" alt="logo"></p>
<p>沿途的风景<br><img src="/about/lifestyle/wudang/9.JPG" alt="logo"><br><img src="/about/lifestyle/wudang/10.JPG" alt="logo"></p>
<h4 id="u91D1_u9876"><a href="#u91D1_u9876" class="headerlink" title="金顶"></a>金顶</h4><p>我们是第二天上的金顶，简单来说真是不容易。应该是我爬过最高的山了，经过两个多小时才到达山顶，而且山路异常陡峭。途径一个分岔口，左上路途平缓但较长，右上路途陡峭但较短，感觉和我们的生活很像的，没有太多的完美，我们的选择不过只是尽量的平衡。</p>
<p>途径朝天门–&gt;一天门–&gt;二天门–&gt;三天门–&gt;朝圣门, 最后到达金顶。沿途的风光:<br><img src="/about/lifestyle/wudang/11.JPG" alt="logo"></p>
<p><img src="/about/lifestyle/wudang/12.JPG" alt="logo"></p>
<h4 id="u743C_u53F0"><a href="#u743C_u53F0" class="headerlink" title="琼台"></a>琼台</h4><p>最后我们是乘坐索道下山的<br><img src="/about/lifestyle/wudang/13.jpeg" alt="logo"></p>
<p>下来的地方就是琼台，有乘坐的巴士回到游客中心<br><img src="/about/lifestyle/wudang/14.JPG" alt="logo"></p>
<p>一言以蔽之，游武当山是一场历炼，不过值得拥有～        </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>清明节前几天和室友一起来了一场说走就走的旅行，目的地就是武当山，之所以选择去武当山当然有很多理由，其中之一就是没去过。在清明节前去主要也是考虑到清明节会下雨，只是室友没想到为什么去的那么匆忙，因为我们当晚十一点半就乘坐武昌到武当山的火车出发了，回来的时候果然武汉也刚刚下起了]]>
    </summary>
    
      <category term="lifestyle" scheme="http://yoursite.com/tags/lifestyle/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ceph in docker测试总结]]></title>
    <link href="http://yoursite.com/year/04/02/ceph-in-docker%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/year/04/02/ceph-in-docker测试总结/</id>
    <published>2016-04-02T09:18:23.000Z</published>
    <updated>2016-05-10T08:04:14.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u786C_u4EF6_u73AF_u5883"><a href="#u786C_u4EF6_u73AF_u5883" class="headerlink" title="硬件环境"></a>硬件环境</h3><h4 id="u8BA1_u7B97_u4E0E_u5B58_u50A8"><a href="#u8BA1_u7B97_u4E0E_u5B58_u50A8" class="headerlink" title="计算与存储"></a>计算与存储</h4><p>三台物理节点, 每台物理节点配备1TB 磁盘(RPM 7500, SATA2.0)和240GB SSD(SATA3.0)。<br><img src="/about/ceph/test/1.png" alt="logo"></p>
<h5 id="u78C1_u76D8_u6D4B_u8BD5"><a href="#u78C1_u76D8_u6D4B_u8BD5" class="headerlink" title="磁盘测试"></a>磁盘测试</h5><p><img src="/about/ceph/test/2.png" alt="logo"></p>
<h5 id="SSD_u6D4B_u8BD5"><a href="#SSD_u6D4B_u8BD5" class="headerlink" title="SSD测试"></a>SSD测试</h5><p><img src="/about/ceph/test/3.png" alt="logo"></p>
<h4 id="u7F51_u7EDC"><a href="#u7F51_u7EDC" class="headerlink" title="网络"></a>网络</h4><p>三张万兆网卡，用iperf3测试物理节点间吞吐量<br><img src="/about/ceph/test/4.png" alt="logo"></p>
<p>用iperf3测试docker之间的吞吐量，几乎没有损失<br><img src="/about/ceph/test/5.png" alt="logo"></p>
<h3 id="u6D4B_u8BD5_u5185_u5BB9"><a href="#u6D4B_u8BD5_u5185_u5BB9" class="headerlink" title="测试内容"></a>测试内容</h3><h4 id="RBD_u5757_u8BBE_u5907"><a href="#RBD_u5757_u8BBE_u5907" class="headerlink" title="RBD块设备"></a>RBD块设备</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若干有用的命令</span></span><br><span class="line">modprobe rbd</span><br><span class="line">rbd ls</span><br><span class="line">rbd create --size <span class="number">10240</span> test</span><br><span class="line">rbd --image test info</span><br><span class="line">rbd showmapped</span><br><span class="line">rbd map rbd/test --id admin</span><br></pre></td></tr></table></figure>
<h5 id="fio_u6D4B_u8BD5"><a href="#fio_u6D4B_u8BD5" class="headerlink" title="fio测试"></a>fio测试</h5><p>HDD-1<br><img src="/about/ceph/test/6.png" alt="logo"></p>
<p>HDD-2<br><img src="/about/ceph/test/7.png" alt="logo"></p>
<p>SSD-1<br><img src="/about/ceph/test/8.png" alt="logo"></p>
<p>SSD-2<br><img src="/about/ceph/test/9.png" alt="logo"></p>
<p>从以上四张测试结果可以看出:</p>
<ol>
<li>HDD-1与SSD-1的对比可以看出,SSD组建的ceph集群RBD块设备IOPS和吞吐量明显优于HDD组成的集群。</li>
<li>HDD-1与HDD-2的对比可以看出,HDD-1OSD与HDD-2OSD的RBD块设备IOPS和吞吐量差异不大。 </li>
<li>SSD-1与SSD-2的对比可以看出,SSD-1OSD与SSD-2OSD的RBD块设备IOPS和吞吐量差异不大。 </li>
<li>虚拟多OSD节点似乎更擅长处理随机写，而不怎么擅长顺序写。考虑到其他随机因素，其实差异不是很大。</li>
</ol>
<h5 id="filebench"><a href="#filebench" class="headerlink" title="filebench"></a>filebench</h5><p>filebench测试RBD的结果<br><img src="/about/ceph/test/10.png" alt="logo"></p>
<p>ceph集群的实时IOPS<br><img src="/about/ceph/test/11.png" alt="logo"></p>
<p>从以上测试结果可以看出:</p>
<ol>
<li>HDD-1与SSD-1的对比可以看出,SSD组建的ceph集群RBD块设备明显优于HDD组成的集群。</li>
<li>HDD-1与HDD-2的对比可以看出,HDD-2的实时IOPS波动比HDD-1更明显,但是HDD-1OSD与HDD-2OSD的RBD块设备性能差异不大。 </li>
<li>SSD-1与SSD-2的对比可以看出,SSD-2的实时IOPS略优于SSD-1,不过,整体而言,SSD-1OSD与SSD-2OSD的RBD块设备性能差异不是很明显。 </li>
</ol>
<h4 id="cephfs_u5206_u5E03_u5F0F_u6587_u4EF6_u7CFB_u7EDF"><a href="#cephfs_u5206_u5E03_u5F0F_u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="cephfs分布式文件系统"></a>cephfs分布式文件系统</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若干有用的命令</span></span><br><span class="line">mkdir -p /var/lib/ceph/mds/ceph-cephfs</span><br><span class="line">ceph --cluster ceph --name client.admin --keyring /etc/ceph/ceph.client.admin.keyring auth get-<span class="keyword">or</span>-create mds.cephfs osd <span class="string">'allow rwx'</span> mds <span class="string">'allow'</span> mon <span class="string">'allow profile mds'</span> -o /var/lib/ceph/mds/ceph-cephfs/keyring</span><br><span class="line">ceph osd pool create cephfs_data <span class="number">128</span></span><br><span class="line">ceph osd pool create cephfs_metadata <span class="number">128</span></span><br><span class="line">ceph fs new cephfs cephfs_metadata cephfs_data</span><br><span class="line">/usr/bin/ceph-mds --cluster ceph -i cephfs &amp;</span><br><span class="line">ceph fs ls</span><br><span class="line">mkdir /home/yankang/cephfs</span><br><span class="line">ceph-fuse -m <span class="number">192.168</span><span class="number">.6</span><span class="number">.66</span>:<span class="number">6789</span> /home/yankang/cephfs</span><br></pre></td></tr></table></figure>
<p>filebench测试cephfs的结果<br><img src="/about/ceph/test/12.png" alt="logo"></p>
<p>ceph集群的实时IOPS<br><img src="/about/ceph/test/13.png" alt="logo"></p>
<p>从以上测试结果可以看出:</p>
<ol>
<li>HDD-1与SSD-1的对比可以看出,SSD组建的ceph集群cephfs分布式文件系统IOPS，吞吐量和IO延迟都明显优于HDD组成的集群。</li>
<li>HDD-1与HDD-2的对比可以看出,HDD-1OSD与HDD-2OSD组建的ceph集群在cephfs分布式文件系统的性能差异不是很明显。</li>
<li>SSD-1与SSD-2的对比可以看出,SSD-2的实时IOPS略差于SSD-1的实时IOPS,但是整体而言,SSD-1OSD与SSD-2OSD组建的ceph集群在cephfs分布式文件系统的性能差异不是很明显。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u786C_u4EF6_u73AF_u5883"><a href="#u786C_u4EF6_u73AF_u5883" class="headerlink" title="硬件环境"></a>硬件环境</h3><h4 id="u8BA1_u7B97_u4E0E_u]]>
    </summary>
    
      <category term="ceph" scheme="http://yoursite.com/tags/ceph/"/>
    
      <category term="cloud computing" scheme="http://yoursite.com/tags/cloud-computing/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[filebench测试]]></title>
    <link href="http://yoursite.com/year/03/29/filebench%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/year/03/29/filebench测试/</id>
    <published>2016-03-29T06:09:56.000Z</published>
    <updated>2016-03-29T06:53:28.000Z</updated>
    <content type="html"><![CDATA[<h3 id="filebench_u5B89_u88C5"><a href="#filebench_u5B89_u88C5" class="headerlink" title="filebench安装"></a>filebench安装</h3><p>Download <a href="https://sourceforge.net/projects/filebench/" target="_blank" rel="external">filebench</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar xvf filebench-<span class="number">1.4</span><span class="number">.9</span><span class="number">.1</span>.tar</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h3 id="fileserver_u6D4B_u8BD5"><a href="#fileserver_u6D4B_u8BD5" class="headerlink" title="fileserver测试"></a>fileserver测试</h3><p>输入filebench</p>
<p>如果遇到如下问题:<br><img src="/about/filebench/1.png" alt="logo"><br>输入如下命令<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">0</span> &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure></p>
<h4 id="u4EA4_u4E92_u65B9_u5F0F_u6D4B_u8BD5"><a href="#u4EA4_u4E92_u65B9_u5F0F_u6D4B_u8BD5" class="headerlink" title="交互方式测试"></a>交互方式测试</h4><p><img src="/about/filebench/2.png" alt="logo"></p>
<h4 id="u975E_u4EA4_u4E92_u65B9_u5F0F_u6D4B_u8BD5"><a href="#u975E_u4EA4_u4E92_u65B9_u5F0F_u6D4B_u8BD5" class="headerlink" title="非交互方式测试"></a>非交互方式测试</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/share/filebench/workloads/fileserver.f ./</span><br><span class="line">vim fileserver.f (set <span class="string">'$dir=/home/yankang/cephfs'</span> <span class="keyword">and</span> add <span class="string">'run 60'</span> to the end of this file)</span><br><span class="line">filebench -f fileserver.f</span><br></pre></td></tr></table></figure>
<p>推荐每个案例测试超过十次取中位数，具体自己体会。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="filebench_u5B89_u88C5"><a href="#filebench_u5B89_u88C5" class="headerlink" title="filebench安装"></a>filebench安装</h3><p>Download <a hr]]>
    </summary>
    
      <category term="Storage" scheme="http://yoursite.com/tags/Storage/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[fio安装与脚本测试]]></title>
    <link href="http://yoursite.com/year/03/24/fio%E5%AE%89%E8%A3%85%E4%B8%8E%E8%84%9A%E6%9C%AC%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/year/03/24/fio安装与脚本测试/</id>
    <published>2016-03-24T06:25:23.000Z</published>
    <updated>2016-04-04T05:32:43.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5B89_u88C5fio"><a href="#u5B89_u88C5fio" class="headerlink" title="安装fio"></a>安装fio</h3><h4 id="ubuntu__u5B89_u88C5"><a href="#ubuntu__u5B89_u88C5" class="headerlink" title="ubuntu 安装"></a>ubuntu 安装</h4><p>apt-get install libaio-dev</p>
<h4 id="centOS__u5B89_u88C5"><a href="#centOS__u5B89_u88C5" class="headerlink" title="centOS 安装"></a>centOS 安装</h4><p>yum install libaio-devel</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://brick.kernel.dk/snaps/fio-<span class="number">2.7</span>.tar.gz</span><br><span class="line">tar zxvf fio-<span class="number">2.7</span>.tar.gz</span><br><span class="line">cd fio-<span class="number">2.7</span></span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h3 id="fio_u6D4B_u8BD5"><a href="#fio_u6D4B_u8BD5" class="headerlink" title="fio测试"></a>fio测试</h3><p>基本命令:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio fio.conf</span><br></pre></td></tr></table></figure></p>
<p>fio.conf可以自己配置,如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">global</span>]</span><br><span class="line">ioengine=libaio</span><br><span class="line">direct=<span class="number">1</span></span><br><span class="line">thread=<span class="number">1</span></span><br><span class="line">runtime=<span class="number">60</span></span><br><span class="line"></span><br><span class="line">[write]</span><br><span class="line">rw=write</span><br><span class="line">bs=<span class="number">2</span>M</span><br><span class="line">filename=/mnt/test/test</span><br><span class="line">name=<span class="string">"SAS 2M write test"</span></span><br><span class="line">size=<span class="number">10</span>G</span><br></pre></td></tr></table></figure></p>
<p>也可以写脚本来传不同的参数给fio.conf,输出结果保存在mytest/write如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">declare -i i=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>((i&lt;<span class="number">512</span>))</span><br><span class="line">do</span><br><span class="line">fio -iodepth $i write.conf &gt;&gt; mytest/write</span><br><span class="line">let i=i+i</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u5B89_u88C5fio"><a href="#u5B89_u88C5fio" class="headerlink" title="安装fio"></a>安装fio</h3><h4 id="ubuntu__u5B89_u88C5"><a href="#ubun]]>
    </summary>
    
      <category term="Storage" scheme="http://yoursite.com/tags/Storage/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ceph的heartbeat设置]]></title>
    <link href="http://yoursite.com/year/03/08/ceph%E7%9A%84heartbeat%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/year/03/08/ceph的heartbeat设置/</id>
    <published>2016-03-08T01:13:14.000Z</published>
    <updated>2016-04-03T07:00:21.000Z</updated>
    <content type="html"><![CDATA[<p>ceph MON会根据ceph OSD的状态报告来动态调整集群状态。</p>
<h3 id="u5E38_u89C1_u7684_u8BBE_u7F6E"><a href="#u5E38_u89C1_u7684_u8BBE_u7F6E" class="headerlink" title="常见的设置"></a>常见的设置</h3><h4 id="osd_heartbeat_interval"><a href="#osd_heartbeat_interval" class="headerlink" title="osd heartbeat interval"></a>osd heartbeat interval</h4><p>OSD每隔一段时间检查另OSD心跳，默认时间6s</p>
<h4 id="osd_heartbeat_grace"><a href="#osd_heartbeat_grace" class="headerlink" title="osd heartbeat grace"></a>osd heartbeat grace</h4><p>OSD检查另OSD心跳，超过这个时间不回复就向MON报告down，默认时间20s<br><img src="/about/ceph/heartbeat/1.png" width="500" heigth="300" alt="logo" align="center"></p>
<h4 id="mon_osd_min_down_reports"><a href="#mon_osd_min_down_reports" class="headerlink" title="mon osd min down reports"></a>mon osd min down reports</h4><p>默认OSD要向MON报告3次另OSD down，MON才会认为另OSD down</p>
<h4 id="mon_osd_min_down_reporters"><a href="#mon_osd_min_down_reporters" class="headerlink" title="mon osd min down reporters"></a>mon osd min down reporters</h4><p>默认只需要一个OSD向MON报告另OSD down的情况<br><img src="/about/ceph/heartbeat/2.png" width="500" heigth="300" alt="logo" align="center"></p>
<h4 id="osd_mon_heartbeat_interval"><a href="#osd_mon_heartbeat_interval" class="headerlink" title="osd mon heartbeat interval"></a>osd mon heartbeat interval</h4><p>如果OSD无法和另OSD同步，每隔一段时间就会接受MON新的集群映射。默认时间30s<br><img src="/about/ceph/heartbeat/3.png" width="500" heigth="300" alt="logo" align="center"></p>
<h4 id="mon_osd_report_timeout"><a href="#mon_osd_report_timeout" class="headerlink" title="mon osd report timeout"></a>mon osd report timeout</h4><p>如果OSD没有给MON报告，隔这段时间MON会将OSD标记为down。默认时间900s</p>
<h4 id="osd_mon_report_interval_min"><a href="#osd_mon_report_interval_min" class="headerlink" title="osd mon report interval min"></a>osd mon report interval min</h4><p>OSD向MON连续报告的最小间隔时间。默认时间5s</p>
<h4 id="osd_mon_report_interval_max"><a href="#osd_mon_report_interval_max" class="headerlink" title="osd mon report interval max"></a>osd mon report interval max</h4><p>OSD向MON发报告的最大时间间隔。默认时间120s<br><img src="/about/ceph/heartbeat/4.png" width="500" heigth="300" alt="logo" align="center"></p>
<h3 id="u5982_u4F55_u5728_u7EBF_u8BBE_u7F6E"><a href="#u5982_u4F55_u5728_u7EBF_u8BBE_u7F6E" class="headerlink" title="如何在线设置"></a>如何在线设置</h3><p>查询心跳<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph daemon /var/run/ceph/ceph-mon.ceph.asok config show | grep heart</span><br></pre></td></tr></table></figure></p>
<p>设置相关的参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ceph daemon /var/run/ceph/ceph-mon.ceph.asok config set osd_heartbeat_grace <span class="number">30</span></span><br></pre></td></tr></table></figure></p>
<p>如果重启集群在线设置都会丢失，要想永久设置就必须写在配置文件中。</p>
<h3 id="u53C2_u8003_u6587_u732E"><a href="#u53C2_u8003_u6587_u732E" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://docs.ceph.com/docs/master/rados/configuration/mon-osd-interaction/" target="_blank" rel="external">Heartbeat Settings</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ceph MON会根据ceph OSD的状态报告来动态调整集群状态。</p>
<h3 id="u5E38_u89C1_u7684_u8BBE_u7F6E"><a href="#u5E38_u89C1_u7684_u8BBE_u7F6E" class="headerlink"]]>
    </summary>
    
      <category term="ceph" scheme="http://yoursite.com/tags/ceph/"/>
    
      <category term="cloud computing" scheme="http://yoursite.com/tags/cloud-computing/"/>
    
      <category term="ceph" scheme="http://yoursite.com/categories/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[硬盘分区]]></title>
    <link href="http://yoursite.com/year/03/07/%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA/"/>
    <id>http://yoursite.com/year/03/07/硬盘分区/</id>
    <published>2016-03-07T12:15:04.000Z</published>
    <updated>2016-03-07T15:09:31.000Z</updated>
    <content type="html"><![CDATA[<p>磁盘包括硬盘和软盘，都由磁性材料制成。磁盘英文名disk，硬盘英文名hard disk。写这篇博客主要是因为最近在运行ceph的时候突然报错说是无效的GPT头结构，然后就查了下GPT分区和MBR分区，这里记录我学习到的东西，更多详细的内容前辈们都已经提到过不再赘述，引用中大家可以去看。</p>
<h3 id="MBR_u5206_u533A_u548CGPT_u5206_u533A_u7B80_u4ECB"><a href="#MBR_u5206_u533A_u548CGPT_u5206_u533A_u7B80_u4ECB" class="headerlink" title="MBR分区和GPT分区简介"></a>MBR分区和GPT分区简介</h3><p><img src="/about/partition/1.png" alt="logo"><br>我们从上图看到partition table是gpt，可以设置为msdos的。我之前ceph运行出错的原因就是分区表类型是msdos，然后我改成gpt就解决了问题。<br>我的理解是分区表类型代表硬盘是什么分区，msdos代表的是MBR分区，gpt代表的是GPT分区。传统的BIOS只支持MBR分区硬盘启动，一个硬盘只能分成四个分区，并且单个分区最大不超过2TB。EFI支持GPT分区启动的，GPT分区没有分区数目的限制并且单个分区可以超过2TB。</p>
<h3 id="MBR_u5206_u533A_u548CGPT_u5206_u533A_u7684_u8F6C_u6362"><a href="#MBR_u5206_u533A_u548CGPT_u5206_u533A_u7684_u8F6C_u6362" class="headerlink" title="MBR分区和GPT分区的转换"></a>MBR分区和GPT分区的转换</h3><p>比如硬盘/dev/sdb</p>
<p>转换成GPT<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parted /dev/sdb</span><br><span class="line">mklabel gpt</span><br></pre></td></tr></table></figure></p>
<p>转换成MBR<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parted /dev/sdb</span><br><span class="line">mklabel msdos</span><br></pre></td></tr></table></figure></p>
<h3 id="fdisk_2C_sgdisk_u548Cparted_u5206_u533A_u5DE5_u5177"><a href="#fdisk_2C_sgdisk_u548Cparted_u5206_u533A_u5DE5_u5177" class="headerlink" title="fdisk, sgdisk和parted分区工具"></a>fdisk, sgdisk和parted分区工具</h3><h4 id="fdisk_28_u521B_u5EFAMBR_u5206_u533A_29_u5DE5_u5177_u5E38_u7528_u547D_u4EE4"><a href="#fdisk_28_u521B_u5EFAMBR_u5206_u533A_29_u5DE5_u5177_u5E38_u7528_u547D_u4EE4" class="headerlink" title="fdisk(创建MBR分区)工具常用命令"></a>fdisk(创建MBR分区)工具常用命令</h4><p>显示所有硬盘分区情况<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure></p>
<p>显示具体单个硬盘分区情况<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l /dev/sdb</span><br></pre></td></tr></table></figure></p>
<p>交互显示方便提示fdisk的所有命令如何使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure></p>
<h4 id="parted_28_u5B9E_u73B0_u5206_u533A_u7C7B_u578B_u8F6C_u6362_29_u5DE5_u5177_u5E38_u7528_u547D_u4EE4"><a href="#parted_28_u5B9E_u73B0_u5206_u533A_u7C7B_u578B_u8F6C_u6362_29_u5DE5_u5177_u5E38_u7528_u547D_u4EE4" class="headerlink" title="parted(实现分区类型转换)工具常用命令"></a>parted(实现分区类型转换)工具常用命令</h4><p>进入parted交互<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parted /dev/sdb</span><br><span class="line"><span class="comment"># 打印硬盘信息</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment"># 搜索可用命令</span></span><br><span class="line">help</span><br><span class="line"><span class="comment"># 设置分区类型</span></span><br><span class="line">mklabel gpt</span><br></pre></td></tr></table></figure></p>
<h4 id="sgdisk_28_u521B_u5EFAGPT_u5206_u533A_29_u5DE5_u5177_u5E38_u7528_u547D_u4EE4_28_u5F15_u7528_u81EAhustcat_29"><a href="#sgdisk_28_u521B_u5EFAGPT_u5206_u533A_29_u5DE5_u5177_u5E38_u7528_u547D_u4EE4_28_u5F15_u7528_u81EAhustcat_29" class="headerlink" title="sgdisk(创建GPT分区)工具常用命令(引用自hustcat)"></a>sgdisk(创建GPT分区)工具常用命令(引用自hustcat)</h4><p>查看所有GPT分区<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sgdisk -p /dev/sdb</span><br></pre></td></tr></table></figure></p>
<p><img src="/about/partition/2.png" alt="logo"></p>
<p>查看某个分区的详细信息<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/sgdisk --info=<span class="number">1</span> /dev/sdb</span><br></pre></td></tr></table></figure></p>
<p><img src="/about/partition/3.png" alt="logo"></p>
<p>最后再介绍两个命令:<br>查询每个分区挂载的目录<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df</span><br></pre></td></tr></table></figure></p>
<p>将/dev/sdb1分区格式化成ext4文件系统<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t ext4 /dev/sdb1</span><br></pre></td></tr></table></figure></p>
<h3 id="u5F15_u7528"><a href="#u5F15_u7528" class="headerlink" title="引用"></a>引用</h3><p><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="external">计算机是如何启动的</a><br><a href="http://www.anchor.com.au/blog/2012/10/the-difference-between-booting-mbr-and-gpt-with-grub/" target="_blank" rel="external">The difference between booting MBR and GPT with GRUB</a><br><a href="http://hustcat.github.io/sgdisk-basic/" target="_blank" rel="external">sgdisk常用操作</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>磁盘包括硬盘和软盘，都由磁性材料制成。磁盘英文名disk，硬盘英文名hard disk。写这篇博客主要是因为最近在运行ceph的时候突然报错说是无效的GPT头结构，然后就查了下GPT分区和MBR分区，这里记录我学习到的东西，更多详细的内容前辈们都已经提到过不再赘述，引用中大]]>
    </summary>
    
      <category term="Storage" scheme="http://yoursite.com/tags/Storage/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Running ceph in docker containers]]></title>
    <link href="http://yoursite.com/year/03/05/Running-ceph-in-docker-containers/"/>
    <id>http://yoursite.com/year/03/05/Running-ceph-in-docker-containers/</id>
    <published>2016-03-05T12:35:59.000Z</published>
    <updated>2016-03-08T13:53:03.000Z</updated>
    <content type="html"><![CDATA[<p>由于毕设在研究docker容器中运行的ceph，现记录下我的运行过程。</p>
<h3 id="u73AF_u5883_u8BF4_u660E"><a href="#u73AF_u5883_u8BF4_u660E" class="headerlink" title="环境说明"></a>环境说明</h3><p>运行环境是centOS 7上安装的Docker version1.10.2。共计有三个主机，每个主机上配置两个硬盘，其中一个硬盘用于装系统，另一个硬盘作为OSD对象存储。由于MON所用计算资源和存储资源都很少所以直接在主机上运行。这样就共计三个MON和三个OSD。</p>
<p>操作之前务必关闭所有主机防火墙，血的教训！！！</p>
<h3 id="u4FEE_u6539_u4E3B_u673A_u540D"><a href="#u4FEE_u6539_u4E3B_u673A_u540D" class="headerlink" title="修改主机名"></a>修改主机名</h3><p>我的三个主机IP分别是192.168.3.65，192.168.3.66，192.168.3.67。将对应的主机名改为ceph1, ceph2, ceph3.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hostname</span><br></pre></td></tr></table></figure></p>
<h3 id="u6539_u53D8_u5BB9_u5668_u548C_u4E3B_u673A_u6620_u5C04_u7684_u76EE_u5F55_u6807_u7B7E"><a href="#u6539_u53D8_u5BB9_u5668_u548C_u4E3B_u673A_u6620_u5C04_u7684_u76EE_u5F55_u6807_u7B7E" class="headerlink" title="改变容器和主机映射的目录标签"></a>改变容器和主机映射的目录标签</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chcon -Rt svirt_sandbox_file_t /etc/ceph</span><br><span class="line">chcon -Rt svirt_sandbox_file_t /var/lib/ceph</span><br></pre></td></tr></table></figure>
<p>上述过程需要设置SELinux是enable的，且三个主机都需要上述步骤。</p>
<h3 id="u8FD0_u884CMON"><a href="#u8FD0_u884CMON" class="headerlink" title="运行MON"></a>运行MON</h3><p>先在ceph1上运行MON<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net=host -v /etc/ceph:/etc/ceph -v /var/lib/ceph/:/var/lib/ceph/ -e MON_IP=<span class="number">192.168</span><span class="number">.3</span><span class="number">.65</span> -e CEPH_PUBLIC_NETWORK=<span class="number">192.168</span><span class="number">.3</span><span class="number">.0</span>/<span class="number">24</span> ceph/daemon mon</span><br></pre></td></tr></table></figure></p>
<p>需要说明CEPH_PUBLIC_NETWORK是你的网卡CIDR值。一般CIDR＝IP &amp; mask。<br>这时候会出现下图的效果:<br><img src="/about/docker/ceph-docker/1.png" alt="logo"></p>
<p>接着在ceph2和ceph3上运行MON，需要将ceph1上的/etc/ceph和/var/lib/ceph目录下的东西都转移到ceph2和ceph3相应的目录中。</p>
<p>然后在ceph2运行:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net=host -v /etc/ceph:/etc/ceph -v /var/lib/ceph/:/var/lib/ceph/ -e MON_IP=<span class="number">192.168</span><span class="number">.3</span><span class="number">.66</span> -e CEPH_PUBLIC_NETWORK=<span class="number">192.168</span><span class="number">.3</span><span class="number">.0</span>/<span class="number">24</span> ceph/daemon mon</span><br></pre></td></tr></table></figure></p>
<p>在ceph3中运行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net=host -v /etc/ceph:/etc/ceph -v /var/lib/ceph/:/var/lib/ceph/ -e MON_IP=<span class="number">192.168</span><span class="number">.3</span><span class="number">.67</span> -e CEPH_PUBLIC_NETWORK=<span class="number">192.168</span><span class="number">.3</span><span class="number">.0</span>/<span class="number">24</span> ceph/daemon mon</span><br></pre></td></tr></table></figure></p>
<p>这时候会看见三个MON都启动了:<br><img src="/about/docker/ceph-docker/2.png" alt="logo">`</p>
<h3 id="u8FD0_u884COSD"><a href="#u8FD0_u884COSD" class="headerlink" title="运行OSD"></a>运行OSD</h3><p>使用mkfs将新添加的硬盘格式化制作ext4或者btrfs文件系统<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t ext4 /dev/sdb</span><br></pre></td></tr></table></figure></p>
<p>挂载OSD<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net=host -v /etc/ceph:/etc/ceph -v /var/lib/ceph:/var/lib/ceph -v /dev:/dev --privileged=true -e OSD_FORCE_ZAP=<span class="number">1</span> -e OSD_DEVICE=/dev/sdb ceph/daemon osd_ceph_disk</span><br></pre></td></tr></table></figure></p>
<p>这时就发现OSD进入了集群<br>同理在ceph2和ceph3中类似操作。</p>
<p>这样我们就完成了在容器中运行ceph，另外我们也可以利用Dockerfile自己构建相关的镜像;ceph/demo镜像提供单机版的容器化的ceph，其中包含一个MON和一个OSD，可以用来学习ceph集群的操作;<br>运行命令如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net=host -e MON_IP=<span class="number">192.168</span><span class="number">.3</span><span class="number">.66</span> -e CEPH_NETWORK=<span class="number">192.168</span><span class="number">.3</span><span class="number">.0</span>/<span class="number">24</span> ceph/demo</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">exec</span> -t -i ContainID /bin/bash</span><br></pre></td></tr></table></figure>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.youtube.com/watch?v=FUSTjTBA8f8&amp;spfreload=10" target="_blank" rel="external">Demo:running Ceph in Docker containers</a><br><a href="http://bbs.ceph.org.cn/article/29#rd?sukey=014c68f407f2d3e12d6bb2c1d65e8cbed9e267135c4c2e973fe434235a519d84b6418f464512ff0410254dbe32d03dc8" target="_blank" rel="external">在Docker里运行Ceph集群</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>由于毕设在研究docker容器中运行的ceph，现记录下我的运行过程。</p>
<h3 id="u73AF_u5883_u8BF4_u660E"><a href="#u73AF_u5883_u8BF4_u660E" class="headerlink" title="环境说]]>
    </summary>
    
      <category term="Storage" scheme="http://yoursite.com/tags/Storage/"/>
    
      <category term="cloud computing" scheme="http://yoursite.com/tags/cloud-computing/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[过年总结]]></title>
    <link href="http://yoursite.com/year/02/15/%E8%BF%87%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/year/02/15/过年总结/</id>
    <published>2016-02-15T08:24:10.000Z</published>
    <updated>2016-02-20T09:00:17.000Z</updated>
    <content type="html"><![CDATA[<p>其实我只是想贴几张过年喜庆的照片:)<br>这是年初三深夜警察局门口放烟火，嘿嘿!<br><img src="/about/lifestyle/1.jpg" width="300" height="300" alt="logo" align="center"><br><img src="/about/lifestyle/2.jpg" width="300" height="300" alt="logo" align="center"><br><img src="/about/lifestyle/3.jpg" width="500" height="300" alt="logo" align="center"><br>接下来是年初四在KTV给小侄女拍的照片<br><img src="/about/lifestyle/4.JPG" width="500" height="300" alt="logo" align="center"><br><img src="/about/lifestyle/5.JPG" width="500" height="300" alt="logo" align="center"><br>突然想起来一个表情包😊<br><img src="/about/lifestyle/6.jpg" width="500" height="300" alt="logo" align="center"> </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>其实我只是想贴几张过年喜庆的照片:)<br>这是年初三深夜警察局门口放烟火，嘿嘿!<br><img src="/about/lifestyle/1.jpg" width="300" height="300" alt="logo" align="center"><br><im]]>
    </summary>
    
      <category term="lifestyle" scheme="http://yoursite.com/tags/lifestyle/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[大话存储2学习笔记]]></title>
    <link href="http://yoursite.com/year/02/09/%E5%A4%A7%E8%AF%9D%E5%AD%98%E5%82%A82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/year/02/09/大话存储2学习笔记/</id>
    <published>2016-02-08T23:17:17.000Z</published>
    <updated>2016-02-14T12:34:06.000Z</updated>
    <content type="html"><![CDATA[<p>今天是大年初二，睡得早醒得也早。想想最近除了拜年也不算很忙，打算看看冬瓜头写的《大话存储2》，其实我刚开始也不知道这本书，我组栋梁给我墙裂推荐这本书，并且还将他的书借给我过年回家看，承蒙我组栋梁的厚爱，所以开此博客，分章纪录自己的学习心得。以下所有内容都是自己学习总结，不一定准备表达作者的意思，仅供参考。</p>
<h3 id="u5B58_u50A8_u7CFB_u7EDF_u7684_u524D_u4E16_u4ECA_u751F"><a href="#u5B58_u50A8_u7CFB_u7EDF_u7684_u524D_u4E16_u4ECA_u751F" class="headerlink" title="存储系统的前世今生"></a>存储系统的前世今生</h3><p>这个章节主要讲了存储设备的发展: 竹筒和纸张–&gt;选数管–&gt;穿孔卡–&gt;穿孔纸带–&gt;磁带–&gt;磁鼓存储器–&gt;硬盘驱动器–&gt;软盘–&gt;光盘–&gt;Flash芯片和卡式存储–&gt;磁盘阵列–&gt;大型网络化磁盘阵列。最后作者介绍了自己理解的信息，数据，数据存储，讲了信息如何影响到人类的行为以及对比人类的行为理解计算机的行为。</p>
<h3 id="u8D70_u8FDB_u8BA1_u7B97_u673AIO_u4E16_u754C"><a href="#u8D70_u8FDB_u8BA1_u7B97_u673AIO_u4E16_u754C" class="headerlink" title="走进计算机IO世界"></a>走进计算机IO世界</h3><p>理解计算机的IO世界就应该要知道计算机系统的组成。当前计算机的组成都是冯罗伊曼结构，本质上是计算，存储，控制三大部件。CPU，内存和IO设备(IO设备需要控制器读写)通过总线连接。作者将CPU，内存和磁盘比作本地的网络，通过总线连接而不是TCP/IP协议的连接。作者也讲到了CPU和内存属于同一个冲突域(连接在北桥上)，IO设备(鼠标，键盘之类的)是另一个冲突域(连接在南桥上)，但是并没有指明当前的性能瓶颈在IO。</p>
<h3 id="u78C1_u76D8_u539F_u7406_u4E0E_u6280_u672F_u8BE6_u89E3"><a href="#u78C1_u76D8_u539F_u7406_u4E0E_u6280_u672F_u8BE6_u89E3" class="headerlink" title="磁盘原理与技术详解"></a>磁盘原理与技术详解</h3><p>首先介绍了磁盘的组件概念，诸如盘面，磁道，柱面和扇区。磁盘的工作原理是先读写柱面上的数据再寻道到下一个磁道读写。然后作者类比打字机讲解了磁盘的读写过程，寻道是径向位移由步进电机来驱动，扇区是由盘片旋转移动，磁头不动来确定的，所以影响磁盘性能的关键因素分别是盘片的转速(影响连续读写)和寻道的速度(影响随机IO)。讲完磁盘以后就需要将磁盘连接到计算机系统中，这时候需要一些接口协议标准，诸如ATA(分为SATA和PATA，PATA又名IDE)和SCSI。计算机完整的使用磁盘过程是:</p>
<blockquote>
<p>1) 系统BIOS初始化执行基本的磁盘控制器驱动程序<br>2) CPU可以产生SCSI或ATA指令CDB来控制磁盘控制器<br>3) 磁盘控制器通过SCSI接口或ATA接口访问磁盘上的磁盘驱动器的控制电路，该控制电路解析指令驱动磁头臂完成IO操作。</p>
</blockquote>
<p>作者接着讲述了IOPS(IO/s)和MBPS(MB/s)来描述磁盘的性能，其实不光是磁盘，存储设备的性能都会说明这些参数。IOPS=队列深度/IO延时，队列深度增加，IO延迟也会随即增加。而IOPS就有点类似于存储设备的IO消化能力。MBPS就是吞吐量。<br>作者还介绍了固态硬盘，主要是讲了Flash介质的，其实新型存储材料的研究还包括PCM，MRAM，RRAM，FeRAM等。Flash介质的固态硬盘相对于磁盘性能快得不只一个数量级，Flash不用寻道，但是Flash也有不完美的地方比如写前擦除，写放大之类的。相应的解决策略作者也讲了一些，感觉就是野路子不够专业，其实概括起来就是磨损均衡，垃圾回收，写前预处理，预留备用空间。</p>
<h3 id="u5927_u8BDD/_u8BE6_u89E3_u4E03_u79CDRAID"><a href="#u5927_u8BDD/_u8BE6_u89E3_u4E03_u79CDRAID" class="headerlink" title="大话/详解七种RAID"></a>大话/详解七种RAID</h3><h3 id="RAID_2C__u865A_u62DF_u78C1_u76D8_2C__u5377_u548C_u6587_u4EF6_u7CFB_u7EDF_u5B9E_u6218"><a href="#RAID_2C__u865A_u62DF_u78C1_u76D8_2C__u5377_u548C_u6587_u4EF6_u7CFB_u7EDF_u5B9E_u6218" class="headerlink" title="RAID, 虚拟磁盘, 卷和文件系统实战"></a>RAID, 虚拟磁盘, 卷和文件系统实战</h3><h3 id="u5927_u8BDD_u5B58_u50A8_u9635_u5217"><a href="#u5927_u8BDD_u5B58_u50A8_u9635_u5217" class="headerlink" title="大话存储阵列"></a>大话存储阵列</h3><h3 id="u7CFB_u7EDF_u4E0E_u7CFB_u7EDF_u4E4B_u95F4_u7684_u8BED_u8A00OSI"><a href="#u7CFB_u7EDF_u4E0E_u7CFB_u7EDF_u4E4B_u95F4_u7684_u8BED_u8A00OSI" class="headerlink" title="系统与系统之间的语言OSI"></a>系统与系统之间的语言OSI</h3><h3 id="Fibre_Channel_u534F_u8BAE_u8BE6_u89E3"><a href="#Fibre_Channel_u534F_u8BAE_u8BE6_u89E3" class="headerlink" title="Fibre Channel协议详解"></a>Fibre Channel协议详解</h3><h3 id="FC_u534F_u8BAE_u7684_u5DE8_u5927_u529B_u91CF"><a href="#FC_u534F_u8BAE_u7684_u5DE8_u5927_u529B_u91CF" class="headerlink" title="FC协议的巨大力量"></a>FC协议的巨大力量</h3><h3 id="DAS_2C_SAN_u548CNAS"><a href="#DAS_2C_SAN_u548CNAS" class="headerlink" title="DAS, SAN和NAS"></a>DAS, SAN和NAS</h3><h3 id="u5927_u8BDD_u4EE5_u592A_u7F51_u548CTCP/IP_u534F_u8BAE"><a href="#u5927_u8BDD_u4EE5_u592A_u7F51_u548CTCP/IP_u534F_u8BAE" class="headerlink" title="大话以太网和TCP/IP协议"></a>大话以太网和TCP/IP协议</h3><h3 id="u5B58_u50A8_u7F51_u7EDC_u7684_u65B0_u519BIP_SAN"><a href="#u5B58_u50A8_u7F51_u7EDC_u7684_u65B0_u519BIP_SAN" class="headerlink" title="存储网络的新军IP SAN"></a>存储网络的新军IP SAN</h3><h3 id="IP_u548CFC_u878D_u5408_u7684_u7ED3_u679C"><a href="#IP_u548CFC_u878D_u5408_u7684_u7ED3_u679C" class="headerlink" title="IP和FC融合的结果"></a>IP和FC融合的结果</h3><h3 id="u865A_u62DF_u5316"><a href="#u865A_u62DF_u5316" class="headerlink" title="虚拟化"></a>虚拟化</h3><h3 id="u5B58_u50A8_u96C6_u7FA4"><a href="#u5B58_u50A8_u96C6_u7FA4" class="headerlink" title="存储集群"></a>存储集群</h3><h3 id="u6570_u636E_u4FDD_u62A4_u548C_u5907_u4EFD_u6280_u672F"><a href="#u6570_u636E_u4FDD_u62A4_u548C_u5907_u4EFD_u6280_u672F" class="headerlink" title="数据保护和备份技术"></a>数据保护和备份技术</h3><h3 id="u5927_u8BDD_u6570_u636E_u5BB9_u707E"><a href="#u5927_u8BDD_u6570_u636E_u5BB9_u707E" class="headerlink" title="大话数据容灾"></a>大话数据容灾</h3><h3 id="u6570_u636E_u524D_u5904_u7406_u4E0E_u540E_u5904_u7406"><a href="#u6570_u636E_u524D_u5904_u7406_u4E0E_u540E_u5904_u7406" class="headerlink" title="数据前处理与后处理"></a>数据前处理与后处理</h3><h3 id="u7CFB_u7EDFIO_u8DEF_u5F84_u53CA_u4F18_u5316"><a href="#u7CFB_u7EDFIO_u8DEF_u5F84_u53CA_u4F18_u5316" class="headerlink" title="系统IO路径及优化"></a>系统IO路径及优化</h3><h3 id="u5927_u8BDD_u4E91_u5B58_u50A8"><a href="#u5927_u8BDD_u4E91_u5B58_u50A8" class="headerlink" title="大话云存储"></a>大话云存储</h3>]]></content>
    <summary type="html">
    <![CDATA[<p>今天是大年初二，睡得早醒得也早。想想最近除了拜年也不算很忙，打算看看冬瓜头写的《大话存储2》，其实我刚开始也不知道这本书，我组栋梁给我墙裂推荐这本书，并且还将他的书借给我过年回家看，承蒙我组栋梁的厚爱，所以开此博客，分章纪录自己的学习心得。以下所有内容都是自己学习总结，不一]]>
    </summary>
    
      <category term="Storage" scheme="http://yoursite.com/tags/Storage/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker 实践总结]]></title>
    <link href="http://yoursite.com/year/02/06/docker-%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/year/02/06/docker-自己的实践总结/</id>
    <published>2016-02-06T12:45:33.000Z</published>
    <updated>2016-03-05T12:38:13.000Z</updated>
    <content type="html"><![CDATA[<p>这两天终于把《docker 从入门到实践》看完了，原本打算写写总结，但是感觉书中的内容太过死板，还不如从自己使用docker的过程中总结出一些好玩的docker应用方法分享给大家，欢迎有更多的人分享自己使用docker时一些好玩的项目，私信我给友情链接。</p>
<h3 id="u5236_u4F5C_u548C_u4F7F_u7528Vim_u63D2_u4EF6_u7684_u955C_u50CF"><a href="#u5236_u4F5C_u548C_u4F7F_u7528Vim_u63D2_u4EF6_u7684_u955C_u50CF" class="headerlink" title="制作和使用Vim插件的镜像"></a>制作和使用Vim插件的镜像</h3><p>如果你用关键词Vim搜索我的博客会发现有篇博客专门介绍如何使用Vim的插件来配置类似于VS的集成开发环境。现在我使用docker制作Vim插件的镜像来实现在多机上快速建立这样的VS集成开发环境。</p>
<h4 id="u5229_u7528Dockerfile_u5236_u4F5C_u955C_u50CF"><a href="#u5229_u7528Dockerfile_u5236_u4F5C_u955C_u50CF" class="headerlink" title="利用Dockerfile制作镜像"></a><font size="2"> 利用Dockerfile制作镜像 </font></h4><p>将需要打包的插件放在某个目录下:<br><img src="/about/docker/practice/1.png" alt="logo"><br>当前目录下编辑Dockerfile，将插件打包到基于ubuntu镜像创建的镜像中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:<span class="number">14.04</span></span><br><span class="line">MAINTAINER Kang Yan &lt;wowyk@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ADD . /tool</span><br></pre></td></tr></table></figure></p>
<p>制作镜像，命令如下(happymain是我在daocloud上注册的用户名，主要的原因是国内有时候无法访问docker hub，所以就使用daocloud):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t daocloud.io/happymain/tool .</span><br></pre></td></tr></table></figure></p>
<h4 id="push_u955C_u50CF_u5230daocloud"><a href="#push_u955C_u50CF_u5230daocloud" class="headerlink" title="push镜像到daocloud"></a><font size="2"> push镜像到daocloud </font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push daocloud.io/happymain/tool</span><br></pre></td></tr></table></figure>
<h4 id="u5728_u90E8_u7F72_u673A_u4E0Apull_u955C_u50CF"><a href="#u5728_u90E8_u7F72_u673A_u4E0Apull_u955C_u50CF" class="headerlink" title="在部署机上pull镜像"></a><font size="2"> 在部署机上pull镜像 </font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull daocloud.io/happymain/tool</span><br></pre></td></tr></table></figure>
<p>在一个会话中运行容器:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i daocloud.io/happymain/tool</span><br></pre></td></tr></table></figure></p>
<p>在另一个会话中导出到test.tar:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps(得到containerID)</span><br><span class="line">docker export containerID &gt; test.tar</span><br></pre></td></tr></table></figure></p>
<p>这个test.tar就是整个文件系统的所有文件，找个目录将其解压，其中的tool目录就是Vim的插件。</p>
<h4 id="u5728_u90E8_u7F72_u673A_u4E0A_u7B80_u5355_u64CD_u4F5C_u5B8C_u6210_u5B89_u88C5"><a href="#u5728_u90E8_u7F72_u673A_u4E0A_u7B80_u5355_u64CD_u4F5C_u5B8C_u6210_u5B89_u88C5" class="headerlink" title="在部署机上简单操作完成安装"></a><font size="2"> 在部署机上简单操作完成安装 </font></h4><p>1) ctags需要单独编译安装<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar xvf ctags-<span class="number">5.8</span>.tar</span><br><span class="line">cd ctags-<span class="number">5.8</span></span><br><span class="line">./configure</span><br><span class="line">make &amp; make install</span><br></pre></td></tr></table></figure></p>
<p>2) 需要将插件移到~/.vim目录下，将hello中的配置拷贝到~/.vimrc<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv * ~/.vim</span><br><span class="line">cd ~/.vim</span><br><span class="line">cp hello ~/.vimrc</span><br></pre></td></tr></table></figure></p>
<p>这样就实现了VS集成开发环境的移植，其实Github也可以做类似的工作;)</p>
<h3 id="u5F00_u53D1_u4E0E_u8FD0_u7EF4_u7684_u9694_u79BB"><a href="#u5F00_u53D1_u4E0E_u8FD0_u7EF4_u7684_u9694_u79BB" class="headerlink" title="开发与运维的隔离"></a>开发与运维的隔离</h3><p>比如说我在主机上编写代码，容器中同步更新并且可以直接运行:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i -v $(pwd):/test ubuntu:<span class="number">14.04</span></span><br></pre></td></tr></table></figure></p>
<p>结果如下:<br><img src="/about/docker/practice/2.png" alt="logo"><br>我们可以看出主机的docker目录下的文件被映射到容器中的test目录下，你可以尝试编辑主机上的test.c文件，然后观察容器中的test.c完全同步更新。所以我们甚至可以想象如果只映射test可执行文件就相当于只在容器中运维，这样的话就可以实现开发和运维的隔离。再往大的讲，我可以映射上述那样的目录后，开启多个容器共享该目录，从而实现多个用户同时编辑，运维。如下所示:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v $(pwd):/test --name test training/postgres echo hello!		 </span><br><span class="line">docker run -d --volumes-<span class="keyword">from</span> test --name test1 training/postgres</span><br><span class="line">docker run -d --volumes-<span class="keyword">from</span> test --name test2 training/postgres</span><br></pre></td></tr></table></figure></p>
<p> 在主机中编辑test.c文件并且编译以后，test1，test2容器都会同步更新并且直接可以运行，也就是说如果我只暴露test可执行文件给test1,test2，那么就可以实现开发与测试运维的隔离。 </p>
<h3 id="mysql_u5BB9_u5668_u4E0Ewordpress_u5BB9_u5668_u7684_u8FDE_u63A5"><a href="#mysql_u5BB9_u5668_u4E0Ewordpress_u5BB9_u5668_u7684_u8FDE_u63A5" class="headerlink" title="mysql容器与wordpress容器的连接"></a>mysql容器与wordpress容器的连接</h3><p>拉取mysql和wordpress镜像(使用daocloud加速器来拉取):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dao pull mysql</span><br><span class="line">dao pull wordpress</span><br></pre></td></tr></table></figure></p>
<p>运行mysql容器:</p>
<pre><code class="python">docker run -d --name mysql -e MYSQL_ROOT_PASSWORD=<span class="number">123456</span> mysql
</code></pre>
<p>连接mysql容器，运行wordpress容器:</p>
<pre><code class="python">docker run -d --name wordpress --link mysql:mysql -p <span class="number">8888</span>:<span class="number">80</span> wordpress
</code></pre>
<p>这样以后在浏览器中输入0.0.0.0:8888就可以使用wordpress，剩下的你就可以自己玩博客了。当然还有很多好玩的东西没有列举出来，欢迎大家继续分享！</p>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="http://dockerpool.com/static/books/docker_practice/index.html" target="_blank" rel="external">docker 从入门到实践</a>    </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这两天终于把《docker 从入门到实践》看完了，原本打算写写总结，但是感觉书中的内容太过死板，还不如从自己使用docker的过程中总结出一些好玩的docker应用方法分享给大家，欢迎有更多的人分享自己使用docker时一些好玩的项目，私信我给友情链接。</p>
<h3 i]]>
    </summary>
    
      <category term="Vim" scheme="http://yoursite.com/tags/Vim/"/>
    
      <category term="cloud computing" scheme="http://yoursite.com/tags/cloud-computing/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker 背后的技术]]></title>
    <link href="http://yoursite.com/year/01/23/docker%E8%83%8C%E5%90%8E%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/year/01/23/docker背后的技术/</id>
    <published>2016-01-23T15:33:41.000Z</published>
    <updated>2016-03-05T12:38:31.000Z</updated>
    <content type="html"><![CDATA[<p>最近一直都在学习使用docker，当你使用docker越久你就越发的想了解docker背后是如何实现的。其实docker的一些功能之前就已经在Linux内核中实现了，只是有些没有进入内核主线中，但是技术就是这样不会凭空产生，总是靠大量的积累，由量变到质变最后在某个时刻绽放。本文主要是介绍docker背后的内核技术namespace，cgroup，aufs。</p>
<h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a><strong>namespace</strong></h2><p>Linux namespace主要的功能就是提供内核级别的环境隔离，这有点类似于Unix中的chroot系统调用，通过修改根目录将用户jail在一个特定的目录下，这样的jail就无法访问外部的内容，而且每一个jail的pid都是1，1意味着是当前环境下的所有进程的根节点，从而实现了环境隔离。<br>Linux namespace提供如下名字空间：(官方的文档<a href="http://lwn.net/Articles/531114/" target="_blank" rel="external">namespaces in operation</a>)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|       分类        |  系统调用参数   |     内核版本     </span><br><span class="line">| UTS namespace     |  CLONE_NEWUTS   |   Linux <span class="number">2.6</span><span class="number">.19</span></span><br><span class="line">| IPC namespace     |  CLONE_NEWIPC   |   Linux <span class="number">2.6</span><span class="number">.19</span></span><br><span class="line">| PID namespace     |  CLONE_NEWPID   |   Linux <span class="number">2.6</span><span class="number">.24</span></span><br><span class="line">| Mount namespace   |  CLONE_NEWNS    |   Linux <span class="number">2.4</span><span class="number">.19</span>    </span><br><span class="line">| USER namespace    |  CLONE_NEWUSER  |started <span class="keyword">in</span> Linux <span class="number">2.6</span><span class="number">.23</span> <span class="keyword">and</span> completed <span class="keyword">in</span> Linux <span class="number">3.8</span></span><br><span class="line">| Network namespace |  CLONE_NEWNET   |started <span class="keyword">in</span> Linux <span class="number">2.6</span><span class="number">.24</span> <span class="keyword">and</span> largely completed by about Linux <span class="number">2.6</span><span class="number">.29</span></span><br></pre></td></tr></table></figure></p>
<p>接下来介绍上述namespace的用法，可以体会一下环境隔离。(我的运行环境是ubuntu14.04，内核版本是4.3.3)<br>与namespace相关的API主要是以下三个:<br>clone():创建一个新进程，具体里面的参数自己man一下<br>unshare():使某个进程脱离某个namespace<br>setns():把某个进程加入到某个namespace          </p>
<h3 id="UTS_namespace"><a href="#UTS_namespace" class="headerlink" title="UTS namespace"></a><font size="2"> UTS namespace </font></h3><p>UTS namespace主要实现环境隔离中的hostname隔离(<a href="http://stackoverflow.com/questions/5582211/what-does-define-gnu-source-imply" target="_blank" rel="external">测试代码加_GNU_SOURCE理由</a>)<br>测试代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _GNU_SOURCE</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sched.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"> </span><br><span class="line">/* 定义一个给 clone 用的栈，栈大小<span class="number">1</span>M */</span><br><span class="line"><span class="comment">#define STACK_SIZE (1024 * 1024)</span></span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"> </span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Container - inside the container!\n"</span>);</span><br><span class="line">    /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span><br><span class="line">    sethostname(<span class="string">"container"</span>,<span class="number">10</span>);	 </span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args); </span><br><span class="line">    printf(<span class="string">"Something's wrong!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Parent - start a container!\n"</span>);</span><br><span class="line">    /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span><br><span class="line">    int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | SIGCHLD, NULL);</span><br><span class="line">    /* 等待子进程结束 */</span><br><span class="line">    waitpid(container_pid, NULL, <span class="number">0</span>);</span><br><span class="line">    printf(<span class="string">"Parent - container stopped!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试结果如下:<br><img src="/about/docker/namespace/1.png" alt="logo"><br>从上面的结果可以看出clone创建的进程hostname是container，和主机的ubuntu不同，从而实现了hostname的隔离。</p>
<h3 id="IPC_namespace"><a href="#IPC_namespace" class="headerlink" title="IPC namespace"></a><font size="2"> IPC namespace </font></h3><p>IPC全称是Inter-Process Communication，也就是<a href="http://songlee24.github.io/2015/04/21/linux-IPC/" target="_blank" rel="external">进程间通信</a>。IPC包括<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">| 进程间通信方式 |                             主要用途                                 </span><br><span class="line">|  无名管道      |半双工，只能用于父子进程或兄弟进程之间通信                            </span><br><span class="line">|  命名管道(FIFO)|半双工，可以用于无关进程间通信                                        </span><br><span class="line">|  消息队列      |消息队列不一定要以先进先出的次序读取,也可以按消息的类型读取          </span><br><span class="line">|  共享内存      |多个进程访问同一块内存空间，信号量结合使用，来达到进程间的同步及互斥 </span><br><span class="line">|  信号量        |作为进程间以及同一进程不同线程之间的同步手段                         </span><br><span class="line">|  套接字        |可用于不同机器之间的进程间通信</span><br></pre></td></tr></table></figure></p>
<p>IPC namespace实现的是限制进程间通信只能发生在同一个namespace。要启动IPC隔离，只需要在调用clone时加上CLONE_NEWIPC:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWIPC  | SIGCHLD, NULL);</span><br></pre></td></tr></table></figure></p>
<p>完整代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _GNU_SOURCE</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sched.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"> </span><br><span class="line">/* 定义一个给 clone 用的栈，栈大小<span class="number">1</span>M */</span><br><span class="line"><span class="comment">#define STACK_SIZE (1024 * 1024)</span></span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"> </span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Container - inside the container!\n"</span>);</span><br><span class="line">    /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span><br><span class="line">    sethostname(<span class="string">"contain"</span>,<span class="number">10</span>);	 </span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args); </span><br><span class="line">    printf(<span class="string">"Something's wrong!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Parent - start a container!\n"</span>);</span><br><span class="line">    /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span><br><span class="line">    int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWIPC  | SIGCHLD, NULL);</span><br><span class="line">    /* 等待子进程结束 */</span><br><span class="line">    waitpid(container_pid, NULL, <span class="number">0</span>);</span><br><span class="line">    printf(<span class="string">"Parent - container stopped!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试如下：<br>无CLONE_NEWIPC时:<br><img src="/about/docker/namespace/2.png" alt="logo"><br>有CLONE_NEWIPC时:<br><img src="/about/docker/namespace/3.png" alt="logo"><br>从上面的结果可以看出，IPC被隔离了，在新创建的进程中无法看到消息队列。</p>
<h3 id="PID_namespace"><a href="#PID_namespace" class="headerlink" title="PID namespace"></a><font size="2"> PID namespace </font></h3><p>PID namespace实现的是隔离进程空间，使得新建的进程的PID是1，在传统的UNIX系统中，PID为1的进程是init，地位非常特殊。他作为所有进程的父进程，有很多特权(比如:屏蔽信号等)，另外，其还会为检查所有进程的状态，我们知道，如果某个子进程脱离了父进程(父进程没有wait它)，那么init就会负责回收资源并结束这个子进程。所以，要做到进程空间的隔离，首先要创建出PID为1的进程，最好就像chroot那样，把子进程的PID在容器内变成1。<br>现在我们在clone子进程中添加PID隔离:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD, NULL);</span><br></pre></td></tr></table></figure></p>
<p>完整代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _GNU_SOURCE</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sched.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"> </span><br><span class="line">/* 定义一个给 clone 用的栈，栈大小<span class="number">1</span>M */</span><br><span class="line"><span class="comment">#define STACK_SIZE (1024 * 1024)</span></span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"> </span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Container [%5d] - inside the container!\n"</span>,getpid());</span><br><span class="line">    /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span><br><span class="line">    sethostname(<span class="string">"container"</span>,<span class="number">10</span>);	 </span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args); </span><br><span class="line">    printf(<span class="string">"Something's wrong!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Parent [%5d] - start a container!\n"</span>,getpid());</span><br><span class="line">    /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span><br><span class="line">    int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD, NULL);</span><br><span class="line">    /* 等待子进程结束 */</span><br><span class="line">    waitpid(container_pid, NULL, <span class="number">0</span>);</span><br><span class="line">    printf(<span class="string">"Parent - container stopped!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试结果如下:<br><img src="/about/docker/namespace/4.png" alt="logo"><br>我们可以看到container的PID是1，但是有个问题，当你在子进程中输入top的时候还是会看到很多其他进程，而这些其他进程是只有父进程才看得到的，也就是说并没有完全隔离进程啊，这是因为ps, top这些命令会去读/proc文件系统，而文件系统对于父进程和子进程来说是一样的，所以还需要隔离文件系统。</p>
<h3 id="Mount_namespace"><a href="#Mount_namespace" class="headerlink" title="Mount namespace"></a><font size="2"> Mount namespace </font></h3><p>Mount namespace实现的是隔离挂载点，顾名思义，也就是说启动Mount namespace后不同进程挂载的文件系统是相互看不到的。所以测试代码中添加了CLONE_NEWNS，并且在子进程中加入了”mount -t proc proc /proc”来挂载/proc文件系统。<br>完整代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _GNU_SOURCE</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sched.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"> </span><br><span class="line">/* 定义一个给 clone 用的栈，栈大小<span class="number">1</span>M */</span><br><span class="line"><span class="comment">#define STACK_SIZE (1024 * 1024)</span></span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"> </span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Container [%5d] - inside the container!\n"</span>,getpid());</span><br><span class="line">    /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span><br><span class="line">    sethostname(<span class="string">"container"</span>,<span class="number">10</span>);	 </span><br><span class="line">    system(<span class="string">"mount -t proc proc /proc"</span>);</span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args); </span><br><span class="line">    printf(<span class="string">"Something's wrong!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Parent [%5d] - start a container!\n"</span>,getpid());</span><br><span class="line">    /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span><br><span class="line">    int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD, NULL);</span><br><span class="line">    /* 等待子进程结束 */</span><br><span class="line">    waitpid(container_pid, NULL, <span class="number">0</span>);</span><br><span class="line">    printf(<span class="string">"Parent - container stopped!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试结果如下:<br><img src="/about/docker/namespace/5.png" alt="logo"><br>从上图可以看出子进程的所有进程，PID为1的正好是新建的bash，另一个进程就是PS命令，这样mount的文件系统就看不到父进程空间中的进程，再比如输入top命令，也会发现进程很干净，结果如下:<br><img src="/about/docker/namespace/6.png" alt="logo"></p>
<h3 id="USER_namespace"><a href="#USER_namespace" class="headerlink" title="USER namespace"></a><font size="2"> USER namespace </font></h3><p>User namespace主要是提供了用户与用户组的隔离。使用CLONE_NEWUSER这个参数，容器内部看到的UID和GID已经与外部不同了，默认显示为65534。因为容器中找不到其真正的UID，所以设置了最大的UID，可通过如下命令查看:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/overflowuid</span><br></pre></td></tr></table></figure></p>
<p>要把容器中的uid和真实系统的uid给映射在一起，需要修改/proc/pid/uid_map和/proc/pid/gid_map这两个文件。这两个文件的格式是:<br>ID-inside-ns    ID-outside-ns    length</p>
<blockquote>
<p>ID-inside-ns表示容器里面显示的UID或GID。<br>ID-outside-ns表示容器外映射的真实UID或GID。<br>length表示映射范围，为1表示一一对应。</p>
</blockquote>
<p>除了上述的格式要求，对于uid/gid的映射还有几点约束:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*)写入uid_map/gid_map的进程，必须对PID进程所属user namespace拥有[CAP_SETUID/CAP_SETGID](http://man7.org/linux/man-pages/man7/capabilities<span class="number">.7</span>.html)权限</span><br><span class="line">*)写入uid_map/gid_map的进程，必须位于PID进程的parent或者child USER namespace</span><br><span class="line">*)另外需要满足如下条件之一:</span><br><span class="line">	<span class="number">1</span>)父进程将有效uid/gid映射到子进程的user namespace中</span><br><span class="line">	<span class="number">2</span>)父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid</span><br></pre></td></tr></table></figure></p>
<p>你可以通过如下命令查看(pid表示进程编号):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/&lt;pid&gt;/uid_map</span><br></pre></td></tr></table></figure></p>
<p>比如下面的例子表示把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形<br><img src="/about/docker/namespace/7.png" alt="logo"><br>现在我们来测试如下代码，如有不懂可以和我联系:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/mount.h&gt;</span><br><span class="line">#include &lt;sys/capability.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">#define STACK_SIZE (1024 * 1024)</span><br><span class="line"> </span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    "/bin/bash",</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int pipefd[2];</span><br><span class="line"> </span><br><span class="line">void set_map(char* file, int inside_id, int outside_id, int len) &#123;</span><br><span class="line">    FILE* mapfd = fopen(file, "w");</span><br><span class="line">    if (NULL == mapfd) &#123;</span><br><span class="line">        perror("open file error");</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    fprintf(mapfd, "%d %d %d", inside_id, outside_id, len);</span><br><span class="line">    fclose(mapfd);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void set_uid_map(pid_t pid, int inside_id, int outside_id, int len) &#123;</span><br><span class="line">    char file[256];</span><br><span class="line">    sprintf(file, "/proc/%d/uid_map", pid);</span><br><span class="line">    set_map(file, inside_id, outside_id, len);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void set_gid_map(pid_t pid, int inside_id, int outside_id, int len) &#123;</span><br><span class="line">    char file[256];</span><br><span class="line">    sprintf(file, "/proc/%d/gid_map", pid);</span><br><span class="line">    set_map(file, inside_id, outside_id, len);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    printf("Container [%5d] - inside the container!\n", getpid());</span><br><span class="line"> </span><br><span class="line">    printf("Container: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n",</span><br><span class="line">            (long) geteuid(), (long) getegid(), (long) getuid(), (long) getgid());</span><br><span class="line"> </span><br><span class="line">    /* 等待父进程通知后再往下执行（进程间的同步） */</span><br><span class="line">    char ch;</span><br><span class="line">    close(pipefd[1]);</span><br><span class="line">    read(pipefd[0], &amp;ch, 1);</span><br><span class="line"> </span><br><span class="line">    printf("Container [%5d] - setup hostname!\n", getpid());</span><br><span class="line">    //set hostname</span><br><span class="line">    sethostname("container",10);</span><br><span class="line"> </span><br><span class="line">    //remount "/proc" to make sure the "top" and "ps" show container's information</span><br><span class="line">    mount("proc", "/proc", "proc", 0, NULL);</span><br><span class="line"> </span><br><span class="line">    execv(container_args[0], container_args);</span><br><span class="line">    printf("Something's wrong!\n");</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int gid=getgid(), uid=getuid();</span><br><span class="line"> </span><br><span class="line">    printf("Parent: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n",</span><br><span class="line">            (long) geteuid(), (long) getegid(), (long) getuid(), (long) getgid());</span><br><span class="line"> </span><br><span class="line">    pipe(pipefd);</span><br><span class="line">  </span><br><span class="line">    printf("Parent [%5d] - start a container!\n", getpid());</span><br><span class="line"> </span><br><span class="line">    int container_pid = clone(container_main, container_stack+STACK_SIZE, </span><br><span class="line">            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | SIGCHLD, NULL);</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    printf("Parent [%5d] - Container [%5d]!\n", getpid(), container_pid);</span><br><span class="line"> </span><br><span class="line">    //To map the uid/gid, </span><br><span class="line">    //   we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent</span><br><span class="line">    //The file format is</span><br><span class="line">    //   ID-inside-ns   ID-outside-ns   length</span><br><span class="line">    //if no mapping, </span><br><span class="line">    //   the uid will be taken from /proc/sys/kernel/overflowuid</span><br><span class="line">    //   the gid will be taken from /proc/sys/kernel/overflowgid</span><br><span class="line">    set_uid_map(container_pid, 0, uid, 1);</span><br><span class="line">    set_gid_map(container_pid, 0, gid, 1);</span><br><span class="line"> </span><br><span class="line">    printf("Parent [%5d] - user/group mapping done!\n", getpid());</span><br><span class="line"> </span><br><span class="line">    /* 通知子进程 */</span><br><span class="line">    close(pipefd[1]);</span><br><span class="line"> </span><br><span class="line">    waitpid(container_pid, NULL, 0);</span><br><span class="line">    printf("Parent - container stopped!\n");</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序运行结果如下:<br><img src="/about/docker/namespace/8.png" alt="logo"><br>我们使用一个pipe来对父子进程进行同步，因为子进程中使用execv的系统调用，这个系统调用会把当前子进程的进程空间给全部覆盖掉，我们希望在execv之前就做好user namespace的uid/gid的映射，基于上述uid/gid的映射规则，我们需要父进程映射uid/gid，然后通知子进程可以执行execv。从而我们可以看到uid=0，就是说在容器中已经是root用户了，但是gid还不是0，是因为进程同步还没有完成，当你进入container的root用户时输入id就会发现如下的结果:<br><img src="/about/docker/namespace/9.png" alt="logo"><br>如果你的gid还不是0的话，有可能是内核版本问题，因为user namespace是在3.8以后才实现绝大部分的功能也就是说还会存在问题，比如安全性问题等。你可以想到的是我们运行程序的权限是普通用户，但是运行出来的容器是root，这样的安全性就可以得到提高，因为本质上还是普通用户，如果你想运行多个namespace可以在容器里使用root权限再创建多个namespace。</p>
<h3 id="Network_namespace"><a href="#Network_namespace" class="headerlink" title="Network namespace"></a><font size="2"> Network namespace </font></h3><p>首先我想用一张图介绍Docker网络部分是如何连接的:<br><img src="/about/docker/namespace/10.png" width="500" height="200" alt="logo" align="center"><br>如上图所示docker0是一个虚拟网桥，可以看成是一个软件交换机。当你安装完docker后可以使用ifconfig查看docker0分配的IP，所有的容器都可以通过docker0进行通信，当然docker0上接着的容器IP和docker0的IP处于同一网段。当创建一个Docker容器的时候，同时会创建了一对veth pair接口(当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包)。这对接口一端在容器内，即eth0;另一端在本地并被挂载到docker0网桥，名称以veth开头(例如vethAQI2QT)。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker就创建了在主机和所有容器之间一个虚拟共享网络。<br>那么上述的Network命名空间如何实现的呢?<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先我们先增加一个虚拟网桥lxcbr0, 类似于docker0</span></span><br><span class="line">brctl addbr lxcbr0</span><br><span class="line">brctl stp lxcbr0 off</span><br><span class="line">ifconfig lxcbr0 <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span>/<span class="number">24</span> up <span class="comment">#为网桥设置IP地址</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 增加一个namesapce命令为ns1(使用ip netns add命令）</span></span><br><span class="line">ip netns add ns1 </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 激活namespace中的loopback，即127.0.0.1(使用ip netns exec ns1来操作ns1中的命令)</span></span><br><span class="line">ip netns <span class="keyword">exec</span> ns1 ip link set dev lo up </span><br><span class="line"> </span><br><span class="line"><span class="comment">## 然后，我们需要增加一对虚拟网卡</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中</span></span><br><span class="line">ip link add veth-ns1 type veth peer name lxcbr0<span class="number">.1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 把veth-ns1按到namespace ns1中，这样容器中就会有一个新的网卡了</span></span><br><span class="line">ip link set veth-ns1 netns ns1</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 把容器里的veth-ns1改名为eth0（容器外会冲突，容器内就不会了）</span></span><br><span class="line">ip netns <span class="keyword">exec</span> ns1 ip link set dev veth-ns1 name eth0 </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 为容器中的网卡分配一个IP地址，并激活它</span></span><br><span class="line">ip netns <span class="keyword">exec</span> ns1 ifconfig eth0 <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span>/<span class="number">24</span> up</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上</span></span><br><span class="line">brctl addif lxcbr0 lxcbr0<span class="number">.1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 为容器增加一个路由规则，让容器可以访问外面的网络</span></span><br><span class="line">ip netns <span class="keyword">exec</span> ns1     ip route add default via <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在/etc/netns下创建network namespce名称为ns1的目录，</span></span><br><span class="line"><span class="comment"># 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了</span></span><br><span class="line">mkdir -p /etc/netns/ns1</span><br><span class="line">echo <span class="string">"nameserver 8.8.8.8"</span> &gt; /etc/netns/ns1/resolv.conf</span><br></pre></td></tr></table></figure></p>
<p>上面基本上就是docker网络的原理了，只不过，<br>Docker的resolv.conf没有用这样的方式，而是用了之前介绍的Mount Namesapce的那种方式<br>另外，docker是用进程的PID来做Network Namespace的名称的。<br>理解了上述过程后你可以给运行的docker容器增加一个新的网卡:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ip link add peerA type veth peer name peerB </span><br><span class="line">brctl addif docker0 peerA </span><br><span class="line">ip link set peerA up </span><br><span class="line">ip link set peerB netns $&#123;container-pid&#125; </span><br><span class="line">ip netns <span class="keyword">exec</span> $&#123;container-pid&#125; ip link set dev peerB name eth1 </span><br><span class="line">ip netns <span class="keyword">exec</span> $&#123;container-pid&#125; ip link set eth1 up</span><br><span class="line">ip netns <span class="keyword">exec</span> $&#123;container-pid&#125; ip addr add $&#123;ROUTEABLE_IP&#125; dev eth1</span><br></pre></td></tr></table></figure></p>
<p>你也可以实现点对点的连接:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开两个sessions, 分别运行如下命令会得到两个容器ID, 比如我得到的是481和3b8</span></span><br><span class="line">docker run -i -t --rm --net=none ubuntu:<span class="number">14.04</span> /bin/bash</span><br><span class="line">docker run -i -t --rm --net=none ubuntu:<span class="number">14.04</span> /bin/bash</span><br><span class="line"><span class="comment"># 找到这两个运行容器的进程编号9166和9206</span></span><br><span class="line">docker inspect -f <span class="string">'&#123;&#123;.State.Pid&#125;&#125;'</span> <span class="number">481</span></span><br><span class="line">docker inspect -f <span class="string">'&#123;&#123;.State.Pid&#125;&#125;'</span> <span class="number">3</span>b8</span><br><span class="line"><span class="comment"># 创建网络名字空间的跟踪文件</span></span><br><span class="line">mkdir -p /var/run/netns</span><br><span class="line">ln -s /proc/<span class="number">9166</span>/ns/net /var/run/netns/<span class="number">9166</span></span><br><span class="line">ln -s /proc/<span class="number">9206</span>/ns/net /var/run/netns/<span class="number">9206</span></span><br><span class="line"><span class="comment"># 创建一对peer接口，然后配置路由</span></span><br><span class="line">ip link add A type veth peer name B</span><br><span class="line"></span><br><span class="line">ip link set A netns <span class="number">9166</span></span><br><span class="line">ip netns <span class="keyword">exec</span> <span class="number">9166</span> ip addr add <span class="number">10.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span> dev A</span><br><span class="line">ip netns <span class="keyword">exec</span> <span class="number">9166</span> ip link set A up</span><br><span class="line">ip netns <span class="keyword">exec</span> <span class="number">9166</span> ip route add <span class="number">10.1</span><span class="number">.1</span><span class="number">.2</span>/<span class="number">32</span> dev A</span><br><span class="line"></span><br><span class="line">ip link set B netns <span class="number">9206</span></span><br><span class="line">ip netns <span class="keyword">exec</span> <span class="number">9206</span> ip addr add <span class="number">10.1</span><span class="number">.1</span><span class="number">.2</span>/<span class="number">32</span> dev B</span><br><span class="line">ip netns <span class="keyword">exec</span> <span class="number">9206</span> ip link set B up</span><br><span class="line">ip netns <span class="keyword">exec</span> <span class="number">9206</span> ip route add <span class="number">10.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span> dev B</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在这2个容器就可以相互ping通(在A中ping 10.1.1.2, B中ping 10.1.1.1)，并成功建立连接。点到点链路不需要子网和子网掩码。</span></span><br></pre></td></tr></table></figure></p>
<p>至此我们介绍了docker的网络命名空间，docker容器与docker0网桥连接原理，docker容器之间点对点连接的实现。</p>
<h2 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a><strong>cgroup</strong></h2><p>Linux cgroup全称是linux control group，是Linux内核的一个功能，主要用来限制，控制与分离一个进程组群的资源(包括CPU计算资源,内存,磁盘IO)。<br>cgroup主要提供了如下功能：</p>
<blockquote>
<p>Resource limitation: 限制资源使用，比如内存使用上限以及文件系统的缓存限制。<br>Prioritization: 优先级控制，比如：CPU利用和磁盘IO吞吐。<br>Accounting: 一些审计或一些统计，主要目的是为了计费。<br>Control: 挂起进程，恢复执行进程。</p>
</blockquote>
<p>本质上来说，cgroup是内核附加在程序上的一系列钩子(hooks)，通过程序运行时对资源的调度触发相应的钩子以达到资源追踪和限制的目的。<br>接下来我们通过三个小实验来感受一下如何限制CPU资源，memory资源，磁盘IO资源。其实Linux已经把cgroup做成一个file system，可以直接mount。</p>
<h3 id="u9650_u5236CPU"><a href="#u9650_u5236CPU" class="headerlink" title="限制CPU"></a><font size="2"> 限制CPU </font></h3><p>首先我们挂载cgroup子系统。然后查看/sys/fs/cgroup/<br><img src="/about/docker/cgroup/1.png" alt="logo"><br>你也可以用lssubsys命令查看cgroup能够限制哪些资源，初次使用会让你下载cgroup-bin，cgroup-bin会装上cgroup的所有子系统，如下图，我这里的测试主要是cpu，memory，blkio。<br><img src="/about/docker/cgroup/2.png" alt="logo"><br>正式进入限制CPU的测试:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /sys/fs/cgroup/cpu</span><br><span class="line">mkdir test</span><br><span class="line"><span class="comment"># 然后你会发现test目录下会生长出许多文件，表示的是限制CPU使用,限制进程数等</span></span><br></pre></td></tr></table></figure></p>
<p>现在我们运行一个main.c程序如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们会发现该程序极其损耗CPU资源，几乎达到100%:<br><img src="/about/docker/cgroup/3.png" alt="logo"><br>我们将之前建立的test组做一些限制，然后发现该进程的PID是4008，将该PID加入到test组中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">20000</span> &gt; /sys/fs/cgroup/cpu/test/cpu.cfs_quota_us</span><br><span class="line">echo <span class="number">4008</span> &gt; /sys/fs/cgroup/cpu/test/tasks</span><br></pre></td></tr></table></figure></p>
<p>我们会发现CPU的利用率瞬间降到20%(与我们之前设置test组的20000有关):<br><img src="/about/docker/cgroup/4.png" alt="logo"><br>于是就这样我们对CPU资源进行了限制的测试，当然也可以写多线程来对每个线程使用的CPU资源进行限制，类似上述的方法可以自己试试。</p>
<h3 id="u9650_u5236memory"><a href="#u9650_u5236memory" class="headerlink" title="限制memory"></a><font size="2"> 限制memory </font></h3><p>同理我们在memory目录中建一个test组:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /sys/fs/cgroup/memory/</span><br><span class="line">mkdir test</span><br></pre></td></tr></table></figure></p>
<p>现在我们运行一个程序不停的分配内存:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int size = <span class="number">0</span>;</span><br><span class="line">    int chunk_size = <span class="number">512</span>;</span><br><span class="line">    char *p = NULL;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ((p = (char *)malloc(sizeof(char)*chunk_size)) == NULL) &#123;</span><br><span class="line">            printf(<span class="string">"out of memory!!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(p, <span class="number">1</span>, chunk_size);</span><br><span class="line">        size += chunk_size;</span><br><span class="line">        printf(<span class="string">"[%d] - memory is allocated [%8d] bytes \n"</span>, getpid(), size);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行上述程序:<br><img src="/about/docker/cgroup/6.png" alt="logo"><br>我们将之前建立的test组做一些限制，然后发现该进程的PID是3133，将该PID加入到test组中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">10</span>k &gt; /sys/fs/cgroup/memory/test/memory.limit_in_bytes</span><br><span class="line">echo <span class="number">3133</span> &gt; /sys/fs/cgroup/memory/test/tasks</span><br></pre></td></tr></table></figure></p>
<p>于是就出现了上图中的分配到超过10kBytes时kill的情况，从而达到了限制内存的目的。</p>
<h3 id="u9650_u5236_u78C1_u76D8IO"><a href="#u9650_u5236_u78C1_u76D8IO" class="headerlink" title="限制磁盘IO"></a><font size="2"> 限制磁盘IO </font></h3><p>我们来测试如何限制硬盘的IO，模拟命令如下:(从/dev/sda1上读入数据,输出到/dev/null,/dev/null是一个“黑洞”,只能写入不能读，而且写入的文件不保存)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/sda1 of=/dev/null</span><br></pre></td></tr></table></figure></p>
<p>我们使用iotop命令测试速度如下，发现IO的速度是316.3MB/s:<br><img src="/about/docker/cgroup/7.png" alt="logo"><br>当我们使用IO限制，将该IO的PID 3382加入到test组里面时，如下代码(8:0是设备号可以通过ls -l /dev/sda1获得，1048576刚好是1M):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">'8:0 1048576'</span> &gt; /sys/fs/cgroup/blkio/test/blkio.throttle.read_bps_device</span><br><span class="line">echo <span class="number">3382</span>  &gt; /sys/fs/cgroup/blkio/test/tasks</span><br></pre></td></tr></table></figure></p>
<p>于是结果如下<br><img src="/about/docker/cgroup/8.png" alt="logo"><br>从上图可以发现我们确实将磁盘的IO操作限制在了1M，达到了限制磁盘IO的目的。</p>
<h2 id="aufs"><a href="#aufs" class="headerlink" title="aufs"></a><strong>aufs</strong></h2><p>aufs是一种union file system，所谓UnionFS就是将不同物理位置的目录合并mount到同一个目录。UnionFS的一个最主要的应用是，把一张CD/DVD和一个硬盘目录给联合mount在一起，然后，你就可以对这个只读的CD/DVD上的文件进行修改(当然，修改的文件存于硬盘上的目录里)。之前在上篇博客<a href="http://mainboy.github.io/2016/01/11/docker-入门/#more" target="_blank" rel="external">docker入门</a>中介绍过，docker的镜像都是只读的模版，当镜像运行在容器中的时候会在镜像的最上层添加一层可写层。如下图所示:<br><img src="/about/docker/aufs/1.png" width="400" height="100" alt="logo" align="center"><br>docker的分层镜像正是基于aufs实现。但是aufs并没有进入Linux内核主线(内核主线是打算发展overlayFS来取代aufs，最新的Linux内核应该已经包含overlay。)，主要是Linus不让，可能是觉得aufs写得烂，也有可能是不喜欢aufs，但是很多Linux发行版都支持aufs，比如Debian，Ubuntu。Centos不支持aufs，所以其采用的是DeviceMapper(然而并没有aufs好用)。可以查看发行版是否支持aufs<br><img src="/about/docker/aufs/2.png" alt="logo"><br>也可以看看docker是aufs驱动还是DeviceMapper驱动<br><img src="/about/docker/aufs/3.png" alt="logo"><br>docker的分层镜像，除了aufs，devicemapper，docker还支持btrfs和vfs，你可以使用-s或–storage-driver= 选项来指定相关的镜像存储</p>
<p>接下来通过几个例子来介绍aufs<br>1) 测试1<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建fruits vegetables mnt三个目录</span></span><br><span class="line">mkdir fruits vegetables mnt</span><br><span class="line"><span class="comment"># 在fruits里创建apple，tomato两个文件，vegetables里创建carrots，tomato两个文件</span></span><br><span class="line">cd ./fruits</span><br><span class="line">touch apple tomato</span><br><span class="line">cd ../vegetables</span><br><span class="line">touch carrots tomato</span><br><span class="line"><span class="comment"># 将fruits和vegetables目录union mount到./mnt目录中</span></span><br><span class="line">mount -t aufs -o dirs=./fruits:./vegetables none ./mnt</span><br><span class="line"><span class="comment"># mnt目录下会出现三个文件apple，carrots，tomato，你可能会疑问tomato是属于fruits还是vegetables，我可以先告诉你是属于fruits，后面解释为什么。</span></span><br><span class="line"><span class="comment"># 接下来做两个小测试</span></span><br><span class="line"><span class="comment"># First</span></span><br><span class="line">echo mnt &gt; ./mnt/apple</span><br><span class="line">cat ./mnt/apple</span><br><span class="line">cat ./fruits/apple</span><br><span class="line"><span class="comment"># 你会发现上述两个cat输出一样</span></span><br><span class="line"><span class="comment"># Second</span></span><br><span class="line">echo mnt_carrots &gt; ./mnt/carrots</span><br><span class="line">cat ./vegetables/carrots</span><br><span class="line">cat ./fruits/carrots</span><br><span class="line"><span class="comment"># 第一个cat没有任何输出，第二个cat输出了mnt_carrots，我们修改了./mnt/carrots的文件内容，./vegetables/carrots并没有变化，反而是./fruits目录中出现了carrots文件，其内容是我们在./mnt/carrots里的内容</span></span><br><span class="line"><span class="comment"># 原因在于我们在mount aufs命令中，并没有指定vegetables和fruits的目录权限，默认上来说，命令行上第一个(最左边)的目录是可读可写的，后面的全都是只读的，这是不是很类似docker的分层镜像？</span></span><br></pre></td></tr></table></figure></p>
<p>2) 测试2<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现在我们来设置指定权限来mount aufs，先把./fruits/carrots删掉以免干扰。</span></span><br><span class="line">mount -t aufs -o dirs=./fruits=rw:./vegetables=rw none ./mnt</span><br><span class="line"><span class="comment"># 接下来我们再做两个小实验</span></span><br><span class="line"><span class="comment"># First</span></span><br><span class="line">echo <span class="string">"mnt_carrots"</span> &gt; ./mnt/carrots</span><br><span class="line">cat ./vegetables/carrots</span><br><span class="line">cat ./fruits/carrots</span><br><span class="line"><span class="comment"># 我们设置vegetables和fruits两个目录都是可读写的，所以第一个cat有输出，第二个cat无输出符合我们的预期。</span></span><br><span class="line"><span class="comment"># Second 我们来解释tomato</span></span><br><span class="line">echo <span class="string">"mnt_tomato"</span> &gt; ./mnt/tomato</span><br><span class="line">cat ./fruits/tomato</span><br><span class="line">cat ./vegetables/tomato</span><br><span class="line"><span class="comment"># 我们发现第一个cat有输出，第二个cat没有输出，即是当有重复文件名的时候，在mount命令行上，越往前的优先级越高。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a><strong>reference</strong></h2><p>进程间通信<br><a href="http://songlee24.github.io/2015/04/21/linux-IPC/" target="_blank" rel="external">Inter-Process Communication</a></p>
<p>namespace<br><a href="http://lwn.net/Articles/531114/" target="_blank" rel="external">Namespaces in operation</a><br><a href="http://man7.org/linux/man-pages/man7/namespaces.7.html" target="_blank" rel="external">Linux Namespace Man Page</a><br><a href="http://crosbymichael.com/creating-containers-part-1.html" target="_blank" rel="external">Creating containers - Part 1</a><br><a href="http://blog.yadutaf.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/" target="_blank" rel="external">Introduction to Linux namespaces</a></p>
<p>cgroup<br><a href="https://lwn.net/Articles/484251/" target="_blank" rel="external">Fixing control groups</a><br><a href="http://lwn.net/Articles/601840/" target="_blank" rel="external">The unified control group hierarchy in 3.16</a><br><a href="http://events.linuxfoundation.org/sites/events/files/slides/2014-KLF.pdf" target="_blank" rel="external">Cgroup v2(PDF)</a></p>
<p>aufs<br><a href="http://www.linuxjournal.com/article/7714" target="_blank" rel="external">Introduce UnionFS</a><br><a href="http://lwn.net/Articles/325369/" target="_blank" rel="external">Union file systems: Implementations, part I</a><br><a href="http://lwn.net/Articles/327738/" target="_blank" rel="external">Union file systems: Implementations, part 2</a><br><a href="http://lwn.net/Articles/403012/" target="_blank" rel="external">Another union filesystem approach</a><br><a href="http://lwn.net/Articles/324291/" target="_blank" rel="external">Unioning file systems: Architecture, features, and design choices</a></p>
<p><a href="http://coolshell.cn/articles/17010.html" target="_blank" rel="external">酷壳</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近一直都在学习使用docker，当你使用docker越久你就越发的想了解docker背后是如何实现的。其实docker的一些功能之前就已经在Linux内核中实现了，只是有些没有进入内核主线中，但是技术就是这样不会凭空产生，总是靠大量的积累，由量变到质变最后在某个时刻绽放。]]>
    </summary>
    
      <category term="cloud computing" scheme="http://yoursite.com/tags/cloud-computing/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker 入门]]></title>
    <link href="http://yoursite.com/year/01/11/docker-%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/year/01/11/docker-入门/</id>
    <published>2016-01-11T05:26:05.000Z</published>
    <updated>2016-03-05T12:37:56.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/about/docker/1.png" width="500" height="200" alt="logo" align="center">        </p>
<h3 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h3><p>docker是基于LXC的容器技术，它利用Linux内核中namespace隔离进程环境，cgroup限制进程使用物理设备资源，同时创新性的将只读镜像分层，当需要在容器中运行镜像时，只需要在镜像的最外面添加一层可写层。你可以简单的将docker容器理解为进程以及运行进程所需要的轻量级环境。</p>
<p><img src="/about/docker/2.png" width="500" height="200" alt="logo" align="center"><br>如上图所示，左边是VM，右边是docker的工作层次，可以看出容器是在操作系统层面上实现的虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现的管理器。docker的优势在于比VM更轻，无需整个系统的资源环境，直接在容器中运行应用，而且支持Build once, run anywhere。缺点就是所有的容器都是运行在Linux内核上的进程，安全性值得考量，尤其是docker用在大量租户的云计算环境中。</p>
<h3 id="u955C_u50CF"><a href="#u955C_u50CF" class="headerlink" title="镜像"></a>镜像</h3><p>docker的镜像是一个只读的模版。对于镜像，你既可以从docker hub中pull下来，也可以自己利用本地文件系统创建上传到docker hub上，当然首先你需要到docker hub上注册一个账号。</p>
<h4 id="u663E_u793A_u672C_u5730_u955C_u50CF"><a href="#u663E_u793A_u672C_u5730_u955C_u50CF" class="headerlink" title="显示本地镜像"></a><font size="2"> 显示本地镜像 </font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<h4 id="pull_u955C_u50CF"><a href="#pull_u955C_u50CF" class="headerlink" title="pull镜像"></a><font size="2"> pull镜像 </font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:<span class="number">14.04</span></span><br></pre></td></tr></table></figure>
<h4 id="push_u955C_u50CF"><a href="#push_u955C_u50CF" class="headerlink" title="push镜像"></a><font size="2"> push镜像 </font></h4><p>首先需要将镜像打个标签，然后上传(af8表示镜像的ID,mainboy代表docker上注册的用户名)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag af8 mainboy/ubuntu:<span class="number">14.04</span></span><br><span class="line">docker push mainboy/ubuntu</span><br></pre></td></tr></table></figure></p>
<h4 id="u5229_u7528Dockerfile_u6765_u521B_u5EFA_u955C_u50CF"><a href="#u5229_u7528Dockerfile_u6765_u521B_u5EFA_u955C_u50CF" class="headerlink" title="利用Dockerfile来创建镜像"></a><font size="2"> 利用Dockerfile来创建镜像 </font></h4><p>利用Dockerfile创建镜像方便管理，便于上传给团队其他人分享。<br>1) 首先创建Dockerfile如下操作:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir test</span><br><span class="line">cd test</span><br><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure></p>
<p>2) 然后在Dockerfile中加入如下指令，注意每条指令都会新建镜像的一层，层数不要超过127层:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#This is a comment</span></span><br><span class="line">FROM ubuntu:<span class="number">14.04</span></span><br><span class="line">MAINTAINER mainboy &lt;wowyk@qq.com&gt;</span><br><span class="line">RUN apt-get -qq update</span><br><span class="line">RUN apt-get -qqy install ruby ruby-dev</span><br><span class="line">RUN gem install sinatra</span><br></pre></td></tr></table></figure></p>
<p>Dockerfile的基本语法:</p>
<blockquote>
<p>使用#注释<br>FROM指令告诉docker使用那个镜像作为基础<br>MAINTAINER是维护者的信息<br>RUN开头的指令会在创建中运行，比如上述的安装一些软件包</p>
</blockquote>
<p>3) 创建镜像:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t mainboy/test test/</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>-t 表示给镜像添加标签名<br>test/ 表示Dockerfile所在目录<br>创建成功后会在docker images中看到名为mainboy/test的镜像</p>
</blockquote>
<h3 id="u5BB9_u5668"><a href="#u5BB9_u5668" class="headerlink" title="容器"></a>容器</h3><p>容器是从镜像创建运行的实例。启动容器有两种方式，一种是基于镜像新建一个容器启动，另一种是将在终止状态的容器重新启动。<br>运行hello world:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu:<span class="number">14.04</span> /bin/echo <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure></p>
<p>启动一个bash终端:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu:<span class="number">14.04</span> /bin/bash</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>-t 表示给docker分配一个伪终端<br>-i 表示让容器的接受输入</p>
</blockquote>
<p>查看运行中的容器:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></p>
<p>终止一个运行中的容器:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop imageID(表示镜像的ID)</span><br></pre></td></tr></table></figure></p>
<p><font size="2"> <strong>清理容器，镜像的快捷方式:</strong> </font><br>1) 在~/.bash_aliases中加入下面快捷键<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kill all running docker</span></span><br><span class="line">alias dockerkill=<span class="string">'docker kill $(docker ps -a -q)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove all stop docker</span></span><br><span class="line">alias dockercleanc=<span class="string">'docker rm $(docker ps -a -q)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove no tag images</span></span><br><span class="line">alias dockercleani=<span class="string">'docker rmi $(docker images -q -f dangling=true)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove all stop docker and no tag images</span></span><br><span class="line">alias dockerclean=<span class="string">'dockercleanc||true&amp;&amp;dockercleani'</span></span><br></pre></td></tr></table></figure></p>
<p>2) 应用~/.bash_aliases<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_aliases</span><br></pre></td></tr></table></figure></p>
<p>3) 如上所示<br>dockercleanc直接清理掉所有停止的容器</p>
<p><font size="2"> <strong>容器的导入导出，镜像的存出载入:</strong> </font><br>1) 镜像的存出载入:<br>存出:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o ubuntu_14<span class="number">.04</span>.tar ubuntu:<span class="number">14.04</span></span><br></pre></td></tr></table></figure></p>
<p>载入:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load --input ubuntu_14<span class="number">.04</span>.tar</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; ubuntu_14<span class="number">.04</span>.tar</span><br></pre></td></tr></table></figure></p>
<p>2) 容器的导出导入:<br>导出:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export ContainerID &gt; ubuntu.tar</span><br></pre></td></tr></table></figure></p>
<p>导入:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ubuntu.tar | sudo docker <span class="keyword">import</span> - mainboy/ubuntu:<span class="number">14</span>:<span class="number">04</span></span><br></pre></td></tr></table></figure></p>
<p>或者通过指定URL或者某个目录来导入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">import</span> http://example.com/exampleimage.gz example/imagerepo</span><br></pre></td></tr></table></figure></p>
<p>3) 两者的区别:<br>容器快照文件将丢弃所有的历史记录和元数据信息(即仅保存容器当时的快照状态)，所以从容器快照文件导入时可以重新指定标签等元数据信息，而镜像存储文件将保存完整记录，体积也要大一些。</p>
<h3 id="u4ED3_u5E93"><a href="#u4ED3_u5E93" class="headerlink" title="仓库"></a>仓库</h3><p>仓库是存放镜像文件的场所。仓库又分为公开仓库和私有仓库，一般情况公开仓库指的是docker hub，类似于github。私有仓库指的是本地网络下搭建的私有仓库。<br>如何向docker hub上传镜像之前已经说过，如果你想让其他人和你一起修改你的镜像，可以在docker hub的Collaborators中添加那个人，这和github是类似的，下面简单介绍一下如何在本地建立自己的私有仓库来管理镜像。<br>1) 运行docker-registry镜像，这是官方提供的用于构建私有镜像的仓库<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p <span class="number">5000</span>:<span class="number">5000</span> -v /home/de66/registry:/tmp/registry registry</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，仓库会被创建在容器的<em>/tmp/registry</em>下，如果是按照上面的方式运行registry，如果你在本地上传的镜像会存储在<em>/home/de66/registry/repositories/library/</em>下<br>2) 上传镜像方式和上传到docker hub上的方式相同，原本应该是本地IP，但是docker只支持https的方式，默认是http，这个问题还没有解决，现在也没有这个需求，所以我暂时就只是用localhost上传。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag imageID localhost:<span class="number">5000</span>/test</span><br></pre></td></tr></table></figure></p>
<p>3) push镜像<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push localhost:<span class="number">5000</span>/test</span><br></pre></td></tr></table></figure></p>
<p>4) pull镜像<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull localhost:<span class="number">5000</span>/test</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/about/docker/1.png" width="500" height="200" alt="logo" align="center">        </p>
<h3 id="u7B80_u4ECB"><a href="#u7B80_u4ECB]]>
    </summary>
    
      <category term="cloud computing" scheme="http://yoursite.com/tags/cloud-computing/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gem5]]></title>
    <link href="http://yoursite.com/year/01/06/gem5/"/>
    <id>http://yoursite.com/year/01/06/gem5/</id>
    <published>2016-01-06T12:50:17.000Z</published>
    <updated>2016-01-12T14:31:56.000Z</updated>
    <content type="html"><![CDATA[<h4 id="gem5_u7B80_u4ECB"><a href="#gem5_u7B80_u4ECB" class="headerlink" title="gem5简介"></a>gem5简介</h4><p>GEM5是一款模块化的离散事件驱动全系统模拟器，它结合了M5和GEMS中最优秀的部分，是一款高度可配置、集成多种ISA和多种CPU模型的体系结构模拟器。M5是由Michigan大学开发的一款开源的多处理机模拟器，受到了业内的广泛关注，很多高水平论文都采用M5作为研究工具。另一方面，Wisconsin推出的GEMS能够对储存层次进行详细而灵活的模拟，包括对多种不同的cache一致性协议和互联模型的支持。目前的GEM5是M5和GEMS的一个紧耦合版本。<br>GEM5已经能够支持多种商用ISA，包括X86、ARM、ALPHA、MIPS、Power、SPARC等，并且能够在X86、ARM、ALPHA上加载操作系统。</p>
<h4 id="gem5_u7CFB_u7EDF_u6A21_u578B"><a href="#gem5_u7CFB_u7EDF_u6A21_u578B" class="headerlink" title="gem5系统模型"></a>gem5系统模型</h4><p>gem5支持两种不同的系统模型:SE(syscall emulation)和FS(full system)。</p>
<blockquote>
<p>SE模型<br>SE模型能够仿真大部分操作系统级服务，能够取得很好功能模拟加速比。<br>FS模型<br>FS模型模拟完整的全系统，包括OS，运行在用户态和核心态的线程调度以及各种设备。能够精确模拟系统时间等开销。</p>
</blockquote>
<h4 id="gem5_u7684_u5B89_u88C5_u4F7F_u7528"><a href="#gem5_u7684_u5B89_u88C5_u4F7F_u7528" class="headerlink" title="gem5的安装使用"></a>gem5的安装使用</h4><p>首先需要介绍一下我的运行环境,我的环境是在虚拟机上安装的ubuntu14.04, 分配了2个CPU, 当然CPU越多越好,后面会讲为什么。其次是内存尽量足够, 4G应该是够的, 不然编译的过程中可能会出错。安装时将ubuntu提升到root权限。<br><strong>1)安装相关的工具</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install mercurial scons swig gcc m4 python python-dev libprotobuf-dev libgoogle-perftools-dev g++</span><br></pre></td></tr></table></figure></p>
<p>简要介绍一下上述工具:<br>mercurial是一个类似于git的软件版本控制工具,主要是负责下载和更新gem5的。<br>scons是类似于make的自动编译链接工具。区别就是make是寻找当前目录的Makefile文件, scons是寻找当前目录的SConstruct配置文件。<br>swig是将C++程序封装以后供给python调用。<br>gcc与g++是C/C++的编译和链接工具,因为gem5对其版本有要求,所以我们这里相当于更新一下。<br>python和python-dev是支持python的工具<br>libprotobuf-dev和libgoogle-perftools-dev是google的一套序列化工具。类似于XML的功能, 将结构化的数据进行序列化存储或传输, 在另一端进行反序列化。protobuf支持C++、Java、Python 三种语言的 API, 它的主要优点就是快, 简单易学。</p>
<p><strong>2)下载gem5</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hg clone http://repo.gem5.org/gem5</span><br></pre></td></tr></table></figure></p>
<p><strong>3)构建gem5</strong>(-j<n>中,n=2*cpu的个数,为编译过程分配n个人物,多线程编译,速度会提升)我选择的是ALPHA指令集架构,当然也可以用其他的架构ARM/X86等。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scons build/ALPHA/gem5.opt -j4</span><br></pre></td></tr></table></figure></n></p>
<p>上述过程可能会失败：<br><strong>问题1)</strong>如果zlib.h文件没找到就需要安装<a href="http://www.zlib.net" target="_blank" rel="external">zlib-1.2.8</a>下载以后将zlib-1.2.8加入gem5<br>进入zlib-1.2.8目录执行下面命令：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p><strong>问题2)</strong>如果出现有关protobuf相关的问题就去下载<a href="https://developers.google.com/protocol-buffers/docs/downloads?hl=zh-cn" target="_blank" rel="external">protobuf-2.6.1</a>, 完成以后将protobuf-2.6.1加入gem5<br>同样进入protobuf-2.6.1目录执行下面命令：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p>同时需要将下面的代码加入~/.bashrc文件里面(下面第三行的/home/yankang/MyItem/gem5/protobuf-2.6.1替换成你的protobuf-2.6.1所在目录)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export LIBRARY_PATH=$LIBRARY_PATH:/usr/local/lib</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib</span><br><span class="line">export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/home/yankang/MyItem/gem5/protobuf-<span class="number">2.6</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></p>
<p>如果不加上述三行，会找不到protobuf-2.6.1的。</p>
<p><strong>4)测试hello world</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/ALPHA/gem5.opt configs/example/se.py -c tests/test-progs/hello/bin/alpha/linux/hello</span><br></pre></td></tr></table></figure></p>
<p>可以清楚的看见hello world被打印出来。<br><img src="/about/gem5/1.png" alt="logo"><br>可以看出几点:<br>Gem5是精确级模拟, 因为它内部的最小计时单位是tick, 而1秒=1万亿ticks。<br>可以通过gdb访问7000端口从而进行调试工作。</p>
<h4 id="gem5_u5168_u7CFB_u7EDF_u6A21_u62DF"><a href="#gem5_u5168_u7CFB_u7EDF_u6A21_u62DF" class="headerlink" title="gem5全系统模拟"></a>gem5全系统模拟</h4><p>*)首先下载系统<a href="http://www.m5sim.org/dist/current/m5_system_2.0b3.tar.bz2" target="_blank" rel="external">镜像</a></p>
<p>*)新建一个目录full_system_images, 将上述压缩包解压到full_system_images目录中, 并用pwd得到镜像所在目录, 我的目录在<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/yankang/MyItem/full_system_images/</span><br></pre></td></tr></table></figure></p>
<p>*)将镜像目录重定向到~/.bashrc中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"export M5_PATH=/home/yankang/MyItem/full_system_images/"</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<p>*)开启全系统仿真:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/ALPHA/gem5.opt configs/example/fs.py</span><br></pre></td></tr></table></figure></p>
<p>如图:<br><img src="/about/gem5/2.png" alt="logo"><br>从该结果可以看出:<br>通过3456端口可以访问全系统。<br>于是开启另一个终端, 在gem5目录中输入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd util/term/</span><br></pre></td></tr></table></figure></p>
<p>进入上述目录以后输入make, 即可编译出m5term。<br>接着输入:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m5term localhost <span class="number">3456</span></span><br></pre></td></tr></table></figure></p>
<p>就可以进入系统结果如图:<br><img src="/about/gem5/3.png" alt="logo"><br>输入clear即可清屏:<br>再输入ls就可以看到如下图:<br><img src="/about/gem5/4.png" alt="logo"><br>benchmarks中有一些测试程序:<br>进入以后可以看到下图:<br><img src="/about/gem5/5.png" alt="logo"><br>我们可以测试一下pthread_mutex_test:<br><img src="/about/gem5/6.png" alt="logo"><br>同时我们也可以尝试将hello world程序加入到这个系统里面<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ./tests/test-progs/hello/bin/alpha/linux/hello ./hello</span><br></pre></td></tr></table></figure></p>
<p>然后将镜像系统挂载在/mnt上:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o,loop,offset=<span class="number">32256</span> ../full_system_images/disks/linux-latest.img /mnt/</span><br></pre></td></tr></table></figure></p>
<p>将hello拷贝到/mnt<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp hello /mnt</span><br></pre></td></tr></table></figure></p>
<p>ls的结果如下图:<br><img src="/about/gem5/7.png" alt="logo"><br>可以看到hello进入了镜像系统然后解挂载:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount /mnt</span><br></pre></td></tr></table></figure></p>
<p>重新进入全系统模拟结果如图:<br><img src="/about/gem5/8.png" alt="logo"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="gem5_u7B80_u4ECB"><a href="#gem5_u7B80_u4ECB" class="headerlink" title="gem5简介"></a>gem5简介</h4><p>GEM5是一款模块化的离散事件驱动全系统模拟器，它结合了M5和GEM]]>
    </summary>
    
      <category term="Architecture" scheme="http://yoursite.com/tags/Architecture/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim]]></title>
    <link href="http://yoursite.com/year/01/06/Vim/"/>
    <id>http://yoursite.com/year/01/06/Vim/</id>
    <published>2016-01-06T08:20:55.000Z</published>
    <updated>2016-01-06T08:49:58.000Z</updated>
    <content type="html"><![CDATA[<p>在Linux下编写程序时，拥有一套类似于VS的集成开发环境可以大大提高程序的阅读和编写效率。本文介绍如何安装vim, ctags, cscope, Taglist, SuperTab, OmniCppComplete, Winmanager, NERDTree和MiniBufExplorer等组件。最后的界面类似于如下:<br><img src="/about/Vim/1.png" alt="logo"></p>
<p>在安装之前将权限提升到root, 以后尽量使用root权限<br>ubuntu下：sudo su然后输入密码</p>
<h4 id="u5B89_u88C5vim"><a href="#u5B89_u88C5vim" class="headerlink" title="安装vim"></a>安装vim</h4><pre><code>apt-get install vim
</code></pre><h4 id="u5B89_u88C5_u4F7F_u7528ctags"><a href="#u5B89_u88C5_u4F7F_u7528ctags" class="headerlink" title="安装使用ctags"></a>安装使用ctags</h4><p>ctags是利用堆栈实现的能快速定位符号的工具。<br>安装方法：<br>1)从<a href="http://ctags.sourceforge.net/" target="_blank" rel="external">http://ctags.sourceforge.net/</a>下载源代码包后，解压缩生成源代码目录<br>2)然后进入源代码根目录执行./configure<br>3)然后执行make<br>4)编译成功后执行make install<br>5)最后将ctrl-F12组合键映射到生成ctags的命令，需要在~/.vimrc(没有就新建)里面添加<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map &lt;C-F12&gt; :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .&lt;CR&gt;</span><br></pre></td></tr></table></figure></p>
<p>使用ctags的方法:<br>使用vim打开源代码目录里面的文件，然后同时按下ctrl和F12键生成tags。<br>简单的使用就是<br>Ctrl-]    跳转到光标所在符号的定义。<br>Ctrl-t    回到上次跳转前的位置</p>
<p>更多的功能通过命令man ctags或在vim的命令行模式下(命令行模式就是在正常打开vim后输入:就进入命令行模式)执行help ctags查询。</p>
<h4 id="u5B89_u88C5_u4F7F_u7528cscope"><a href="#u5B89_u88C5_u4F7F_u7528cscope" class="headerlink" title="安装使用cscope"></a>安装使用cscope</h4><p>安装cscope的方法:<br>1)从<a href="http://cscope.sourceforge.net/" target="_blank" rel="external">http://cscope.sourceforge.net/</a>下载源代码包后，解压缩生成源代码目录<br>2)然后进入源代码根目录执行./configure<br>3)然后执行make<br>4)编译成功后执行make install<br>5)将文件<a href="http://cscope.sourceforge.net/cscope_maps.vim" target="_blank" rel="external">http://cscope.sourceforge.net/cscope_maps.vim</a>下载到~/.vim/plugin目录，如果没有该目录就新建。</p>
<p>使用cscope的方法:<br>1) 生成cscope数据库文件，进入项目代码根目录运行命令<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscope -Rbq -f ./a.out</span><br></pre></td></tr></table></figure></p>
<p>2)打开源代码的根目录下的文件在vim的命令下输入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cs add ./a.out</span><br></pre></td></tr></table></figure></p>
<p>将数据库加载进来</p>
<p>Cscope常用快捷键<br>Ctrl-\ s 查找所有当前光标所在符号出现过位置。<br>Ctrl-\ c 查找所有调用当前光标所在函数的函数。</p>
<p>在命令行下输入cw还可以重选。<br>为了使cscope展现的更好看，在~/.vimrc里面添加如下行<br>set cscopequickfix=s-,c-,d-,i-,t-,e-</p>
<h4 id="u5B89_u88C5_u4F7F_u7528Taglist"><a href="#u5B89_u88C5_u4F7F_u7528Taglist" class="headerlink" title="安装使用Taglist"></a>安装使用Taglist</h4><p>1）从<a href="http://www.vim.org/scripts/script.php?script_id=273" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=273</a>下载安装包，也可以从<a href="http://vim-taglist.sourceforge.net/index.html" target="_blank" rel="external">http://vim-taglist.sourceforge.net/index.html</a>下载。<br>2）进入~/.vim目录，将Taglist安装包解压，解压后会在~/.vim目录中生成几个新子目录，如plugin和doc（安装其它插件时，可能还会新建autoload等其它目录）。<br>3）进入~/.vim/doc目录，在Vim下运行”helptags .”命令。此步骤是将doc下的帮助文档加入到Vim的帮助主题中，这样我们就可以通过在Vim中运行“help taglist.txt”查看taglist帮助。<br>4）打开配置文件~/.vimrc，加入以下两行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let Tlist_Show_One_File=<span class="number">1</span></span><br><span class="line">let Tlist_Exit_OnlyWindow=<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>在命令行下输入TlistToggle命令就可以打开Taglist窗口。</p>
<h4 id="u5B89_u88C5_u4F7F_u7528OmniCppComplete"><a href="#u5B89_u88C5_u4F7F_u7528OmniCppComplete" class="headerlink" title="安装使用OmniCppComplete"></a>安装使用OmniCppComplete</h4><p>OmniCppComplete主要提供输入时实时提供类或结构体的属性或方法的提示和补全。跟Talist一样，OmniCppComplete也是一个Vim插件，同样依赖与Ctags工具生成的tags文件。安装步骤跟Taglist类似。<br>从<a href="http://www.vim.org/scripts/script.php?script_id=1520" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=1520</a>下载安装包后。<br>1）进入~/.vim目录，将安装版解压缩<br>2）进入~/.vim/doc目录，在Vim命令行下运行”helptags .”<br>3）在~/.vimrc中加入以下几行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set nocp</span><br><span class="line">filetype plugin on</span><br></pre></td></tr></table></figure></p>
<h4 id="u5B89_u88C5_u4F7F_u7528SuperTab"><a href="#u5B89_u88C5_u4F7F_u7528SuperTab" class="headerlink" title="安装使用SuperTab"></a>安装使用SuperTab</h4><p>SuperTab使Tab快捷键具有更快捷的上下文提示功能。跟OmniCppComplete一样，SuperTab也是一个Vim插件。<br>从<a href="http://www.vim.org/scripts/script.php?script_id=1643" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=1643</a>下载安装版。这个安装包跟先前的几个Vim插件不同，它是一个vba文件，即Vimball格式的安装包，这种格式安装包提供傻瓜式的安装插件的方法。<br>1）用Vim打开.vba安装包文件。<br>2）在Vim命令行下运行命令“UseVimball ~/.vim”。此命令将安装包解压缩到~/.vim目录。VImball安装方式的便利之处在于你可以在任何目录打开.vba包安装，而不用切换到安装目的地目录。而且不用运行helptags命令安装帮助文档。<br>3）在~/.vimrc文件中加入以下这行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let g:SuperTabDefaultCompletionType=<span class="string">"context"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="u5B89_u88C5_u4F7F_u7528Winmanager_2C_NERDTree_u548CMiniBufExplorer"><a href="#u5B89_u88C5_u4F7F_u7528Winmanager_2C_NERDTree_u548CMiniBufExplorer" class="headerlink" title="安装使用Winmanager, NERDTree和MiniBufExplorer"></a>安装使用Winmanager, NERDTree和MiniBufExplorer</h4><p>前面介绍的几个工具和插件，主要提供快捷的编辑功能，如定义跳转，符号查询，符号提示与补全等。这里的三个插件，主要优化布置VIm的界面。具体来说，NERDTree提供树形浏览文件系统的界面，MiniBufExplorer提供多文件同时编辑功能，而Winmanager将这NERDTree界面和Taglist界面整合起来，使Vim更像VS！<br>分别从<a href="http://www.vim.org/scripts/script.php?script_id=1658" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=1658</a><br><a href="http://www.vim.org/scripts/script.php?script_id=159" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=159</a><br><a href="http://www.vim.org/scripts/script.php?script_id=95" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=95</a><br>下载NERDTree，MiniBufExplorer和Winmanager安装包（Winmanager还有个更新的vba版本<a href="http://www.vim.org/scripts/script.php?script_id=1440" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=1440</a>，这里选用旧版本的Winmanger）。<br>1）像其它插件一样，将NERDTree安装包解压到~/.vim目录。并进入doc目录，在Vim命令行下运行”helptags .”命令。<br>2）MiniBufExplorer只有一个.vim文件，将其拷贝到~/.vim/plugin目录。<br>3）在~/.vimrc文件中加入以下几行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let g:miniBufExplMapWindowNavVim = <span class="number">1</span> </span><br><span class="line">let g:miniBufExplMapWindowNavArrows = <span class="number">1</span> </span><br><span class="line">let g:miniBufExplMapCTabSwitchBufs = <span class="number">1</span> </span><br><span class="line">let g:miniBufExplModSelTarget = <span class="number">1</span></span><br><span class="line">let g:miniBufExplMoreThanOne=<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>4）将Winmanager安装包解压到~/.vim目录。<br>5）在~/.vimrc文件中加入以下几行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let g:NERDTree_title=<span class="string">"[NERDTree]"</span></span><br><span class="line">let g:winManagerWindowLayout=<span class="string">"NERDTree|TagList"</span></span><br><span class="line"></span><br><span class="line">function! NERDTree_Start()</span><br><span class="line">	<span class="keyword">exec</span> <span class="string">'NERDTree'</span></span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">function! NERDTree_IsValid()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">nmap wm :WMToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure></p>
<p>6）这个版本的Winmanager好像有个小bug，你在打开Winmanager界面时，会同时打开一个空的文件。这会影响后续使用，所以我们要在打开Winmanager时关掉这个空文件。在~/.vim/plugin目录下的winmanager.vim文件中找到以下函数定义并在第5行下添加第6行的内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function! &lt;SID&gt;ToggleWindowsManager()</span><br><span class="line">	<span class="keyword">if</span> IsWinManagerVisible()</span><br><span class="line">		call s:CloseWindowsManager()</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		call s:StartWindowsManager()</span><br><span class="line">	exe <span class="string">'q'</span></span><br><span class="line">	end</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure></p>
<p>这样同时按下w-m就可以打开集成环境。</p>
<h4 id="u5176_u4ED6_u6709_u7528_u7684_7E/-vimrc_u914D_u7F6E"><a href="#u5176_u4ED6_u6709_u7528_u7684_7E/-vimrc_u914D_u7F6E" class="headerlink" title="其他有用的~/.vimrc配置"></a>其他有用的~/.vimrc配置</h4><p>在~/.vimrc里面加入：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">colo evening</span><br><span class="line">set nu</span><br><span class="line">set autoindent</span><br><span class="line">set tabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line">set mouse=a</span><br><span class="line">set hlsearch</span><br><span class="line"></span><br><span class="line">" 执行特定命令并保留光标位置及搜索历史</span><br><span class="line">function! Preserve(command)</span><br><span class="line">	let _s=@/</span><br><span class="line">	let l = line(".")</span><br><span class="line">	let c = col(".")</span><br><span class="line">	execute a:command</span><br><span class="line"></span><br><span class="line">	let @/=_s</span><br><span class="line">		call cursor(l, c)</span><br><span class="line">	endfunction</span><br><span class="line">" 格式化全文</span><br><span class="line">function! FullFormat()</span><br><span class="line">	call Preserve("normal gg=G")</span><br><span class="line">endfunction</span><br><span class="line">nmap &lt;M-F9&gt; :call FullFormat()&lt;CR&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Linux下编写程序时，拥有一套类似于VS的集成开发环境可以大大提高程序的阅读和编写效率。本文介绍如何安装vim, ctags, cscope, Taglist, SuperTab, OmniCppComplete, Winmanager, NERDTree和MiniBu]]>
    </summary>
    
      <category term="Vim" scheme="http://yoursite.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图着色问题]]></title>
    <link href="http://yoursite.com/year/01/03/%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/year/01/03/图着色问题/</id>
    <published>2016-01-03T04:12:08.000Z</published>
    <updated>2016-01-06T11:57:56.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u95EE_u9898_u63CF_u8FF0_3A"><a href="#u95EE_u9898_u63CF_u8FF0_3A" class="headerlink" title="问题描述:"></a>问题描述:</h4><p>给出一张图，节点有n个，总共有k种颜色，将k种颜色分配给这n个点，使得在图中的每条边所连接的两个点的颜色不同。这是一个NP问题，如果从精确算法去求解，则会很难在多项式时间内确定求解，所以我们从组合优化的角度对其进行求解。下面描述了禁忌搜索算法和多种混合进化算法处理思路。</p>
<h4 id="u542F_u53D1_u5F0F_u641C_u7D22"><a href="#u542F_u53D1_u5F0F_u641C_u7D22" class="headerlink" title="启发式搜索"></a>启发式搜索</h4><h5 id="1-_u7981_u5FCC_u641C_u7D22"><a href="#1-_u7981_u5FCC_u641C_u7D22" class="headerlink" title="1.禁忌搜索"></a>1.禁忌搜索</h5><p>第一步:随机产生一个初始解，即将每个点随机分配一种颜色，并计算f, f代表当前解的矛盾数(矛盾是指相邻节点颜色相同)。可以利用所有的矛盾数相加除以2求得。<br>第二步:初始化M矩阵,M是一个二维矩阵(如下图)，记录每个点着不同的颜色的不同矛盾数。<br><img src="/about/Graphcoloring/1.jpeg" alt="logo"><br><img src="/about/Graphcoloring/2.png" alt="logo"><br>第三步:判断是否有解即每个点涂色后对应的M都是0。可以用f=0表示有解, 若有解则退出。<br>第四步:若不解,则需考虑能使f最快下降的Δf, Δf理应是个负数, 但是陷入局部最优的时候也是可以接受正数的, 考虑非禁忌的最好解, 保存最小的Δf, 若有多组最好解则按照1/n的概率选择新的最好解。禁忌的最好解的处理方式也是同样的。<br>第五步:若禁忌的最好解严格优于非禁忌的最好解且严格优于历史最优f_best，则接受禁忌的最好解，否则接受非禁忌的最好解。<br>第六步:更新M表，并且将新加入的解设为禁忌解，禁忌长度为当前迭代次数+当前矛盾数+1到10的随机数。再走第三步。(如何区分禁忌解与非禁忌解,如果禁忌长度大于当前迭代次数则是禁忌解, 否则解禁为非禁忌解。)</p>
<h5 id="2-_u6DF7_u5408_u8FDB_u5316_u641C_u7D22"><a href="#2-_u6DF7_u5408_u8FDB_u5316_u641C_u7D22" class="headerlink" title="2.混合进化搜索"></a>2.混合进化搜索</h5><p>混合方式: 交替选择父代中图同颜色最多的组，依次标上1~k种颜色, 然后去掉属于该组的所有元素, 最后若有未被分配的节点, 则随机涂色。如图所示<br><img src="/about/Graphcoloring/3.jpeg" alt="logo"></p>
<p>混合进化1:<br>十个子代构成种群，随机选择两个进行杂交(杂交方式如上图)，然后将结果进行禁忌搜索，用得到的新解，替换原先的十个种群中最差的解，(ps：一种是直接替换最差的解，一种是新解比原先最差的解要好的时候才替换。其实测试两种效果差不多。)</p>
<p>混合进化2:<br>只有两个初始解,将两个解作为父代s1,s2.s1杂交s2得到一种解s1’,s2杂交s1得到一种解s2’,将s1’禁忌得到的解直接替换替换s1,将s2’禁忌得到的解直接替换替换s2,重复操作。直至求解。</p>
<p>混合进化3:<br>思想和第二种大致相同,但是它会在每次把上一个十代的最好解替换当前的某个父代。这种方法是考虑到疏散性与集中性的平衡,其实生活的哲学也是一种平衡。这种处理方法是最快能够求解的，如果需要源码和测试案例可以邮箱联系我。</p>
<h4 id="u7ED3_u8BBA"><a href="#u7ED3_u8BBA" class="headerlink" title="结论"></a>结论</h4><p>对于NP问题的研究感觉需要很多灵感，需要借鉴各个领域的知识，这也从另一方面说明了计算机科学是一个舶来品的科学。关于NP?=P一直都无法解决，很多研究人员所做的事情更像是炼丹，炼出来的结果不错就可以发论文。当然解决这些问题本身也是很有趣的，也很有价值，如果将每个点都赋予权值，就会有sum-coloring问题，如果再把每个点当成集群的节点，就会有比如负载均衡，资源分配的问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u95EE_u9898_u63CF_u8FF0_3A"><a href="#u95EE_u9898_u63CF_u8FF0_3A" class="headerlink" title="问题描述:"></a>问题描述:</h4><p>给出一张图，节点有n个，总共有k]]>
    </summary>
    
      <category term="NP" scheme="http://yoursite.com/tags/NP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MicroBlaze Simple IO Test]]></title>
    <link href="http://yoursite.com/year/01/03/MicroBlaze-Simple-IO-Test/"/>
    <id>http://yoursite.com/year/01/03/MicroBlaze-Simple-IO-Test/</id>
    <published>2016-01-03T02:03:31.000Z</published>
    <updated>2016-01-06T14:30:31.000Z</updated>
    <content type="html"><![CDATA[<p>本实验使用Digilent Anvyl Spartan6 FPGA开发套件，只需要使用EDK中的Xilinx Platform Studio.(XPS) 务必注意后面的备注Could not detect MDM peripheral on hardware.这是我写博文的主要原因,竟然被这么一个愚蠢的问题给卡住了。。。</p>
<p>第一步：在XPS操作<br>(1)点击Create New Project Using Base System Builder<br><img src="/about/microblaze/1.jpeg" alt="logo"><br>(2)选择安装路径及命名<br><img src="/about/microblaze/2.png" alt="logo"><br>(3)FPGA选择XC6SLX45，封装为csg484，按下图配置，一定要记住你是高电平复位还是低电平复位(这是我写这篇文档的重要原因)<br><img src="/about/microblaze/3.jpeg" alt="logo"><br>(4)按下图配置, 需要在Add Device中找到开关, LED灯, 串口加入。点击Finish<br><img src="/about/microblaze/4.jpeg" alt="logo"><br>(5)去掉CLK_N, 将CLK_P改成CLK得到下图<br><img src="/about/microblaze/5.png" alt="logo"><br>(6)进入.mhs和.ucf文件<br>进入.mhs将DIFFERENTIAL_POLARITY = P去掉<br><img src="/about/microblaze/6.jpeg" alt="logo"><br>进入.ucf加入以下引脚绑定<br><img src="/about/microblaze/7.png" alt="logo"><br>(7)点击Generate BitStream 开始生成, 若出现bug再重新点击Generate BitStream生成</p>
<p>第二步：进入SDK平台<br>(1)在XPS环境中导出SDK：<br>先选择XPS环境中Project下的“Export Hardware Design To SDK …”<br><img src="/about/microblaze/8.jpeg" alt="logo"><br>在弹出的对话框中选择“Export &amp; Launch SDK”<br><img src="/about/microblaze/9.png" alt="logo"><br>(2)选择工作目录，最好在SDK下面新建一个SDK_workspace文件夹, 点击OK<br><img src="/about/microblaze/10.png" alt="logo"><br>(3)如下图所示界面，稍等片刻<br><img src="/about/microblaze/11.jpeg" alt="logo"><br>导入完成，出现如下界面，此时的CPU_SYS_hw_platform平台为默认的平台，我们可以理解为硬件平台。现在就完全进入了SDK环境，此后就可以从Windows界面直接进入。<br><img src="/about/microblaze/12.png" alt="logo"><br>(4)新建一个工程，选择Xilinx C Project，点击Next<br><img src="/about/microblaze/13.jpeg" alt="logo"><br>(5)选择 Hello World 模板，点Next<br><img src="/about/microblaze/14.jpeg" alt="logo"><br>(6)生成成功，点击Finish 即可<br><img src="/about/microblaze/15.jpeg" alt="logo"><br>此时的模版已经生成，在里面hello_world_0下展开会有src文件夹，其中的helloworld.c可以进行编写，但是此时的程序已经是一个完整的程序，运行即可。</p>
<p>(7)由于要点亮LED灯，为简单起见，我们类似于上面的模版生成一个Peripheral Tests模版，如下图，点Next<br><img src="/about/microblaze/16.jpeg" alt="logo"><br>弹出下图所示界面后等待，如下图，完成后点Finish<br><img src="/about/microblaze/17.jpeg" alt="logo"><br>(8)Build Project<br>右键点击peripheral_test_o在弹出的选项中选择Build Project，或者在工具栏中的Project下选择Build Project<br><img src="/about/microblaze/18.png" alt="logo"><br>(9)Program FPGA<br>单击工具栏的Program FPGA图标，如下图所示，或者在Xilinx Tools中选择Program FPGA<br><img src="/about/microblaze/19.jpeg" alt="logo"><br>在弹出的下图中选择相应目录下的.bit文件和.bmm文件（一般选择_bd的那一个），然后点击Program即可<br><img src="/about/microblaze/20.png" alt="logo"><br>当进度条跑满的时候就表示下载成功</p>
<p>重新认识下工具栏中比较常用的几个，如下图所示。<br>第一个红色框框住的图标表示Program FPGA，这在前面已经用到过；<br>绿色框所示的图标为Debug模式下进行调试用的，一般会在完善程序的时候用到；<br>紫色框所示图标即为最常用的验证程序是否运行正确时使用到的，本次实验我们就点击这个图标，然后观察FPGA开发板上面的外围设备有没有按照预期的结果运行。<br><img src="/about/microblaze/21.jpeg" alt="logo"><br>(10)运行程序<br>点击上面提到的紫色框中图标右侧的小三角，选择“Run Configurations … ”或者在直接在菜单栏Run下面的选项中选择“Run Configurations … ”弹出如下图所示对话框<br>先选中左侧的peripheral_test_0.elf，在右侧的STDIO Connection下，先选中Connect STDIO to Console复选框，再在Port下拉菜单中选择COM1(这要看你的设备也可能是COM4等等)，点击右下的Apply后，点Run即可<br><img src="/about/microblaze/22.jpeg" alt="logo"><br>此时，程序已经运行起来，因为是第一次设置，所以上述步骤不可省略。<br>运行完后观察FPGA开发板，可以看到8个LED灯依次亮起，打开串口调试工具并正确设置后也可以看到在接收区出现如下图所示输出，这充分表明Microblaze和SDK中的程序均正确运行起来。(如果我们在硬件平台设计时使用了“调试串口”，不需要专用的串口调试软件，在SDK的Console中就可以看到下面的信息)<br><img src="/about/microblaze/23.png" alt="logo"><br>备注:如果你出现下面这种错误, 处理方法, 想想之前是RESET设置的高电平还是低电平重置, 如果是高电平重置,则当你Program一定要将RESET置为低电平, 否则置为高电平, 切记！<br><img src="/about/microblaze/24.png" alt="logo"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本实验使用Digilent Anvyl Spartan6 FPGA开发套件，只需要使用EDK中的Xilinx Platform Studio.(XPS) 务必注意后面的备注Could not detect MDM peripheral on hardware.这是我写博文的]]>
    </summary>
    
      <category term="Hardware" scheme="http://yoursite.com/tags/Hardware/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[组合数学]]></title>
    <link href="http://yoursite.com/year/01/02/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    <id>http://yoursite.com/year/01/02/组合数学/</id>
    <published>2016-01-02T08:04:42.000Z</published>
    <updated>2016-01-27T01:01:54.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u524D_u8FF0"><a href="#u524D_u8FF0" class="headerlink" title="前述"></a>前述</h4><p>组合数学：<br>1) C(n,m)=C(n,n-m)经常拿来预处理提高程序的执行效率。<br>还有很多需要总结的，还没想好，先放着。</p>
<h4 id="POJ2249"><a href="#POJ2249" class="headerlink" title="POJ2249"></a>POJ2249</h4><p>题目描述：求组合数C(n,2)。<br>解题思路：如果直接相乘肯定会在中途溢出，所以用贪心的策略，每乘一个数，用尽量多的除数去把它除掉，如果再用64保存结果应该更加保险一点。<br>源代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,k;</span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;k)==<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (n==<span class="number">0</span>&amp;&amp;k==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (n-k&lt;k)</span><br><span class="line">			k=n-k;</span><br><span class="line">		int i,m=k;</span><br><span class="line">		__int64 mul=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=k;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			mul = mul*(n-m+i);</span><br><span class="line">			<span class="keyword">while</span> (mul%k==<span class="number">0</span>&amp;&amp;k&gt;<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				mul /= k;</span><br><span class="line">				k--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(<span class="string">"%I64d\n"</span>,mul);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1833"><a href="#POJ1833" class="headerlink" title="POJ1833"></a>POJ1833</h4><p>题目描述：大家知道，给出正整数n，则1到n这n个数可以构成n！种排列，把这些排列按照从小到大的顺序（字典顺序）列出，如n=3时，列出1 2 3，1 3 2，2 1 3，2 3 1，3 1 2，3 2 1六个排列。 </p>
<p>任务描述：<br>给出某个排列，求出这个排列的下k个排列，如果遇到最后一个排列，则下1排列为第1个排列，即排列1 2 3…n。<br>比如：n = 3，k=2 给出排列2 3 1，则它的下1个排列为3 1 2，下2个排列为3 2 1，因此答案为3 2 1。</p>
<p>解决思路：1. 使用next_permutation函数  2.模拟这个查找过程，先找右边第一个逆序的数，将其右边略大于它的数放在其位置，将右边剩下的数和它按从小到大排序即完成一次next_permutation。</p>
<p>源代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int m,n,k,i,a[<span class="number">1024</span>+<span class="number">5</span>];</span><br><span class="line">	scanf(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			scanf(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		<span class="keyword">while</span> (k--)</span><br><span class="line">			next_permutation(a,a+n);</span><br><span class="line">		printf(<span class="string">"%d"</span>,a[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">			printf(<span class="string">" %d"</span>,a[i]);</span><br><span class="line">		printf(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1844"><a href="#POJ1844" class="headerlink" title="POJ1844"></a>POJ1844</h4><p>题目描述：给你一个数S让你用1～N，用这些自然数通过加减得到S，要求N最小。<br>比如12=－1+2+3+4+5+6-7<br>解题思路：S＝(1+N)<em>N/2  - 偶数，这很容易想到。那么偶数等于(1+N)</em>N/2-S, 现在要证明为什么(1+N)<em>N/2-S是偶数就能得到S，首先(1+N)</em>N/2-S &lt; (1+N)<em>N的也就是偶数 &lt; (1+N)</em>N，我们知道偶数是通过翻转1～N中的若干数得到，只要他不超过(1+N)<em>N就可以翻转得到，因此此N是可以通过加减得到S的，另外N从小到大依次找，第一个能使(1+N)</em>N/2-S为偶数的既是N最小。<br>源代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,i;</span><br><span class="line">	scanf(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	int sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;sum&lt;n||(sum-n)%<span class="number">2</span>==<span class="number">1</span>;i++)</span><br><span class="line">		sum += i;</span><br><span class="line">	printf(<span class="string">"%d\n"</span>,i-<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u524D_u8FF0"><a href="#u524D_u8FF0" class="headerlink" title="前述"></a>前述</h4><p>组合数学：<br>1) C(n,m)=C(n,n-m)经常拿来预处理提高程序的执行效率。<br>还有很多]]>
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[字符串]]></title>
    <link href="http://yoursite.com/year/01/02/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/year/01/02/字符串/</id>
    <published>2016-01-02T07:57:19.000Z</published>
    <updated>2016-01-27T01:00:44.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u524D_u8FF0"><a href="#u524D_u8FF0" class="headerlink" title="前述"></a>前述</h4><p>首先介绍一些技巧总结：<br>1) scanf与gets的区别：scanf读取到空格或换行，gets读取到换行。<br>2) 需要保存最后输出字符串的时候可以自定义数组char ch[max]来保存，记得加串尾。<br>3) string.h里面一些常用的函数memcpy，strcpy，strcmp，strchr，strstr，strlen， strtok。<br>ctype.h里面一些常用函数isalnum, isalpha, isdigit, islower/isupper, tolower/toupper。</p>
<p>现在再谈谈POJ上面的一些处理字符串类型的题目</p>
<h4 id="POJ1598"><a href="#POJ1598" class="headerlink" title="POJ1598"></a>POJ1598</h4><p>题目描述：给你K个小写字母组成的单词，E个句子，先要你输出包含K个单词中的单词数目最多的句子，如有多个这样的句子，不要求顺序的输出。句子匹配不考虑大小写。<br>解题思路：网上可能有些其他的思路比如STL，排序之类的，这里我采用字符处理提取单词的方法，然后进行匹配计数，最后输出等于最大计数的句子。<br>源代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;ctype.h&gt;</span></span><br><span class="line">char pattern[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line">char inStr[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line">int cnt[<span class="number">205</span>];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int k,e,set=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%d%d"</span>,&amp;k,&amp;e)==<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(cnt,<span class="number">0</span>,sizeof(cnt));</span><br><span class="line">		int i,j,m,max=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">			scanf(<span class="string">"%s"</span>,&amp;pattern[i]);</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;e;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			gets(inStr[i]);</span><br><span class="line">			int len=strlen(inStr[i]);</span><br><span class="line">			char ch[<span class="number">105</span>];</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				int a=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">while</span> (isalpha(inStr[i][j]))</span><br><span class="line">				&#123;</span><br><span class="line">					ch[a++] = tolower(inStr[i][j]);</span><br><span class="line">					j++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (a&gt;<span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ch[a]=<span class="string">'\0'</span>;</span><br><span class="line">					<span class="keyword">for</span> (m=<span class="number">0</span>;m&lt;k;m++)</span><br><span class="line">						<span class="keyword">if</span> (strcmp(ch,pattern[m])==<span class="number">0</span>)</span><br><span class="line">						&#123;</span><br><span class="line">							cnt[i]++;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;e;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (cnt[i] &gt; max)</span><br><span class="line">			&#123;</span><br><span class="line">				max = cnt[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(<span class="string">"Excuse Set #%d\n"</span>,set++);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;e;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (max==cnt[i])</span><br><span class="line">				printf(<span class="string">"%s\n"</span>,inStr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1782"><a href="#POJ1782" class="headerlink" title="POJ1782"></a>POJ1782</h4><p>题目描述：题意不容易理解，主要是需要你重新编码。规则如下：<br>1）将连续相同的字符串依次输出个数，字符，如果个数大于9就需要重新使用编码规则<br>2）将不相同的字符串首尾各添加1，在不相同的字符串中如果出现1就将其转换成2个1<br>解题思路：每次记录上一个字符与当前字符比较，如果相等将计数＋1，如果计数达到8就可以输出并且将计数清0，为什么我这里处理是8，因为个数等于9需要比较8次。如果不相等就一直循环到相等的时候退出，在此过程中需要保存不相同的字符串，如果遇到1就保存2个1，最后还需要在前面和后面都添加1，到字符相等的时候就输出。<br>源代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define N 10000+5</span></span><br><span class="line"></span><br><span class="line">char str[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(NULL != gets(str))</span><br><span class="line">	&#123;</span><br><span class="line">		int i,len = strlen(str),cnt=<span class="number">0</span>;</span><br><span class="line">		char c = str[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (cnt==<span class="number">8</span>)&#123;</span><br><span class="line">				printf(<span class="string">"%d%c"</span>,cnt+<span class="number">1</span>,c);</span><br><span class="line">				cnt=<span class="number">0</span>;</span><br><span class="line">				c=str[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (c == str[i])</span><br><span class="line">				cnt++;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (cnt&gt;<span class="number">0</span>&amp;&amp;cnt&lt;<span class="number">9</span>)&#123;</span><br><span class="line">					printf(<span class="string">"%d%c"</span>,cnt+<span class="number">1</span>,c);</span><br><span class="line">					cnt=<span class="number">0</span>;</span><br><span class="line">					c=str[i];</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					char ch[N];</span><br><span class="line">					int j=<span class="number">0</span>;</span><br><span class="line">					ch[j++]=<span class="string">'1'</span>;</span><br><span class="line">					<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span> (str[i]==c||i&gt;=len)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">if</span> (i==len)</span><br><span class="line">							&#123;</span><br><span class="line">								<span class="keyword">if</span> (str[i-<span class="number">1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">									ch[j++]=<span class="string">'1'</span>;</span><br><span class="line">									ch[j++]=<span class="string">'1'</span>;</span><br><span class="line">								&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">									ch[j++]=str[i-<span class="number">1</span>];</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">							ch[j++]=<span class="string">'1'</span>;</span><br><span class="line">							ch[j]=<span class="string">'\0'</span>;</span><br><span class="line">							printf(<span class="string">"%s"</span>,ch);</span><br><span class="line">							<span class="keyword">if</span> (i!=len)</span><br><span class="line">								cnt++;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (str[i-<span class="number">1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">							ch[j++]=<span class="string">'1'</span>;</span><br><span class="line">							ch[j++]=<span class="string">'1'</span>;</span><br><span class="line">						&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">							ch[j++]=str[i-<span class="number">1</span>];</span><br><span class="line">						&#125;</span><br><span class="line">						c=str[i];</span><br><span class="line">						i++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;   </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1936"><a href="#POJ1936" class="headerlink" title="POJ1936"></a>POJ1936</h4><p>题目描述：给你两个字符串s和t，判断s是否是t的子串。这里的子串之意就是s字符串中每个字符的先后顺序在t中的顺序也应该一样。<br>解题思路：此题应该很容易想到字符比较，如果si==ti则都往后推1，否则t往后推。<br>源代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#define N 100000+5</span></span><br><span class="line">char s[N],t[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%s%s"</span>,&amp;s,&amp;t)==<span class="number">2</span>)&#123;</span><br><span class="line">		int lens=strlen(s),lent=strlen(t);</span><br><span class="line">		int i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">		bool flag=false;</span><br><span class="line">		<span class="keyword">while</span> (i&lt;lens&amp;&amp;j&lt;lent)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i]==t[j])&#123;</span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i==lens)</span><br><span class="line">			printf(<span class="string">"Yes\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			printf(<span class="string">"No\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1790"><a href="#POJ1790" class="headerlink" title="POJ1790"></a>POJ1790</h4><p>题目描述：给你一串数字s，分成权数和基数，要求权数小于基数。求解有多少种分法？比如1234可以分成<br>(1-2-3)4, (1-2)34, (12)34, (1)234。<br>解题思路：类似于动态规划的思想，分别处理基数长度为1～数字串长度－1，然后将所有的种数相加，那么怎么比较？使用strncmp()函数。cnt[i]表示以s+i起始的基数总共有多少种分法。cnt[i]应该加上所有以len-i为基数的cnt。<br>源代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line">char s[<span class="number">100</span>+<span class="number">5</span>];</span><br><span class="line">int cnt[<span class="number">100</span>+<span class="number">5</span>];</span><br><span class="line">int len;</span><br><span class="line"></span><br><span class="line">int num(int cur)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (s[len-cur]==<span class="string">'0'</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	int i;</span><br><span class="line">	cnt[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=len-cur;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cnt[i]=<span class="number">0</span>;</span><br><span class="line">		int minn;</span><br><span class="line">		<span class="keyword">if</span> (i-cur&lt;<span class="number">0</span>)</span><br><span class="line">			minn=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			minn=i-cur;</span><br><span class="line">		<span class="keyword">for</span> (int j=minn; j&lt;i; j++)&#123;  </span><br><span class="line">			<span class="keyword">if</span> ((j+<span class="number">1</span>&lt;i || j==<span class="number">0</span> &amp;&amp; len-cur&gt;<span class="number">1</span>) &amp;&amp; s[j]==<span class="string">'0'</span>) <span class="keyword">continue</span>;  </span><br><span class="line">			<span class="keyword">if</span> (j+cur==i) <span class="keyword">if</span> (strncmp(s+j,s+len-cur,cur)&gt;=<span class="number">0</span>) <span class="keyword">continue</span>;  </span><br><span class="line">			cnt[i]+=cnt[j];  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cnt[len-cur];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%s"</span>,&amp;s)==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (s[<span class="number">0</span>]==<span class="string">'#'</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		int ans=<span class="number">0</span>,i;</span><br><span class="line">		len = strlen(s);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">			ans+=num(i);</span><br><span class="line">		<span class="keyword">if</span> (ans&gt;<span class="number">0</span>)</span><br><span class="line">			printf(<span class="string">"The code %s can represent %d numbers.\n"</span>,s,ans);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			printf(<span class="string">"The code %s is invalid.\n"</span>,s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u524D_u8FF0"><a href="#u524D_u8FF0" class="headerlink" title="前述"></a>前述</h4><p>首先介绍一些技巧总结：<br>1) scanf与gets的区别：scanf读取到空格或换行，gets读取]]>
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
  </entry>
  
</feed>
