<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Kiss]]></title>
  <subtitle><![CDATA[less is more]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-02-08T11:39:11.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[yankang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[docker 实践总结]]></title>
    <link href="http://yoursite.com/year/02/06/docker-%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/year/02/06/docker-自己的实践总结/</id>
    <published>2016-02-06T12:45:33.000Z</published>
    <updated>2016-02-08T11:39:11.000Z</updated>
    <content type="html"><![CDATA[<p>这两天终于把《docker 从入门到实践》看完了，原本打算写写总结，但是感觉书中的内容太过死板，还不如从自己使用docker的过程中总结出一些好玩的docker应用方法分享给大家，欢迎有更多的人分享自己使用docker时一些好玩的项目，私信我给友情链接。</p>
<h3 id="u5236_u4F5C_u548C_u4F7F_u7528Vim_u63D2_u4EF6_u7684_u955C_u50CF"><a href="#u5236_u4F5C_u548C_u4F7F_u7528Vim_u63D2_u4EF6_u7684_u955C_u50CF" class="headerlink" title="制作和使用Vim插件的镜像"></a>制作和使用Vim插件的镜像</h3><p>如果你用关键词Vim搜索我的博客会发现有篇博客专门介绍如何使用Vim的插件来配置类似于VS的集成开发环境。现在我使用docker制作Vim插件的镜像来实现在多机上快速建立这样的VS集成开发环境。</p>
<h4 id="u5229_u7528Dockerfile_u5236_u4F5C_u955C_u50CF"><a href="#u5229_u7528Dockerfile_u5236_u4F5C_u955C_u50CF" class="headerlink" title="利用Dockerfile制作镜像"></a><font size="2"> 利用Dockerfile制作镜像 </font></h4><p>将需要打包的插件放在某个目录下:<br><img src="/about/docker/practice/1.png" alt="logo"><br>当前目录下编辑Dockerfile，将插件打包到基于ubuntu镜像创建的镜像中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:<span class="number">14.04</span></span><br><span class="line">MAINTAINER Kang Yan &lt;wowyk@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ADD . /tool</span><br></pre></td></tr></table></figure></p>
<p>制作镜像，命令如下(happymain是我在daocloud上注册的用户名，主要的原因是国内有时候无法访问docker hub，所以就使用daocloud):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t daocloud.io/happymain/tool .</span><br></pre></td></tr></table></figure></p>
<h4 id="push_u955C_u50CF_u5230daocloud"><a href="#push_u955C_u50CF_u5230daocloud" class="headerlink" title="push镜像到daocloud"></a><font size="2"> push镜像到daocloud </font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push daocloud.io/happymain/tool</span><br></pre></td></tr></table></figure>
<h4 id="u5728_u90E8_u7F72_u673A_u4E0Apull_u955C_u50CF"><a href="#u5728_u90E8_u7F72_u673A_u4E0Apull_u955C_u50CF" class="headerlink" title="在部署机上pull镜像"></a><font size="2"> 在部署机上pull镜像 </font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull daocloud.io/happymain/tool</span><br></pre></td></tr></table></figure>
<p>在一个会话中运行容器:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i daocloud.io/happymain/tool</span><br></pre></td></tr></table></figure></p>
<p>在另一个会话中导出到test.tar:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps(得到containerID)</span><br><span class="line">docker export containerID &gt; test.tar</span><br></pre></td></tr></table></figure></p>
<p>这个test.tar就是整个文件系统的所有文件，找个目录将其解压，其中的tool目录就是Vim的插件。</p>
<h4 id="u5728_u90E8_u7F72_u673A_u4E0A_u7B80_u5355_u64CD_u4F5C_u5B8C_u6210_u5B89_u88C5"><a href="#u5728_u90E8_u7F72_u673A_u4E0A_u7B80_u5355_u64CD_u4F5C_u5B8C_u6210_u5B89_u88C5" class="headerlink" title="在部署机上简单操作完成安装"></a><font size="2"> 在部署机上简单操作完成安装 </font></h4><p>1) ctags需要单独编译安装<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar xvf ctags-<span class="number">5.8</span>.tar</span><br><span class="line">cd ctags-<span class="number">5.8</span></span><br><span class="line">./configure</span><br><span class="line">make &amp; make install</span><br></pre></td></tr></table></figure></p>
<p>2) 需要将插件移到~/.vim目录下，将hello中的配置拷贝到~/.vimrc<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv * ~/.vim</span><br><span class="line">cd ~/.vim</span><br><span class="line">cp hello ~/.vimrc</span><br></pre></td></tr></table></figure></p>
<p>这样就实现了VS集成开发环境的移植，其实Github也可以做类似的工作;)</p>
<h3 id="u5F00_u53D1_u4E0E_u8FD0_u7EF4_u7684_u9694_u79BB"><a href="#u5F00_u53D1_u4E0E_u8FD0_u7EF4_u7684_u9694_u79BB" class="headerlink" title="开发与运维的隔离"></a>开发与运维的隔离</h3><p>比如说我在主机上编写代码，容器中同步更新并且可以直接运行:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i -v $(pwd):/test ubuntu:<span class="number">14.04</span></span><br></pre></td></tr></table></figure></p>
<p>结果如下:<br><img src="/about/docker/practice/2.png" alt="logo"><br>我们可以看出主机的docker目录下的文件被映射到容器中的test目录下，你可以尝试编辑主机上的test.c文件，然后观察容器中的test.c完全同步更新。所以我们甚至可以想象如果只映射test可执行文件就相当于只在容器中运维，这样的话就可以实现开发和运维的隔离。再往大的讲，我可以映射上述那样的目录后，开启多个容器共享该目录，从而实现多个用户同时编辑，运维。如下所示:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v $(pwd):/test --name test training/postgres echo hello!		 </span><br><span class="line">docker run -d --volumes-<span class="keyword">from</span> test --name test1 training/postgres</span><br><span class="line">docker run -d --volumes-<span class="keyword">from</span> test --name test2 training/postgres</span><br></pre></td></tr></table></figure></p>
<p> 在主机中编辑test.c文件并且编译以后，test1，test2容器都会同步更新并且直接可以运行，也就是说如果我只暴露test可执行文件给test1,test2，那么就可以实现开发与测试运维的隔离。 </p>
<h3 id="mysql_u5BB9_u5668_u4E0Ewordpress_u5BB9_u5668_u7684_u8FDE_u63A5"><a href="#mysql_u5BB9_u5668_u4E0Ewordpress_u5BB9_u5668_u7684_u8FDE_u63A5" class="headerlink" title="mysql容器与wordpress容器的连接"></a>mysql容器与wordpress容器的连接</h3><p>拉取mysql和wordpress镜像(使用daocloud加速器来拉取):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dao pull mysql</span><br><span class="line">dao pull wordpress</span><br></pre></td></tr></table></figure></p>
<p>运行mysql容器:</p>
<pre><code class="python">docker run -d --name mysql -e MYSQL_ROOT_PASSWORD=<span class="number">123456</span> mysql
</code></pre>
<p>连接mysql容器，运行wordpress容器:</p>
<pre><code class="python">docker run -d --name wordpress --link mysql:mysql -p <span class="number">8888</span>:<span class="number">80</span> wordpress
</code></pre>
<p>这样以后在浏览器中输入0.0.0.0:8888就可以使用wordpress，剩下的你就可以自己玩博客了。当然还有很多好玩的东西没有列举出来，欢迎大家继续分享！</p>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="http://dockerpool.com/static/books/docker_practice/index.html" target="_blank" rel="external">docker 从入门到实践</a>    </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这两天终于把《docker 从入门到实践》看完了，原本打算写写总结，但是感觉书中的内容太过死板，还不如从自己使用docker的过程中总结出一些好玩的docker应用方法分享给大家，欢迎有更多的人分享自己使用docker时一些好玩的项目，私信我给友情链接。</p>
<h3 i]]>
    </summary>
    
      <category term="Vim" scheme="http://yoursite.com/tags/Vim/"/>
    
      <category term="cloud computing" scheme="http://yoursite.com/tags/cloud-computing/"/>
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker 背后的技术]]></title>
    <link href="http://yoursite.com/year/01/23/docker%E8%83%8C%E5%90%8E%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/year/01/23/docker背后的技术/</id>
    <published>2016-01-23T15:33:41.000Z</published>
    <updated>2016-02-04T16:10:26.000Z</updated>
    <content type="html"><![CDATA[<p>最近一直都在学习使用docker，当你使用docker越久你就越发的想了解docker背后是如何实现的。其实docker的一些功能之前就已经在Linux内核中实现了，只是有些没有进入内核主线中，但是技术就是这样不会凭空产生，总是靠大量的积累，由量变到质变最后在某个时刻绽放。本文主要是介绍docker背后的内核技术namespace，cgroup，aufs。</p>
<h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a><strong>namespace</strong></h2><p>Linux namespace主要的功能就是提供内核级别的环境隔离，这有点类似于Unix中的chroot系统调用，通过修改根目录将用户jail在一个特定的目录下，这样的jail就无法访问外部的内容，而且每一个jail的pid都是1，1意味着是当前环境下的所有进程的根节点，从而实现了环境隔离。<br>Linux namespace提供如下名字空间：(官方的文档<a href="http://lwn.net/Articles/531114/" target="_blank" rel="external">namespaces in operation</a>)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|       分类        |  系统调用参数   |     内核版本     </span><br><span class="line">| UTS namespace     |  CLONE_NEWUTS   |   Linux <span class="number">2.6</span><span class="number">.19</span></span><br><span class="line">| IPC namespace     |  CLONE_NEWIPC   |   Linux <span class="number">2.6</span><span class="number">.19</span></span><br><span class="line">| PID namespace     |  CLONE_NEWPID   |   Linux <span class="number">2.6</span><span class="number">.24</span></span><br><span class="line">| Mount namespace   |  CLONE_NEWNS    |   Linux <span class="number">2.4</span><span class="number">.19</span>    </span><br><span class="line">| USER namespace    |  CLONE_NEWUSER  |started <span class="keyword">in</span> Linux <span class="number">2.6</span><span class="number">.23</span> <span class="keyword">and</span> completed <span class="keyword">in</span> Linux <span class="number">3.8</span></span><br><span class="line">| Network namespace |  CLONE_NEWNET   |started <span class="keyword">in</span> Linux <span class="number">2.6</span><span class="number">.24</span> <span class="keyword">and</span> largely completed by about Linux <span class="number">2.6</span><span class="number">.29</span></span><br></pre></td></tr></table></figure></p>
<p>接下来介绍上述namespace的用法，可以体会一下环境隔离。(我的运行环境是ubuntu14.04，内核版本是4.3.3)<br>与namespace相关的API主要是以下三个:<br>clone():创建一个新进程，具体里面的参数自己man一下<br>unshare():使某个进程脱离某个namespace<br>setns():把某个进程加入到某个namespace          </p>
<h3 id="UTS_namespace"><a href="#UTS_namespace" class="headerlink" title="UTS namespace"></a><font size="2"> UTS namespace </font></h3><p>UTS namespace主要实现环境隔离中的hostname隔离(<a href="http://stackoverflow.com/questions/5582211/what-does-define-gnu-source-imply" target="_blank" rel="external">测试代码加_GNU_SOURCE理由</a>)<br>测试代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _GNU_SOURCE</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sched.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"> </span><br><span class="line">/* 定义一个给 clone 用的栈，栈大小<span class="number">1</span>M */</span><br><span class="line"><span class="comment">#define STACK_SIZE (1024 * 1024)</span></span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"> </span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Container - inside the container!\n"</span>);</span><br><span class="line">    /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span><br><span class="line">    sethostname(<span class="string">"container"</span>,<span class="number">10</span>);	 </span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args); </span><br><span class="line">    printf(<span class="string">"Something's wrong!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Parent - start a container!\n"</span>);</span><br><span class="line">    /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span><br><span class="line">    int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | SIGCHLD, NULL);</span><br><span class="line">    /* 等待子进程结束 */</span><br><span class="line">    waitpid(container_pid, NULL, <span class="number">0</span>);</span><br><span class="line">    printf(<span class="string">"Parent - container stopped!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试结果如下:<br><img src="/about/docker/namespace/1.png" alt="logo"><br>从上面的结果可以看出clone创建的进程hostname是container，和主机的ubuntu不同，从而实现了hostname的隔离。</p>
<h3 id="IPC_namespace"><a href="#IPC_namespace" class="headerlink" title="IPC namespace"></a><font size="2"> IPC namespace </font></h3><p>IPC全称是Inter-Process Communication，也就是<a href="http://songlee24.github.io/2015/04/21/linux-IPC/" target="_blank" rel="external">进程间通信</a>。IPC包括<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">| 进程间通信方式 |                             主要用途                                 </span><br><span class="line">|  无名管道      |半双工，只能用于父子进程或兄弟进程之间通信                            </span><br><span class="line">|  命名管道(FIFO)|半双工，可以用于无关进程间通信                                        </span><br><span class="line">|  消息队列      |消息队列不一定要以先进先出的次序读取,也可以按消息的类型读取          </span><br><span class="line">|  共享内存      |多个进程访问同一块内存空间，信号量结合使用，来达到进程间的同步及互斥 </span><br><span class="line">|  信号量        |作为进程间以及同一进程不同线程之间的同步手段                         </span><br><span class="line">|  套接字        |可用于不同机器之间的进程间通信</span><br></pre></td></tr></table></figure></p>
<p>IPC namespace实现的是限制进程间通信只能发生在同一个namespace。要启动IPC隔离，只需要在调用clone时加上CLONE_NEWIPC:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWIPC  | SIGCHLD, NULL);</span><br></pre></td></tr></table></figure></p>
<p>完整代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _GNU_SOURCE</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sched.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"> </span><br><span class="line">/* 定义一个给 clone 用的栈，栈大小<span class="number">1</span>M */</span><br><span class="line"><span class="comment">#define STACK_SIZE (1024 * 1024)</span></span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"> </span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Container - inside the container!\n"</span>);</span><br><span class="line">    /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span><br><span class="line">    sethostname(<span class="string">"contain"</span>,<span class="number">10</span>);	 </span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args); </span><br><span class="line">    printf(<span class="string">"Something's wrong!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Parent - start a container!\n"</span>);</span><br><span class="line">    /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span><br><span class="line">    int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWIPC  | SIGCHLD, NULL);</span><br><span class="line">    /* 等待子进程结束 */</span><br><span class="line">    waitpid(container_pid, NULL, <span class="number">0</span>);</span><br><span class="line">    printf(<span class="string">"Parent - container stopped!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试如下：<br>无CLONE_NEWIPC时:<br><img src="/about/docker/namespace/2.png" alt="logo"><br>有CLONE_NEWIPC时:<br><img src="/about/docker/namespace/3.png" alt="logo"><br>从上面的结果可以看出，IPC被隔离了，在新创建的进程中无法看到消息队列。</p>
<h3 id="PID_namespace"><a href="#PID_namespace" class="headerlink" title="PID namespace"></a><font size="2"> PID namespace </font></h3><p>PID namespace实现的是隔离进程空间，使得新建的进程的PID是1，在传统的UNIX系统中，PID为1的进程是init，地位非常特殊。他作为所有进程的父进程，有很多特权(比如:屏蔽信号等)，另外，其还会为检查所有进程的状态，我们知道，如果某个子进程脱离了父进程(父进程没有wait它)，那么init就会负责回收资源并结束这个子进程。所以，要做到进程空间的隔离，首先要创建出PID为1的进程，最好就像chroot那样，把子进程的PID在容器内变成1。<br>现在我们在clone子进程中添加PID隔离:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD, NULL);</span><br></pre></td></tr></table></figure></p>
<p>完整代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _GNU_SOURCE</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sched.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"> </span><br><span class="line">/* 定义一个给 clone 用的栈，栈大小<span class="number">1</span>M */</span><br><span class="line"><span class="comment">#define STACK_SIZE (1024 * 1024)</span></span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"> </span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Container [%5d] - inside the container!\n"</span>,getpid());</span><br><span class="line">    /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span><br><span class="line">    sethostname(<span class="string">"container"</span>,<span class="number">10</span>);	 </span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args); </span><br><span class="line">    printf(<span class="string">"Something's wrong!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Parent [%5d] - start a container!\n"</span>,getpid());</span><br><span class="line">    /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span><br><span class="line">    int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD, NULL);</span><br><span class="line">    /* 等待子进程结束 */</span><br><span class="line">    waitpid(container_pid, NULL, <span class="number">0</span>);</span><br><span class="line">    printf(<span class="string">"Parent - container stopped!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试结果如下:<br><img src="/about/docker/namespace/4.png" alt="logo"><br>我们可以看到container的PID是1，但是有个问题，当你在子进程中输入top的时候还是会看到很多其他进程，而这些其他进程是只有父进程才看得到的，也就是说并没有完全隔离进程啊，这是因为ps, top这些命令会去读/proc文件系统，而文件系统对于父进程和子进程来说是一样的，所以还需要隔离文件系统。</p>
<h3 id="Mount_namespace"><a href="#Mount_namespace" class="headerlink" title="Mount namespace"></a><font size="2"> Mount namespace </font></h3><p>Mount namespace实现的是隔离挂载点，顾名思义，也就是说启动Mount namespace后不同进程挂载的文件系统是相互看不到的。所以测试代码中添加了CLONE_NEWNS，并且在子进程中加入了”mount -t proc proc /proc”来挂载/proc文件系统。<br>完整代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _GNU_SOURCE</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sched.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"> </span><br><span class="line">/* 定义一个给 clone 用的栈，栈大小<span class="number">1</span>M */</span><br><span class="line"><span class="comment">#define STACK_SIZE (1024 * 1024)</span></span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"> </span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Container [%5d] - inside the container!\n"</span>,getpid());</span><br><span class="line">    /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span><br><span class="line">    sethostname(<span class="string">"container"</span>,<span class="number">10</span>);	 </span><br><span class="line">    system(<span class="string">"mount -t proc proc /proc"</span>);</span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args); </span><br><span class="line">    printf(<span class="string">"Something's wrong!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Parent [%5d] - start a container!\n"</span>,getpid());</span><br><span class="line">    /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span><br><span class="line">    int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD, NULL);</span><br><span class="line">    /* 等待子进程结束 */</span><br><span class="line">    waitpid(container_pid, NULL, <span class="number">0</span>);</span><br><span class="line">    printf(<span class="string">"Parent - container stopped!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试结果如下:<br><img src="/about/docker/namespace/5.png" alt="logo"><br>从上图可以看出子进程的所有进程，PID为1的正好是新建的bash，另一个进程就是PS命令，这样mount的文件系统就看不到父进程空间中的进程，再比如输入top命令，也会发现进程很干净，结果如下:<br><img src="/about/docker/namespace/6.png" alt="logo"></p>
<h3 id="USER_namespace"><a href="#USER_namespace" class="headerlink" title="USER namespace"></a><font size="2"> USER namespace </font></h3><p>User namespace主要是提供了用户与用户组的隔离。使用CLONE_NEWUSER这个参数，容器内部看到的UID和GID已经与外部不同了，默认显示为65534。因为容器中找不到其真正的UID，所以设置了最大的UID，可通过如下命令查看:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/overflowuid</span><br></pre></td></tr></table></figure></p>
<p>要把容器中的uid和真实系统的uid给映射在一起，需要修改/proc/pid/uid_map和/proc/pid/gid_map这两个文件。这两个文件的格式是:<br>ID-inside-ns    ID-outside-ns    length</p>
<blockquote>
<p>ID-inside-ns表示容器里面显示的UID或GID。<br>ID-outside-ns表示容器外映射的真实UID或GID。<br>length表示映射范围，为1表示一一对应。</p>
</blockquote>
<p>除了上述的格式要求，对于uid/gid的映射还有几点约束:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*)写入uid_map/gid_map的进程，必须对PID进程所属user namespace拥有[CAP_SETUID/CAP_SETGID](http://man7.org/linux/man-pages/man7/capabilities<span class="number">.7</span>.html)权限</span><br><span class="line">*)写入uid_map/gid_map的进程，必须位于PID进程的parent或者child USER namespace</span><br><span class="line">*)另外需要满足如下条件之一:</span><br><span class="line">	<span class="number">1</span>)父进程将有效uid/gid映射到子进程的user namespace中</span><br><span class="line">	<span class="number">2</span>)父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid</span><br></pre></td></tr></table></figure></p>
<p>你可以通过如下命令查看(pid表示进程编号):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/&lt;pid&gt;/uid_map</span><br></pre></td></tr></table></figure></p>
<p>比如下面的例子表示把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形<br><img src="/about/docker/namespace/7.png" alt="logo"><br>现在我们来测试如下代码，如有不懂可以和我联系:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/mount.h&gt;</span><br><span class="line">#include &lt;sys/capability.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">#define STACK_SIZE (1024 * 1024)</span><br><span class="line"> </span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    "/bin/bash",</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int pipefd[2];</span><br><span class="line"> </span><br><span class="line">void set_map(char* file, int inside_id, int outside_id, int len) &#123;</span><br><span class="line">    FILE* mapfd = fopen(file, "w");</span><br><span class="line">    if (NULL == mapfd) &#123;</span><br><span class="line">        perror("open file error");</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    fprintf(mapfd, "%d %d %d", inside_id, outside_id, len);</span><br><span class="line">    fclose(mapfd);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void set_uid_map(pid_t pid, int inside_id, int outside_id, int len) &#123;</span><br><span class="line">    char file[256];</span><br><span class="line">    sprintf(file, "/proc/%d/uid_map", pid);</span><br><span class="line">    set_map(file, inside_id, outside_id, len);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void set_gid_map(pid_t pid, int inside_id, int outside_id, int len) &#123;</span><br><span class="line">    char file[256];</span><br><span class="line">    sprintf(file, "/proc/%d/gid_map", pid);</span><br><span class="line">    set_map(file, inside_id, outside_id, len);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    printf("Container [%5d] - inside the container!\n", getpid());</span><br><span class="line"> </span><br><span class="line">    printf("Container: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n",</span><br><span class="line">            (long) geteuid(), (long) getegid(), (long) getuid(), (long) getgid());</span><br><span class="line"> </span><br><span class="line">    /* 等待父进程通知后再往下执行（进程间的同步） */</span><br><span class="line">    char ch;</span><br><span class="line">    close(pipefd[1]);</span><br><span class="line">    read(pipefd[0], &amp;ch, 1);</span><br><span class="line"> </span><br><span class="line">    printf("Container [%5d] - setup hostname!\n", getpid());</span><br><span class="line">    //set hostname</span><br><span class="line">    sethostname("container",10);</span><br><span class="line"> </span><br><span class="line">    //remount "/proc" to make sure the "top" and "ps" show container's information</span><br><span class="line">    mount("proc", "/proc", "proc", 0, NULL);</span><br><span class="line"> </span><br><span class="line">    execv(container_args[0], container_args);</span><br><span class="line">    printf("Something's wrong!\n");</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int gid=getgid(), uid=getuid();</span><br><span class="line"> </span><br><span class="line">    printf("Parent: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n",</span><br><span class="line">            (long) geteuid(), (long) getegid(), (long) getuid(), (long) getgid());</span><br><span class="line"> </span><br><span class="line">    pipe(pipefd);</span><br><span class="line">  </span><br><span class="line">    printf("Parent [%5d] - start a container!\n", getpid());</span><br><span class="line"> </span><br><span class="line">    int container_pid = clone(container_main, container_stack+STACK_SIZE, </span><br><span class="line">            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | SIGCHLD, NULL);</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    printf("Parent [%5d] - Container [%5d]!\n", getpid(), container_pid);</span><br><span class="line"> </span><br><span class="line">    //To map the uid/gid, </span><br><span class="line">    //   we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent</span><br><span class="line">    //The file format is</span><br><span class="line">    //   ID-inside-ns   ID-outside-ns   length</span><br><span class="line">    //if no mapping, </span><br><span class="line">    //   the uid will be taken from /proc/sys/kernel/overflowuid</span><br><span class="line">    //   the gid will be taken from /proc/sys/kernel/overflowgid</span><br><span class="line">    set_uid_map(container_pid, 0, uid, 1);</span><br><span class="line">    set_gid_map(container_pid, 0, gid, 1);</span><br><span class="line"> </span><br><span class="line">    printf("Parent [%5d] - user/group mapping done!\n", getpid());</span><br><span class="line"> </span><br><span class="line">    /* 通知子进程 */</span><br><span class="line">    close(pipefd[1]);</span><br><span class="line"> </span><br><span class="line">    waitpid(container_pid, NULL, 0);</span><br><span class="line">    printf("Parent - container stopped!\n");</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序运行结果如下:<br><img src="/about/docker/namespace/8.png" alt="logo"><br>我们使用一个pipe来对父子进程进行同步，因为子进程中使用execv的系统调用，这个系统调用会把当前子进程的进程空间给全部覆盖掉，我们希望在execv之前就做好user namespace的uid/gid的映射，基于上述uid/gid的映射规则，我们需要父进程映射uid/gid，然后通知子进程可以执行execv。从而我们可以看到uid=0，就是说在容器中已经是root用户了，但是gid还不是0，是因为进程同步还没有完成，当你进入container的root用户时输入id就会发现如下的结果:<br><img src="/about/docker/namespace/9.png" alt="logo"><br>如果你的gid还不是0的话，有可能是内核版本问题，因为user namespace是在3.8以后才实现绝大部分的功能也就是说还会存在问题，比如安全性问题等。你可以想到的是我们运行程序的权限是普通用户，但是运行出来的容器是root，这样的安全性就可以得到提高，因为本质上还是普通用户，如果你想运行多个namespace可以在容器里使用root权限再创建多个namespace。</p>
<h3 id="Network_namespace"><a href="#Network_namespace" class="headerlink" title="Network namespace"></a><font size="2"> Network namespace </font></h3><p>首先我想用一张图介绍Docker网络部分是如何连接的:<br><img src="/about/docker/namespace/10.png" width="500" height="200" alt="logo" align="center"><br>如上图所示docker0是一个虚拟网桥，可以看成是一个软件交换机。当你安装完docker后可以使用ifconfig查看docker0分配的IP，所有的容器都可以通过docker0进行通信，当然docker0上接着的容器IP和docker0的IP处于同一网段。当创建一个Docker容器的时候，同时会创建了一对veth pair接口(当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包)。这对接口一端在容器内，即eth0;另一端在本地并被挂载到docker0网桥，名称以veth开头(例如vethAQI2QT)。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker就创建了在主机和所有容器之间一个虚拟共享网络。<br>那么上述的Network命名空间如何实现的呢?<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先我们先增加一个虚拟网桥lxcbr0, 类似于docker0</span></span><br><span class="line">brctl addbr lxcbr0</span><br><span class="line">brctl stp lxcbr0 off</span><br><span class="line">ifconfig lxcbr0 <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span>/<span class="number">24</span> up <span class="comment">#为网桥设置IP地址</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 增加一个namesapce命令为ns1(使用ip netns add命令）</span></span><br><span class="line">ip netns add ns1 </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 激活namespace中的loopback，即127.0.0.1(使用ip netns exec ns1来操作ns1中的命令)</span></span><br><span class="line">ip netns <span class="keyword">exec</span> ns1 ip link set dev lo up </span><br><span class="line"> </span><br><span class="line"><span class="comment">## 然后，我们需要增加一对虚拟网卡</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中</span></span><br><span class="line">ip link add veth-ns1 type veth peer name lxcbr0<span class="number">.1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 把veth-ns1按到namespace ns1中，这样容器中就会有一个新的网卡了</span></span><br><span class="line">ip link set veth-ns1 netns ns1</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 把容器里的veth-ns1改名为eth0（容器外会冲突，容器内就不会了）</span></span><br><span class="line">ip netns <span class="keyword">exec</span> ns1 ip link set dev veth-ns1 name eth0 </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 为容器中的网卡分配一个IP地址，并激活它</span></span><br><span class="line">ip netns <span class="keyword">exec</span> ns1 ifconfig eth0 <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span>/<span class="number">24</span> up</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上</span></span><br><span class="line">brctl addif lxcbr0 lxcbr0<span class="number">.1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 为容器增加一个路由规则，让容器可以访问外面的网络</span></span><br><span class="line">ip netns <span class="keyword">exec</span> ns1     ip route add default via <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在/etc/netns下创建network namespce名称为ns1的目录，</span></span><br><span class="line"><span class="comment"># 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了</span></span><br><span class="line">mkdir -p /etc/netns/ns1</span><br><span class="line">echo <span class="string">"nameserver 8.8.8.8"</span> &gt; /etc/netns/ns1/resolv.conf</span><br></pre></td></tr></table></figure></p>
<p>上面基本上就是docker网络的原理了，只不过，<br>Docker的resolv.conf没有用这样的方式，而是用了之前介绍的Mount Namesapce的那种方式<br>另外，docker是用进程的PID来做Network Namespace的名称的。<br>理解了上述过程后你可以给运行的docker容器增加一个新的网卡:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ip link add peerA type veth peer name peerB </span><br><span class="line">brctl addif docker0 peerA </span><br><span class="line">ip link set peerA up </span><br><span class="line">ip link set peerB netns $&#123;container-pid&#125; </span><br><span class="line">ip netns <span class="keyword">exec</span> $&#123;container-pid&#125; ip link set dev peerB name eth1 </span><br><span class="line">ip netns <span class="keyword">exec</span> $&#123;container-pid&#125; ip link set eth1 up</span><br><span class="line">ip netns <span class="keyword">exec</span> $&#123;container-pid&#125; ip addr add $&#123;ROUTEABLE_IP&#125; dev eth1</span><br></pre></td></tr></table></figure></p>
<p>你也可以实现点对点的连接:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开两个sessions, 分别运行如下命令会得到两个容器ID, 比如我得到的是481和3b8</span></span><br><span class="line">docker run -i -t --rm --net=none ubuntu:<span class="number">14.04</span> /bin/bash</span><br><span class="line">docker run -i -t --rm --net=none ubuntu:<span class="number">14.04</span> /bin/bash</span><br><span class="line"><span class="comment"># 找到这两个运行容器的进程编号9166和9206</span></span><br><span class="line">docker inspect -f <span class="string">'&#123;&#123;.State.Pid&#125;&#125;'</span> <span class="number">481</span></span><br><span class="line">docker inspect -f <span class="string">'&#123;&#123;.State.Pid&#125;&#125;'</span> <span class="number">3</span>b8</span><br><span class="line"><span class="comment"># 创建网络名字空间的跟踪文件</span></span><br><span class="line">mkdir -p /var/run/netns</span><br><span class="line">ln -s /proc/<span class="number">9166</span>/ns/net /var/run/netns/<span class="number">9166</span></span><br><span class="line">ln -s /proc/<span class="number">9206</span>/ns/net /var/run/netns/<span class="number">9206</span></span><br><span class="line"><span class="comment"># 创建一对peer接口，然后配置路由</span></span><br><span class="line">ip link add A type veth peer name B</span><br><span class="line"></span><br><span class="line">ip link set A netns <span class="number">9166</span></span><br><span class="line">ip netns <span class="keyword">exec</span> <span class="number">9166</span> ip addr add <span class="number">10.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span> dev A</span><br><span class="line">ip netns <span class="keyword">exec</span> <span class="number">9166</span> ip link set A up</span><br><span class="line">ip netns <span class="keyword">exec</span> <span class="number">9166</span> ip route add <span class="number">10.1</span><span class="number">.1</span><span class="number">.2</span>/<span class="number">32</span> dev A</span><br><span class="line"></span><br><span class="line">ip link set B netns <span class="number">9206</span></span><br><span class="line">ip netns <span class="keyword">exec</span> <span class="number">9206</span> ip addr add <span class="number">10.1</span><span class="number">.1</span><span class="number">.2</span>/<span class="number">32</span> dev B</span><br><span class="line">ip netns <span class="keyword">exec</span> <span class="number">9206</span> ip link set B up</span><br><span class="line">ip netns <span class="keyword">exec</span> <span class="number">9206</span> ip route add <span class="number">10.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span> dev B</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在这2个容器就可以相互ping通(在A中ping 10.1.1.2, B中ping 10.1.1.1)，并成功建立连接。点到点链路不需要子网和子网掩码。</span></span><br></pre></td></tr></table></figure></p>
<p>至此我们介绍了docker的网络命名空间，docker容器与docker0网桥连接原理，docker容器之间点对点连接的实现。</p>
<h2 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a><strong>cgroup</strong></h2><p>Linux cgroup全称是linux control group，是Linux内核的一个功能，主要用来限制，控制与分离一个进程组群的资源(包括CPU计算资源,内存,磁盘IO)。<br>cgroup主要提供了如下功能：</p>
<blockquote>
<p>Resource limitation: 限制资源使用，比如内存使用上限以及文件系统的缓存限制。<br>Prioritization: 优先级控制，比如：CPU利用和磁盘IO吞吐。<br>Accounting: 一些审计或一些统计，主要目的是为了计费。<br>Control: 挂起进程，恢复执行进程。</p>
</blockquote>
<p>本质上来说，cgroup是内核附加在程序上的一系列钩子(hooks)，通过程序运行时对资源的调度触发相应的钩子以达到资源追踪和限制的目的。<br>接下来我们通过三个小实验来感受一下如何限制CPU资源，memory资源，磁盘IO资源。其实Linux已经把cgroup做成一个file system，可以直接mount。</p>
<h3 id="u9650_u5236CPU"><a href="#u9650_u5236CPU" class="headerlink" title="限制CPU"></a><font size="2"> 限制CPU </font></h3><p>首先我们挂载cgroup子系统。然后查看/sys/fs/cgroup/<br><img src="/about/docker/cgroup/1.png" alt="logo"><br>你也可以用lssubsys命令查看cgroup能够限制哪些资源，初次使用会让你下载cgroup-bin，cgroup-bin会装上cgroup的所有子系统，如下图，我这里的测试主要是cpu，memory，blkio。<br><img src="/about/docker/cgroup/2.png" alt="logo"><br>正式进入限制CPU的测试:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /sys/fs/cgroup/cpu</span><br><span class="line">mkdir test</span><br><span class="line"><span class="comment"># 然后你会发现test目录下会生长出许多文件，表示的是限制CPU使用,限制进程数等</span></span><br></pre></td></tr></table></figure></p>
<p>现在我们运行一个main.c程序如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们会发现该程序极其损耗CPU资源，几乎达到100%:<br><img src="/about/docker/cgroup/3.png" alt="logo"><br>我们将之前建立的test组做一些限制，然后发现该进程的PID是4008，将该PID加入到test组中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">20000</span> &gt; /sys/fs/cgroup/cpu/test/cpu.cfs_quota_us</span><br><span class="line">echo <span class="number">4008</span> &gt; /sys/fs/cgroup/cpu/test/tasks</span><br></pre></td></tr></table></figure></p>
<p>我们会发现CPU的利用率瞬间降到20%(与我们之前设置test组的20000有关):<br><img src="/about/docker/cgroup/4.png" alt="logo"><br>于是就这样我们对CPU资源进行了限制的测试，当然也可以写多线程来对每个线程使用的CPU资源进行限制，类似上述的方法可以自己试试。</p>
<h3 id="u9650_u5236memory"><a href="#u9650_u5236memory" class="headerlink" title="限制memory"></a><font size="2"> 限制memory </font></h3><p>同理我们在memory目录中建一个test组:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /sys/fs/cgroup/memory/</span><br><span class="line">mkdir test</span><br></pre></td></tr></table></figure></p>
<p>现在我们运行一个程序不停的分配内存:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int size = <span class="number">0</span>;</span><br><span class="line">    int chunk_size = <span class="number">512</span>;</span><br><span class="line">    char *p = NULL;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ((p = (char *)malloc(sizeof(char)*chunk_size)) == NULL) &#123;</span><br><span class="line">            printf(<span class="string">"out of memory!!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(p, <span class="number">1</span>, chunk_size);</span><br><span class="line">        size += chunk_size;</span><br><span class="line">        printf(<span class="string">"[%d] - memory is allocated [%8d] bytes \n"</span>, getpid(), size);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行上述程序:<br><img src="/about/docker/cgroup/6.png" alt="logo"><br>我们将之前建立的test组做一些限制，然后发现该进程的PID是3133，将该PID加入到test组中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">10</span>k &gt; /sys/fs/cgroup/memory/test/memory.limit_in_bytes</span><br><span class="line">echo <span class="number">3133</span> &gt; /sys/fs/cgroup/memory/test/tasks</span><br></pre></td></tr></table></figure></p>
<p>于是就出现了上图中的分配到超过10kBytes时kill的情况，从而达到了限制内存的目的。</p>
<h3 id="u9650_u5236_u78C1_u76D8IO"><a href="#u9650_u5236_u78C1_u76D8IO" class="headerlink" title="限制磁盘IO"></a><font size="2"> 限制磁盘IO </font></h3><p>我们来测试如何限制硬盘的IO，模拟命令如下:(从/dev/sda1上读入数据,输出到/dev/null,/dev/null是一个“黑洞”,只能写入不能读，而且写入的文件不保存)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/sda1 of=/dev/null</span><br></pre></td></tr></table></figure></p>
<p>我们使用iotop命令测试速度如下，发现IO的速度是316.3MB/s:<br><img src="/about/docker/cgroup/7.png" alt="logo"><br>当我们使用IO限制，将该IO的PID 3382加入到test组里面时，如下代码(8:0是设备号可以通过ls -l /dev/sda1获得，1048576刚好是1M):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">'8:0 1048576'</span> &gt; /sys/fs/cgroup/blkio/test/blkio.throttle.read_bps_device</span><br><span class="line">echo <span class="number">3382</span>  &gt; /sys/fs/cgroup/blkio/test/tasks</span><br></pre></td></tr></table></figure></p>
<p>于是结果如下<br><img src="/about/docker/cgroup/8.png" alt="logo"><br>从上图可以发现我们确实将磁盘的IO操作限制在了1M，达到了限制磁盘IO的目的。</p>
<h2 id="aufs"><a href="#aufs" class="headerlink" title="aufs"></a><strong>aufs</strong></h2><p>aufs是一种union file system，所谓UnionFS就是将不同物理位置的目录合并mount到同一个目录。UnionFS的一个最主要的应用是，把一张CD/DVD和一个硬盘目录给联合mount在一起，然后，你就可以对这个只读的CD/DVD上的文件进行修改(当然，修改的文件存于硬盘上的目录里)。之前在上篇博客<a href="http://mainboy.github.io/2016/01/11/docker-入门/#more" target="_blank" rel="external">docker入门</a>中介绍过，docker的镜像都是只读的模版，当镜像运行在容器中的时候会在镜像的最上层添加一层可写层。如下图所示:<br><img src="/about/docker/aufs/1.png" width="400" height="100" alt="logo" align="center"><br>docker的分层镜像正是基于aufs实现。但是aufs并没有进入Linux内核主线(内核主线是打算发展overlayFS来取代aufs，最新的Linux内核应该已经包含overlay。)，主要是Linus不让，可能是觉得aufs写得烂，也有可能是不喜欢aufs，但是很多Linux发行版都支持aufs，比如Debian，Ubuntu。Centos不支持aufs，所以其采用的是DeviceMapper(然而并没有aufs好用)。可以查看发行版是否支持aufs<br><img src="/about/docker/aufs/2.png" alt="logo"><br>也可以看看docker是aufs驱动还是DeviceMapper驱动<br><img src="/about/docker/aufs/3.png" alt="logo"><br>docker的分层镜像，除了aufs，devicemapper，docker还支持btrfs和vfs，你可以使用-s或–storage-driver= 选项来指定相关的镜像存储</p>
<p>接下来通过几个例子来介绍aufs<br>1) 测试1<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建fruits vegetables mnt三个目录</span></span><br><span class="line">mkdir fruits vegetables mnt</span><br><span class="line"><span class="comment"># 在fruits里创建apple，tomato两个文件，vegetables里创建carrots，tomato两个文件</span></span><br><span class="line">cd ./fruits</span><br><span class="line">touch apple tomato</span><br><span class="line">cd ../vegetables</span><br><span class="line">touch carrots tomato</span><br><span class="line"><span class="comment"># 将fruits和vegetables目录union mount到./mnt目录中</span></span><br><span class="line">mount -t aufs -o dirs=./fruits:./vegetables none ./mnt</span><br><span class="line"><span class="comment"># mnt目录下会出现三个文件apple，carrots，tomato，你可能会疑问tomato是属于fruits还是vegetables，我可以先告诉你是属于fruits，后面解释为什么。</span></span><br><span class="line"><span class="comment"># 接下来做两个小测试</span></span><br><span class="line"><span class="comment"># First</span></span><br><span class="line">echo mnt &gt; ./mnt/apple</span><br><span class="line">cat ./mnt/apple</span><br><span class="line">cat ./fruits/apple</span><br><span class="line"><span class="comment"># 你会发现上述两个cat输出一样</span></span><br><span class="line"><span class="comment"># Second</span></span><br><span class="line">echo mnt_carrots &gt; ./mnt/carrots</span><br><span class="line">cat ./vegetables/carrots</span><br><span class="line">cat ./fruits/carrots</span><br><span class="line"><span class="comment"># 第一个cat没有任何输出，第二个cat输出了mnt_carrots，我们修改了./mnt/carrots的文件内容，./vegetables/carrots并没有变化，反而是./fruits目录中出现了carrots文件，其内容是我们在./mnt/carrots里的内容</span></span><br><span class="line"><span class="comment"># 原因在于我们在mount aufs命令中，并没有指定vegetables和fruits的目录权限，默认上来说，命令行上第一个(最左边)的目录是可读可写的，后面的全都是只读的，这是不是很类似docker的分层镜像？</span></span><br></pre></td></tr></table></figure></p>
<p>2) 测试2<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现在我们来设置指定权限来mount aufs，先把./fruits/carrots删掉以免干扰。</span></span><br><span class="line">mount -t aufs -o dirs=./fruits=rw:./vegetables=rw none ./mnt</span><br><span class="line"><span class="comment"># 接下来我们再做两个小实验</span></span><br><span class="line"><span class="comment"># First</span></span><br><span class="line">echo <span class="string">"mnt_carrots"</span> &gt; ./mnt/carrots</span><br><span class="line">cat ./vegetables/carrots</span><br><span class="line">cat ./fruits/carrots</span><br><span class="line"><span class="comment"># 我们设置vegetables和fruits两个目录都是可读写的，所以第一个cat有输出，第二个cat无输出符合我们的预期。</span></span><br><span class="line"><span class="comment"># Second 我们来解释tomato</span></span><br><span class="line">echo <span class="string">"mnt_tomato"</span> &gt; ./mnt/tomato</span><br><span class="line">cat ./fruits/tomato</span><br><span class="line">cat ./vegetables/tomato</span><br><span class="line"><span class="comment"># 我们发现第一个cat有输出，第二个cat没有输出，即是当有重复文件名的时候，在mount命令行上，越往前的优先级越高。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a><strong>reference</strong></h2><p>进程间通信<br><a href="http://songlee24.github.io/2015/04/21/linux-IPC/" target="_blank" rel="external">Inter-Process Communication</a></p>
<p>namespace<br><a href="http://lwn.net/Articles/531114/" target="_blank" rel="external">Namespaces in operation</a><br><a href="http://man7.org/linux/man-pages/man7/namespaces.7.html" target="_blank" rel="external">Linux Namespace Man Page</a><br><a href="http://crosbymichael.com/creating-containers-part-1.html" target="_blank" rel="external">Creating containers - Part 1</a><br><a href="http://blog.yadutaf.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/" target="_blank" rel="external">Introduction to Linux namespaces</a></p>
<p>cgroup<br><a href="https://lwn.net/Articles/484251/" target="_blank" rel="external">Fixing control groups</a><br><a href="http://lwn.net/Articles/601840/" target="_blank" rel="external">The unified control group hierarchy in 3.16</a><br><a href="http://events.linuxfoundation.org/sites/events/files/slides/2014-KLF.pdf" target="_blank" rel="external">Cgroup v2(PDF)</a></p>
<p>aufs<br><a href="http://www.linuxjournal.com/article/7714" target="_blank" rel="external">Introduce UnionFS</a><br><a href="http://lwn.net/Articles/325369/" target="_blank" rel="external">Union file systems: Implementations, part I</a><br><a href="http://lwn.net/Articles/327738/" target="_blank" rel="external">Union file systems: Implementations, part 2</a><br><a href="http://lwn.net/Articles/403012/" target="_blank" rel="external">Another union filesystem approach</a><br><a href="http://lwn.net/Articles/324291/" target="_blank" rel="external">Unioning file systems: Architecture, features, and design choices</a></p>
<p><a href="http://coolshell.cn/articles/17010.html" target="_blank" rel="external">酷壳</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近一直都在学习使用docker，当你使用docker越久你就越发的想了解docker背后是如何实现的。其实docker的一些功能之前就已经在Linux内核中实现了，只是有些没有进入内核主线中，但是技术就是这样不会凭空产生，总是靠大量的积累，由量变到质变最后在某个时刻绽放。]]>
    </summary>
    
      <category term="cloud computing" scheme="http://yoursite.com/tags/cloud-computing/"/>
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker 入门]]></title>
    <link href="http://yoursite.com/year/01/11/docker-%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/year/01/11/docker-入门/</id>
    <published>2016-01-11T05:26:05.000Z</published>
    <updated>2016-02-02T05:21:15.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/about/docker/1.png" width="500" height="200" alt="logo" align="center">        </p>
<h3 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h3><p>docker是基于LXC的容器技术，它利用Linux内核中namespace隔离进程环境，cgroup限制进程使用物理设备资源，同时创新性的将只读镜像分层，当需要在容器中运行镜像时，只需要在镜像的最外面添加一层可写层。你可以简单的将docker容器理解为进程以及运行进程所需要的轻量级环境。</p>
<p><img src="/about/docker/2.png" width="500" height="200" alt="logo" align="center"><br>如上图所示，左边是VM，右边是docker的工作层次，可以看出容器是在操作系统层面上实现的虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现的管理器。docker的优势在于比VM更轻，无需整个系统的资源环境，直接在容器中运行应用，而且支持Build once, run anywhere。缺点就是所有的容器都是运行在Linux内核上的进程，安全性值得考量，尤其是docker用在大量租户的云计算环境中。</p>
<h3 id="u955C_u50CF"><a href="#u955C_u50CF" class="headerlink" title="镜像"></a>镜像</h3><p>docker的镜像是一个只读的模版。对于镜像，你既可以从docker hub中pull下来，也可以自己利用本地文件系统创建上传到docker hub上，当然首先你需要到docker hub上注册一个账号。</p>
<h4 id="u663E_u793A_u672C_u5730_u955C_u50CF"><a href="#u663E_u793A_u672C_u5730_u955C_u50CF" class="headerlink" title="显示本地镜像"></a><font size="2"> 显示本地镜像 </font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<h4 id="pull_u955C_u50CF"><a href="#pull_u955C_u50CF" class="headerlink" title="pull镜像"></a><font size="2"> pull镜像 </font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:<span class="number">14.04</span></span><br></pre></td></tr></table></figure>
<h4 id="push_u955C_u50CF"><a href="#push_u955C_u50CF" class="headerlink" title="push镜像"></a><font size="2"> push镜像 </font></h4><p>首先需要将镜像打个标签，然后上传(af8表示镜像的ID,mainboy代表docker上注册的用户名)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag af8 mainboy/ubuntu:<span class="number">14.04</span></span><br><span class="line">docker push mainboy/ubuntu</span><br></pre></td></tr></table></figure></p>
<h4 id="u5229_u7528Dockerfile_u6765_u521B_u5EFA_u955C_u50CF"><a href="#u5229_u7528Dockerfile_u6765_u521B_u5EFA_u955C_u50CF" class="headerlink" title="利用Dockerfile来创建镜像"></a><font size="2"> 利用Dockerfile来创建镜像 </font></h4><p>利用Dockerfile创建镜像方便管理，便于上传给团队其他人分享。<br>1) 首先创建Dockerfile如下操作:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir test</span><br><span class="line">cd test</span><br><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure></p>
<p>2) 然后在Dockerfile中加入如下指令，注意每条指令都会新建镜像的一层，层数不要超过127层:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#This is a comment</span></span><br><span class="line">FROM ubuntu:<span class="number">14.04</span></span><br><span class="line">MAINTAINER mainboy &lt;wowyk@qq.com&gt;</span><br><span class="line">RUN apt-get -qq update</span><br><span class="line">RUN apt-get -qqy install ruby ruby-dev</span><br><span class="line">RUN gem install sinatra</span><br></pre></td></tr></table></figure></p>
<p>Dockerfile的基本语法:</p>
<blockquote>
<p>使用#注释<br>FROM指令告诉docker使用那个镜像作为基础<br>MAINTAINER是维护者的信息<br>RUN开头的指令会在创建中运行，比如上述的安装一些软件包</p>
</blockquote>
<p>3) 创建镜像:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t mainboy/test test/</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>-t 表示给镜像添加标签名<br>test/ 表示Dockerfile所在目录<br>创建成功后会在docker images中看到名为mainboy/test的镜像</p>
</blockquote>
<h3 id="u5BB9_u5668"><a href="#u5BB9_u5668" class="headerlink" title="容器"></a>容器</h3><p>容器是从镜像创建运行的实例。启动容器有两种方式，一种是基于镜像新建一个容器启动，另一种是将在终止状态的容器重新启动。<br>运行hello world:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu:<span class="number">14.04</span> /bin/echo <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure></p>
<p>启动一个bash终端:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu:<span class="number">14.04</span> /bin/bash</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>-t 表示给docker分配一个伪终端<br>-i 表示让容器的接受输入</p>
</blockquote>
<p>查看运行中的容器:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></p>
<p>终止一个运行中的容器:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop imageID(表示镜像的ID)</span><br></pre></td></tr></table></figure></p>
<p><font size="2"> <strong>清理容器，镜像的快捷方式:</strong> </font><br>1) 在~/.bash_aliases中加入下面快捷键<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kill all running docker</span></span><br><span class="line">alias dockerkill=<span class="string">'docker kill $(docker ps -a -q)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove all stop docker</span></span><br><span class="line">alias dockercleanc=<span class="string">'docker rm $(docker ps -a -q)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove no tag images</span></span><br><span class="line">alias dockercleani=<span class="string">'docker rmi $(docker images -q -f dangling=true)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove all stop docker and no tag images</span></span><br><span class="line">alias dockerclean=<span class="string">'dockercleanc||true&amp;&amp;dockercleani'</span></span><br></pre></td></tr></table></figure></p>
<p>2) 应用~/.bash_aliases<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_aliases</span><br></pre></td></tr></table></figure></p>
<p>3) 如上所示<br>dockercleanc直接清理掉所有停止的容器</p>
<p><font size="2"> <strong>容器的导入导出，镜像的存出载入:</strong> </font><br>1) 镜像的存出载入:<br>存出:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o ubuntu_14<span class="number">.04</span>.tar ubuntu:<span class="number">14.04</span></span><br></pre></td></tr></table></figure></p>
<p>载入:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load --input ubuntu_14<span class="number">.04</span>.tar</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; ubuntu_14<span class="number">.04</span>.tar</span><br></pre></td></tr></table></figure></p>
<p>2) 容器的导出导入:<br>导出:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export ContainerID &gt; ubuntu.tar</span><br></pre></td></tr></table></figure></p>
<p>导入:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ubuntu.tar | sudo docker <span class="keyword">import</span> - mainboy/ubuntu:<span class="number">14</span>:<span class="number">04</span></span><br></pre></td></tr></table></figure></p>
<p>或者通过指定URL或者某个目录来导入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">import</span> http://example.com/exampleimage.gz example/imagerepo</span><br></pre></td></tr></table></figure></p>
<p>3) 两者的区别:<br>容器快照文件将丢弃所有的历史记录和元数据信息(即仅保存容器当时的快照状态)，所以从容器快照文件导入时可以重新指定标签等元数据信息，而镜像存储文件将保存完整记录，体积也要大一些。</p>
<h3 id="u4ED3_u5E93"><a href="#u4ED3_u5E93" class="headerlink" title="仓库"></a>仓库</h3><p>仓库是存放镜像文件的场所。仓库又分为公开仓库和私有仓库，一般情况公开仓库指的是docker hub，类似于github。私有仓库指的是本地网络下搭建的私有仓库。<br>如何向docker hub上传镜像之前已经说过，如果你想让其他人和你一起修改你的镜像，可以在docker hub的Collaborators中添加那个人，这和github是类似的，下面简单介绍一下如何在本地建立自己的私有仓库来管理镜像。<br>1) 运行docker-registry镜像，这是官方提供的用于构建私有镜像的仓库<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p <span class="number">5000</span>:<span class="number">5000</span> -v /home/de66/registry:/tmp/registry registry</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，仓库会被创建在容器的<em>/tmp/registry</em>下，如果是按照上面的方式运行registry，如果你在本地上传的镜像会存储在<em>/home/de66/registry/repositories/library/</em>下<br>2) 上传镜像方式和上传到docker hub上的方式相同，原本应该是本地IP，但是docker只支持https的方式，默认是http，这个问题还没有解决，现在也没有这个需求，所以我暂时就只是用localhost上传。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag imageID localhost:<span class="number">5000</span>/test</span><br></pre></td></tr></table></figure></p>
<p>3) push镜像<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push localhost:<span class="number">5000</span>/test</span><br></pre></td></tr></table></figure></p>
<p>4) pull镜像<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull localhost:<span class="number">5000</span>/test</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/about/docker/1.png" width="500" height="200" alt="logo" align="center">        </p>
<h3 id="u7B80_u4ECB"><a href="#u7B80_u4ECB]]>
    </summary>
    
      <category term="cloud computing" scheme="http://yoursite.com/tags/cloud-computing/"/>
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gem5]]></title>
    <link href="http://yoursite.com/year/01/06/gem5/"/>
    <id>http://yoursite.com/year/01/06/gem5/</id>
    <published>2016-01-06T12:50:17.000Z</published>
    <updated>2016-01-12T14:31:56.000Z</updated>
    <content type="html"><![CDATA[<h4 id="gem5_u7B80_u4ECB"><a href="#gem5_u7B80_u4ECB" class="headerlink" title="gem5简介"></a>gem5简介</h4><p>GEM5是一款模块化的离散事件驱动全系统模拟器，它结合了M5和GEMS中最优秀的部分，是一款高度可配置、集成多种ISA和多种CPU模型的体系结构模拟器。M5是由Michigan大学开发的一款开源的多处理机模拟器，受到了业内的广泛关注，很多高水平论文都采用M5作为研究工具。另一方面，Wisconsin推出的GEMS能够对储存层次进行详细而灵活的模拟，包括对多种不同的cache一致性协议和互联模型的支持。目前的GEM5是M5和GEMS的一个紧耦合版本。<br>GEM5已经能够支持多种商用ISA，包括X86、ARM、ALPHA、MIPS、Power、SPARC等，并且能够在X86、ARM、ALPHA上加载操作系统。</p>
<h4 id="gem5_u7CFB_u7EDF_u6A21_u578B"><a href="#gem5_u7CFB_u7EDF_u6A21_u578B" class="headerlink" title="gem5系统模型"></a>gem5系统模型</h4><p>gem5支持两种不同的系统模型:SE(syscall emulation)和FS(full system)。</p>
<blockquote>
<p>SE模型<br>SE模型能够仿真大部分操作系统级服务，能够取得很好功能模拟加速比。<br>FS模型<br>FS模型模拟完整的全系统，包括OS，运行在用户态和核心态的线程调度以及各种设备。能够精确模拟系统时间等开销。</p>
</blockquote>
<h4 id="gem5_u7684_u5B89_u88C5_u4F7F_u7528"><a href="#gem5_u7684_u5B89_u88C5_u4F7F_u7528" class="headerlink" title="gem5的安装使用"></a>gem5的安装使用</h4><p>首先需要介绍一下我的运行环境,我的环境是在虚拟机上安装的ubuntu14.04, 分配了2个CPU, 当然CPU越多越好,后面会讲为什么。其次是内存尽量足够, 4G应该是够的, 不然编译的过程中可能会出错。安装时将ubuntu提升到root权限。<br><strong>1)安装相关的工具</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install mercurial scons swig gcc m4 python python-dev libprotobuf-dev libgoogle-perftools-dev g++</span><br></pre></td></tr></table></figure></p>
<p>简要介绍一下上述工具:<br>mercurial是一个类似于git的软件版本控制工具,主要是负责下载和更新gem5的。<br>scons是类似于make的自动编译链接工具。区别就是make是寻找当前目录的Makefile文件, scons是寻找当前目录的SConstruct配置文件。<br>swig是将C++程序封装以后供给python调用。<br>gcc与g++是C/C++的编译和链接工具,因为gem5对其版本有要求,所以我们这里相当于更新一下。<br>python和python-dev是支持python的工具<br>libprotobuf-dev和libgoogle-perftools-dev是google的一套序列化工具。类似于XML的功能, 将结构化的数据进行序列化存储或传输, 在另一端进行反序列化。protobuf支持C++、Java、Python 三种语言的 API, 它的主要优点就是快, 简单易学。</p>
<p><strong>2)下载gem5</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hg clone http://repo.gem5.org/gem5</span><br></pre></td></tr></table></figure></p>
<p><strong>3)构建gem5</strong>(-j<n>中,n=2*cpu的个数,为编译过程分配n个人物,多线程编译,速度会提升)我选择的是ALPHA指令集架构,当然也可以用其他的架构ARM/X86等。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scons build/ALPHA/gem5.opt -j4</span><br></pre></td></tr></table></figure></n></p>
<p>上述过程可能会失败：<br><strong>问题1)</strong>如果zlib.h文件没找到就需要安装<a href="http://www.zlib.net" target="_blank" rel="external">zlib-1.2.8</a>下载以后将zlib-1.2.8加入gem5<br>进入zlib-1.2.8目录执行下面命令：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p><strong>问题2)</strong>如果出现有关protobuf相关的问题就去下载<a href="https://developers.google.com/protocol-buffers/docs/downloads?hl=zh-cn" target="_blank" rel="external">protobuf-2.6.1</a>, 完成以后将protobuf-2.6.1加入gem5<br>同样进入protobuf-2.6.1目录执行下面命令：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p>同时需要将下面的代码加入~/.bashrc文件里面(下面第三行的/home/yankang/MyItem/gem5/protobuf-2.6.1替换成你的protobuf-2.6.1所在目录)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export LIBRARY_PATH=$LIBRARY_PATH:/usr/local/lib</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib</span><br><span class="line">export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/home/yankang/MyItem/gem5/protobuf-<span class="number">2.6</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></p>
<p>如果不加上述三行，会找不到protobuf-2.6.1的。</p>
<p><strong>4)测试hello world</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/ALPHA/gem5.opt configs/example/se.py -c tests/test-progs/hello/bin/alpha/linux/hello</span><br></pre></td></tr></table></figure></p>
<p>可以清楚的看见hello world被打印出来。<br><img src="/about/gem5/1.png" alt="logo"><br>可以看出几点:<br>Gem5是精确级模拟, 因为它内部的最小计时单位是tick, 而1秒=1万亿ticks。<br>可以通过gdb访问7000端口从而进行调试工作。</p>
<h4 id="gem5_u5168_u7CFB_u7EDF_u6A21_u62DF"><a href="#gem5_u5168_u7CFB_u7EDF_u6A21_u62DF" class="headerlink" title="gem5全系统模拟"></a>gem5全系统模拟</h4><p>*)首先下载系统<a href="http://www.m5sim.org/dist/current/m5_system_2.0b3.tar.bz2" target="_blank" rel="external">镜像</a></p>
<p>*)新建一个目录full_system_images, 将上述压缩包解压到full_system_images目录中, 并用pwd得到镜像所在目录, 我的目录在<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/yankang/MyItem/full_system_images/</span><br></pre></td></tr></table></figure></p>
<p>*)将镜像目录重定向到~/.bashrc中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"export M5_PATH=/home/yankang/MyItem/full_system_images/"</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<p>*)开启全系统仿真:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/ALPHA/gem5.opt configs/example/fs.py</span><br></pre></td></tr></table></figure></p>
<p>如图:<br><img src="/about/gem5/2.png" alt="logo"><br>从该结果可以看出:<br>通过3456端口可以访问全系统。<br>于是开启另一个终端, 在gem5目录中输入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd util/term/</span><br></pre></td></tr></table></figure></p>
<p>进入上述目录以后输入make, 即可编译出m5term。<br>接着输入:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m5term localhost <span class="number">3456</span></span><br></pre></td></tr></table></figure></p>
<p>就可以进入系统结果如图:<br><img src="/about/gem5/3.png" alt="logo"><br>输入clear即可清屏:<br>再输入ls就可以看到如下图:<br><img src="/about/gem5/4.png" alt="logo"><br>benchmarks中有一些测试程序:<br>进入以后可以看到下图:<br><img src="/about/gem5/5.png" alt="logo"><br>我们可以测试一下pthread_mutex_test:<br><img src="/about/gem5/6.png" alt="logo"><br>同时我们也可以尝试将hello world程序加入到这个系统里面<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ./tests/test-progs/hello/bin/alpha/linux/hello ./hello</span><br></pre></td></tr></table></figure></p>
<p>然后将镜像系统挂载在/mnt上:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o,loop,offset=<span class="number">32256</span> ../full_system_images/disks/linux-latest.img /mnt/</span><br></pre></td></tr></table></figure></p>
<p>将hello拷贝到/mnt<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp hello /mnt</span><br></pre></td></tr></table></figure></p>
<p>ls的结果如下图:<br><img src="/about/gem5/7.png" alt="logo"><br>可以看到hello进入了镜像系统然后解挂载:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount /mnt</span><br></pre></td></tr></table></figure></p>
<p>重新进入全系统模拟结果如图:<br><img src="/about/gem5/8.png" alt="logo"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="gem5_u7B80_u4ECB"><a href="#gem5_u7B80_u4ECB" class="headerlink" title="gem5简介"></a>gem5简介</h4><p>GEM5是一款模块化的离散事件驱动全系统模拟器，它结合了M5和GEM]]>
    </summary>
    
      <category term="Architecture" scheme="http://yoursite.com/tags/Architecture/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim]]></title>
    <link href="http://yoursite.com/year/01/06/Vim/"/>
    <id>http://yoursite.com/year/01/06/Vim/</id>
    <published>2016-01-06T08:20:55.000Z</published>
    <updated>2016-01-06T08:49:58.000Z</updated>
    <content type="html"><![CDATA[<p>在Linux下编写程序时，拥有一套类似于VS的集成开发环境可以大大提高程序的阅读和编写效率。本文介绍如何安装vim, ctags, cscope, Taglist, SuperTab, OmniCppComplete, Winmanager, NERDTree和MiniBufExplorer等组件。最后的界面类似于如下:<br><img src="/about/Vim/1.png" alt="logo"></p>
<p>在安装之前将权限提升到root, 以后尽量使用root权限<br>ubuntu下：sudo su然后输入密码</p>
<h4 id="u5B89_u88C5vim"><a href="#u5B89_u88C5vim" class="headerlink" title="安装vim"></a>安装vim</h4><pre><code>apt-get install vim
</code></pre><h4 id="u5B89_u88C5_u4F7F_u7528ctags"><a href="#u5B89_u88C5_u4F7F_u7528ctags" class="headerlink" title="安装使用ctags"></a>安装使用ctags</h4><p>ctags是利用堆栈实现的能快速定位符号的工具。<br>安装方法：<br>1)从<a href="http://ctags.sourceforge.net/" target="_blank" rel="external">http://ctags.sourceforge.net/</a>下载源代码包后，解压缩生成源代码目录<br>2)然后进入源代码根目录执行./configure<br>3)然后执行make<br>4)编译成功后执行make install<br>5)最后将ctrl-F12组合键映射到生成ctags的命令，需要在~/.vimrc(没有就新建)里面添加<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map &lt;C-F12&gt; :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .&lt;CR&gt;</span><br></pre></td></tr></table></figure></p>
<p>使用ctags的方法:<br>使用vim打开源代码目录里面的文件，然后同时按下ctrl和F12键生成tags。<br>简单的使用就是<br>Ctrl-]    跳转到光标所在符号的定义。<br>Ctrl-t    回到上次跳转前的位置</p>
<p>更多的功能通过命令man ctags或在vim的命令行模式下(命令行模式就是在正常打开vim后输入:就进入命令行模式)执行help ctags查询。</p>
<h4 id="u5B89_u88C5_u4F7F_u7528cscope"><a href="#u5B89_u88C5_u4F7F_u7528cscope" class="headerlink" title="安装使用cscope"></a>安装使用cscope</h4><p>安装cscope的方法:<br>1)从<a href="http://cscope.sourceforge.net/" target="_blank" rel="external">http://cscope.sourceforge.net/</a>下载源代码包后，解压缩生成源代码目录<br>2)然后进入源代码根目录执行./configure<br>3)然后执行make<br>4)编译成功后执行make install<br>5)将文件<a href="http://cscope.sourceforge.net/cscope_maps.vim" target="_blank" rel="external">http://cscope.sourceforge.net/cscope_maps.vim</a>下载到~/.vim/plugin目录，如果没有该目录就新建。</p>
<p>使用cscope的方法:<br>1) 生成cscope数据库文件，进入项目代码根目录运行命令<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscope -Rbq -f ./a.out</span><br></pre></td></tr></table></figure></p>
<p>2)打开源代码的根目录下的文件在vim的命令下输入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cs add ./a.out</span><br></pre></td></tr></table></figure></p>
<p>将数据库加载进来</p>
<p>Cscope常用快捷键<br>Ctrl-\ s 查找所有当前光标所在符号出现过位置。<br>Ctrl-\ c 查找所有调用当前光标所在函数的函数。</p>
<p>在命令行下输入cw还可以重选。<br>为了使cscope展现的更好看，在~/.vimrc里面添加如下行<br>set cscopequickfix=s-,c-,d-,i-,t-,e-</p>
<h4 id="u5B89_u88C5_u4F7F_u7528Taglist"><a href="#u5B89_u88C5_u4F7F_u7528Taglist" class="headerlink" title="安装使用Taglist"></a>安装使用Taglist</h4><p>1）从<a href="http://www.vim.org/scripts/script.php?script_id=273" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=273</a>下载安装包，也可以从<a href="http://vim-taglist.sourceforge.net/index.html" target="_blank" rel="external">http://vim-taglist.sourceforge.net/index.html</a>下载。<br>2）进入~/.vim目录，将Taglist安装包解压，解压后会在~/.vim目录中生成几个新子目录，如plugin和doc（安装其它插件时，可能还会新建autoload等其它目录）。<br>3）进入~/.vim/doc目录，在Vim下运行”helptags .”命令。此步骤是将doc下的帮助文档加入到Vim的帮助主题中，这样我们就可以通过在Vim中运行“help taglist.txt”查看taglist帮助。<br>4）打开配置文件~/.vimrc，加入以下两行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let Tlist_Show_One_File=<span class="number">1</span></span><br><span class="line">let Tlist_Exit_OnlyWindow=<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>在命令行下输入TlistToggle命令就可以打开Taglist窗口。</p>
<h4 id="u5B89_u88C5_u4F7F_u7528OmniCppComplete"><a href="#u5B89_u88C5_u4F7F_u7528OmniCppComplete" class="headerlink" title="安装使用OmniCppComplete"></a>安装使用OmniCppComplete</h4><p>OmniCppComplete主要提供输入时实时提供类或结构体的属性或方法的提示和补全。跟Talist一样，OmniCppComplete也是一个Vim插件，同样依赖与Ctags工具生成的tags文件。安装步骤跟Taglist类似。<br>从<a href="http://www.vim.org/scripts/script.php?script_id=1520" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=1520</a>下载安装包后。<br>1）进入~/.vim目录，将安装版解压缩<br>2）进入~/.vim/doc目录，在Vim命令行下运行”helptags .”<br>3）在~/.vimrc中加入以下几行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set nocp</span><br><span class="line">filetype plugin on</span><br></pre></td></tr></table></figure></p>
<h4 id="u5B89_u88C5_u4F7F_u7528SuperTab"><a href="#u5B89_u88C5_u4F7F_u7528SuperTab" class="headerlink" title="安装使用SuperTab"></a>安装使用SuperTab</h4><p>SuperTab使Tab快捷键具有更快捷的上下文提示功能。跟OmniCppComplete一样，SuperTab也是一个Vim插件。<br>从<a href="http://www.vim.org/scripts/script.php?script_id=1643" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=1643</a>下载安装版。这个安装包跟先前的几个Vim插件不同，它是一个vba文件，即Vimball格式的安装包，这种格式安装包提供傻瓜式的安装插件的方法。<br>1）用Vim打开.vba安装包文件。<br>2）在Vim命令行下运行命令“UseVimball ~/.vim”。此命令将安装包解压缩到~/.vim目录。VImball安装方式的便利之处在于你可以在任何目录打开.vba包安装，而不用切换到安装目的地目录。而且不用运行helptags命令安装帮助文档。<br>3）在~/.vimrc文件中加入以下这行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let g:SuperTabDefaultCompletionType=<span class="string">"context"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="u5B89_u88C5_u4F7F_u7528Winmanager_2C_NERDTree_u548CMiniBufExplorer"><a href="#u5B89_u88C5_u4F7F_u7528Winmanager_2C_NERDTree_u548CMiniBufExplorer" class="headerlink" title="安装使用Winmanager, NERDTree和MiniBufExplorer"></a>安装使用Winmanager, NERDTree和MiniBufExplorer</h4><p>前面介绍的几个工具和插件，主要提供快捷的编辑功能，如定义跳转，符号查询，符号提示与补全等。这里的三个插件，主要优化布置VIm的界面。具体来说，NERDTree提供树形浏览文件系统的界面，MiniBufExplorer提供多文件同时编辑功能，而Winmanager将这NERDTree界面和Taglist界面整合起来，使Vim更像VS！<br>分别从<a href="http://www.vim.org/scripts/script.php?script_id=1658" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=1658</a><br><a href="http://www.vim.org/scripts/script.php?script_id=159" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=159</a><br><a href="http://www.vim.org/scripts/script.php?script_id=95" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=95</a><br>下载NERDTree，MiniBufExplorer和Winmanager安装包（Winmanager还有个更新的vba版本<a href="http://www.vim.org/scripts/script.php?script_id=1440" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=1440</a>，这里选用旧版本的Winmanger）。<br>1）像其它插件一样，将NERDTree安装包解压到~/.vim目录。并进入doc目录，在Vim命令行下运行”helptags .”命令。<br>2）MiniBufExplorer只有一个.vim文件，将其拷贝到~/.vim/plugin目录。<br>3）在~/.vimrc文件中加入以下几行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let g:miniBufExplMapWindowNavVim = <span class="number">1</span> </span><br><span class="line">let g:miniBufExplMapWindowNavArrows = <span class="number">1</span> </span><br><span class="line">let g:miniBufExplMapCTabSwitchBufs = <span class="number">1</span> </span><br><span class="line">let g:miniBufExplModSelTarget = <span class="number">1</span></span><br><span class="line">let g:miniBufExplMoreThanOne=<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>4）将Winmanager安装包解压到~/.vim目录。<br>5）在~/.vimrc文件中加入以下几行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let g:NERDTree_title=<span class="string">"[NERDTree]"</span></span><br><span class="line">let g:winManagerWindowLayout=<span class="string">"NERDTree|TagList"</span></span><br><span class="line"></span><br><span class="line">function! NERDTree_Start()</span><br><span class="line">	<span class="keyword">exec</span> <span class="string">'NERDTree'</span></span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">function! NERDTree_IsValid()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">nmap wm :WMToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure></p>
<p>6）这个版本的Winmanager好像有个小bug，你在打开Winmanager界面时，会同时打开一个空的文件。这会影响后续使用，所以我们要在打开Winmanager时关掉这个空文件。在~/.vim/plugin目录下的winmanager.vim文件中找到以下函数定义并在第5行下添加第6行的内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function! &lt;SID&gt;ToggleWindowsManager()</span><br><span class="line">	<span class="keyword">if</span> IsWinManagerVisible()</span><br><span class="line">		call s:CloseWindowsManager()</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		call s:StartWindowsManager()</span><br><span class="line">	exe <span class="string">'q'</span></span><br><span class="line">	end</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure></p>
<p>这样同时按下w-m就可以打开集成环境。</p>
<h4 id="u5176_u4ED6_u6709_u7528_u7684_7E/-vimrc_u914D_u7F6E"><a href="#u5176_u4ED6_u6709_u7528_u7684_7E/-vimrc_u914D_u7F6E" class="headerlink" title="其他有用的~/.vimrc配置"></a>其他有用的~/.vimrc配置</h4><p>在~/.vimrc里面加入：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">colo evening</span><br><span class="line">set nu</span><br><span class="line">set autoindent</span><br><span class="line">set tabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line">set mouse=a</span><br><span class="line">set hlsearch</span><br><span class="line"></span><br><span class="line">" 执行特定命令并保留光标位置及搜索历史</span><br><span class="line">function! Preserve(command)</span><br><span class="line">	let _s=@/</span><br><span class="line">	let l = line(".")</span><br><span class="line">	let c = col(".")</span><br><span class="line">	execute a:command</span><br><span class="line"></span><br><span class="line">	let @/=_s</span><br><span class="line">		call cursor(l, c)</span><br><span class="line">	endfunction</span><br><span class="line">" 格式化全文</span><br><span class="line">function! FullFormat()</span><br><span class="line">	call Preserve("normal gg=G")</span><br><span class="line">endfunction</span><br><span class="line">nmap &lt;M-F9&gt; :call FullFormat()&lt;CR&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Linux下编写程序时，拥有一套类似于VS的集成开发环境可以大大提高程序的阅读和编写效率。本文介绍如何安装vim, ctags, cscope, Taglist, SuperTab, OmniCppComplete, Winmanager, NERDTree和MiniBu]]>
    </summary>
    
      <category term="Vim" scheme="http://yoursite.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图着色问题]]></title>
    <link href="http://yoursite.com/year/01/03/%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/year/01/03/图着色问题/</id>
    <published>2016-01-03T04:12:08.000Z</published>
    <updated>2016-01-06T11:57:56.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u95EE_u9898_u63CF_u8FF0_3A"><a href="#u95EE_u9898_u63CF_u8FF0_3A" class="headerlink" title="问题描述:"></a>问题描述:</h4><p>给出一张图，节点有n个，总共有k种颜色，将k种颜色分配给这n个点，使得在图中的每条边所连接的两个点的颜色不同。这是一个NP问题，如果从精确算法去求解，则会很难在多项式时间内确定求解，所以我们从组合优化的角度对其进行求解。下面描述了禁忌搜索算法和多种混合进化算法处理思路。</p>
<h4 id="u542F_u53D1_u5F0F_u641C_u7D22"><a href="#u542F_u53D1_u5F0F_u641C_u7D22" class="headerlink" title="启发式搜索"></a>启发式搜索</h4><h5 id="1-_u7981_u5FCC_u641C_u7D22"><a href="#1-_u7981_u5FCC_u641C_u7D22" class="headerlink" title="1.禁忌搜索"></a>1.禁忌搜索</h5><p>第一步:随机产生一个初始解，即将每个点随机分配一种颜色，并计算f, f代表当前解的矛盾数(矛盾是指相邻节点颜色相同)。可以利用所有的矛盾数相加除以2求得。<br>第二步:初始化M矩阵,M是一个二维矩阵(如下图)，记录每个点着不同的颜色的不同矛盾数。<br><img src="/about/Graphcoloring/1.jpeg" alt="logo"><br><img src="/about/Graphcoloring/2.png" alt="logo"><br>第三步:判断是否有解即每个点涂色后对应的M都是0。可以用f=0表示有解, 若有解则退出。<br>第四步:若不解,则需考虑能使f最快下降的Δf, Δf理应是个负数, 但是陷入局部最优的时候也是可以接受正数的, 考虑非禁忌的最好解, 保存最小的Δf, 若有多组最好解则按照1/n的概率选择新的最好解。禁忌的最好解的处理方式也是同样的。<br>第五步:若禁忌的最好解严格优于非禁忌的最好解且严格优于历史最优f_best，则接受禁忌的最好解，否则接受非禁忌的最好解。<br>第六步:更新M表，并且将新加入的解设为禁忌解，禁忌长度为当前迭代次数+当前矛盾数+1到10的随机数。再走第三步。(如何区分禁忌解与非禁忌解,如果禁忌长度大于当前迭代次数则是禁忌解, 否则解禁为非禁忌解。)</p>
<h5 id="2-_u6DF7_u5408_u8FDB_u5316_u641C_u7D22"><a href="#2-_u6DF7_u5408_u8FDB_u5316_u641C_u7D22" class="headerlink" title="2.混合进化搜索"></a>2.混合进化搜索</h5><p>混合方式: 交替选择父代中图同颜色最多的组，依次标上1~k种颜色, 然后去掉属于该组的所有元素, 最后若有未被分配的节点, 则随机涂色。如图所示<br><img src="/about/Graphcoloring/3.jpeg" alt="logo"></p>
<p>混合进化1:<br>十个子代构成种群，随机选择两个进行杂交(杂交方式如上图)，然后将结果进行禁忌搜索，用得到的新解，替换原先的十个种群中最差的解，(ps：一种是直接替换最差的解，一种是新解比原先最差的解要好的时候才替换。其实测试两种效果差不多。)</p>
<p>混合进化2:<br>只有两个初始解,将两个解作为父代s1,s2.s1杂交s2得到一种解s1’,s2杂交s1得到一种解s2’,将s1’禁忌得到的解直接替换替换s1,将s2’禁忌得到的解直接替换替换s2,重复操作。直至求解。</p>
<p>混合进化3:<br>思想和第二种大致相同,但是它会在每次把上一个十代的最好解替换当前的某个父代。这种方法是考虑到疏散性与集中性的平衡,其实生活的哲学也是一种平衡。这种处理方法是最快能够求解的，如果需要源码和测试案例可以邮箱联系我。</p>
<h4 id="u7ED3_u8BBA"><a href="#u7ED3_u8BBA" class="headerlink" title="结论"></a>结论</h4><p>对于NP问题的研究感觉需要很多灵感，需要借鉴各个领域的知识，这也从另一方面说明了计算机科学是一个舶来品的科学。关于NP?=P一直都无法解决，很多研究人员所做的事情更像是炼丹，炼出来的结果不错就可以发论文。当然解决这些问题本身也是很有趣的，也很有价值，如果将每个点都赋予权值，就会有sum-coloring问题，如果再把每个点当成集群的节点，就会有比如负载均衡，资源分配的问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u95EE_u9898_u63CF_u8FF0_3A"><a href="#u95EE_u9898_u63CF_u8FF0_3A" class="headerlink" title="问题描述:"></a>问题描述:</h4><p>给出一张图，节点有n个，总共有k]]>
    </summary>
    
      <category term="NP" scheme="http://yoursite.com/tags/NP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MicroBlaze Simple IO Test]]></title>
    <link href="http://yoursite.com/year/01/03/MicroBlaze-Simple-IO-Test/"/>
    <id>http://yoursite.com/year/01/03/MicroBlaze-Simple-IO-Test/</id>
    <published>2016-01-03T02:03:31.000Z</published>
    <updated>2016-01-06T14:30:31.000Z</updated>
    <content type="html"><![CDATA[<p>本实验使用Digilent Anvyl Spartan6 FPGA开发套件，只需要使用EDK中的Xilinx Platform Studio.(XPS) 务必注意后面的备注Could not detect MDM peripheral on hardware.这是我写博文的主要原因,竟然被这么一个愚蠢的问题给卡住了。。。</p>
<p>第一步：在XPS操作<br>(1)点击Create New Project Using Base System Builder<br><img src="/about/microblaze/1.jpeg" alt="logo"><br>(2)选择安装路径及命名<br><img src="/about/microblaze/2.png" alt="logo"><br>(3)FPGA选择XC6SLX45，封装为csg484，按下图配置，一定要记住你是高电平复位还是低电平复位(这是我写这篇文档的重要原因)<br><img src="/about/microblaze/3.jpeg" alt="logo"><br>(4)按下图配置, 需要在Add Device中找到开关, LED灯, 串口加入。点击Finish<br><img src="/about/microblaze/4.jpeg" alt="logo"><br>(5)去掉CLK_N, 将CLK_P改成CLK得到下图<br><img src="/about/microblaze/5.png" alt="logo"><br>(6)进入.mhs和.ucf文件<br>进入.mhs将DIFFERENTIAL_POLARITY = P去掉<br><img src="/about/microblaze/6.jpeg" alt="logo"><br>进入.ucf加入以下引脚绑定<br><img src="/about/microblaze/7.png" alt="logo"><br>(7)点击Generate BitStream 开始生成, 若出现bug再重新点击Generate BitStream生成</p>
<p>第二步：进入SDK平台<br>(1)在XPS环境中导出SDK：<br>先选择XPS环境中Project下的“Export Hardware Design To SDK …”<br><img src="/about/microblaze/8.jpeg" alt="logo"><br>在弹出的对话框中选择“Export &amp; Launch SDK”<br><img src="/about/microblaze/9.png" alt="logo"><br>(2)选择工作目录，最好在SDK下面新建一个SDK_workspace文件夹, 点击OK<br><img src="/about/microblaze/10.png" alt="logo"><br>(3)如下图所示界面，稍等片刻<br><img src="/about/microblaze/11.jpeg" alt="logo"><br>导入完成，出现如下界面，此时的CPU_SYS_hw_platform平台为默认的平台，我们可以理解为硬件平台。现在就完全进入了SDK环境，此后就可以从Windows界面直接进入。<br><img src="/about/microblaze/12.png" alt="logo"><br>(4)新建一个工程，选择Xilinx C Project，点击Next<br><img src="/about/microblaze/13.jpeg" alt="logo"><br>(5)选择 Hello World 模板，点Next<br><img src="/about/microblaze/14.jpeg" alt="logo"><br>(6)生成成功，点击Finish 即可<br><img src="/about/microblaze/15.jpeg" alt="logo"><br>此时的模版已经生成，在里面hello_world_0下展开会有src文件夹，其中的helloworld.c可以进行编写，但是此时的程序已经是一个完整的程序，运行即可。</p>
<p>(7)由于要点亮LED灯，为简单起见，我们类似于上面的模版生成一个Peripheral Tests模版，如下图，点Next<br><img src="/about/microblaze/16.jpeg" alt="logo"><br>弹出下图所示界面后等待，如下图，完成后点Finish<br><img src="/about/microblaze/17.jpeg" alt="logo"><br>(8)Build Project<br>右键点击peripheral_test_o在弹出的选项中选择Build Project，或者在工具栏中的Project下选择Build Project<br><img src="/about/microblaze/18.png" alt="logo"><br>(9)Program FPGA<br>单击工具栏的Program FPGA图标，如下图所示，或者在Xilinx Tools中选择Program FPGA<br><img src="/about/microblaze/19.jpeg" alt="logo"><br>在弹出的下图中选择相应目录下的.bit文件和.bmm文件（一般选择_bd的那一个），然后点击Program即可<br><img src="/about/microblaze/20.png" alt="logo"><br>当进度条跑满的时候就表示下载成功</p>
<p>重新认识下工具栏中比较常用的几个，如下图所示。<br>第一个红色框框住的图标表示Program FPGA，这在前面已经用到过；<br>绿色框所示的图标为Debug模式下进行调试用的，一般会在完善程序的时候用到；<br>紫色框所示图标即为最常用的验证程序是否运行正确时使用到的，本次实验我们就点击这个图标，然后观察FPGA开发板上面的外围设备有没有按照预期的结果运行。<br><img src="/about/microblaze/21.jpeg" alt="logo"><br>(10)运行程序<br>点击上面提到的紫色框中图标右侧的小三角，选择“Run Configurations … ”或者在直接在菜单栏Run下面的选项中选择“Run Configurations … ”弹出如下图所示对话框<br>先选中左侧的peripheral_test_0.elf，在右侧的STDIO Connection下，先选中Connect STDIO to Console复选框，再在Port下拉菜单中选择COM1(这要看你的设备也可能是COM4等等)，点击右下的Apply后，点Run即可<br><img src="/about/microblaze/22.jpeg" alt="logo"><br>此时，程序已经运行起来，因为是第一次设置，所以上述步骤不可省略。<br>运行完后观察FPGA开发板，可以看到8个LED灯依次亮起，打开串口调试工具并正确设置后也可以看到在接收区出现如下图所示输出，这充分表明Microblaze和SDK中的程序均正确运行起来。(如果我们在硬件平台设计时使用了“调试串口”，不需要专用的串口调试软件，在SDK的Console中就可以看到下面的信息)<br><img src="/about/microblaze/23.png" alt="logo"><br>备注:如果你出现下面这种错误, 处理方法, 想想之前是RESET设置的高电平还是低电平重置, 如果是高电平重置,则当你Program一定要将RESET置为低电平, 否则置为高电平, 切记！<br><img src="/about/microblaze/24.png" alt="logo"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本实验使用Digilent Anvyl Spartan6 FPGA开发套件，只需要使用EDK中的Xilinx Platform Studio.(XPS) 务必注意后面的备注Could not detect MDM peripheral on hardware.这是我写博文的]]>
    </summary>
    
      <category term="Hardware" scheme="http://yoursite.com/tags/Hardware/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[组合数学]]></title>
    <link href="http://yoursite.com/year/01/02/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    <id>http://yoursite.com/year/01/02/组合数学/</id>
    <published>2016-01-02T08:04:42.000Z</published>
    <updated>2016-01-27T01:01:54.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u524D_u8FF0"><a href="#u524D_u8FF0" class="headerlink" title="前述"></a>前述</h4><p>组合数学：<br>1) C(n,m)=C(n,n-m)经常拿来预处理提高程序的执行效率。<br>还有很多需要总结的，还没想好，先放着。</p>
<h4 id="POJ2249"><a href="#POJ2249" class="headerlink" title="POJ2249"></a>POJ2249</h4><p>题目描述：求组合数C(n,2)。<br>解题思路：如果直接相乘肯定会在中途溢出，所以用贪心的策略，每乘一个数，用尽量多的除数去把它除掉，如果再用64保存结果应该更加保险一点。<br>源代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,k;</span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;k)==<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (n==<span class="number">0</span>&amp;&amp;k==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (n-k&lt;k)</span><br><span class="line">			k=n-k;</span><br><span class="line">		int i,m=k;</span><br><span class="line">		__int64 mul=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=k;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			mul = mul*(n-m+i);</span><br><span class="line">			<span class="keyword">while</span> (mul%k==<span class="number">0</span>&amp;&amp;k&gt;<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				mul /= k;</span><br><span class="line">				k--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(<span class="string">"%I64d\n"</span>,mul);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1833"><a href="#POJ1833" class="headerlink" title="POJ1833"></a>POJ1833</h4><p>题目描述：大家知道，给出正整数n，则1到n这n个数可以构成n！种排列，把这些排列按照从小到大的顺序（字典顺序）列出，如n=3时，列出1 2 3，1 3 2，2 1 3，2 3 1，3 1 2，3 2 1六个排列。 </p>
<p>任务描述：<br>给出某个排列，求出这个排列的下k个排列，如果遇到最后一个排列，则下1排列为第1个排列，即排列1 2 3…n。<br>比如：n = 3，k=2 给出排列2 3 1，则它的下1个排列为3 1 2，下2个排列为3 2 1，因此答案为3 2 1。</p>
<p>解决思路：1. 使用next_permutation函数  2.模拟这个查找过程，先找右边第一个逆序的数，将其右边略大于它的数放在其位置，将右边剩下的数和它按从小到大排序即完成一次next_permutation。</p>
<p>源代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int m,n,k,i,a[<span class="number">1024</span>+<span class="number">5</span>];</span><br><span class="line">	scanf(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			scanf(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		<span class="keyword">while</span> (k--)</span><br><span class="line">			next_permutation(a,a+n);</span><br><span class="line">		printf(<span class="string">"%d"</span>,a[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">			printf(<span class="string">" %d"</span>,a[i]);</span><br><span class="line">		printf(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1844"><a href="#POJ1844" class="headerlink" title="POJ1844"></a>POJ1844</h4><p>题目描述：给你一个数S让你用1～N，用这些自然数通过加减得到S，要求N最小。<br>比如12=－1+2+3+4+5+6-7<br>解题思路：S＝(1+N)<em>N/2  - 偶数，这很容易想到。那么偶数等于(1+N)</em>N/2-S, 现在要证明为什么(1+N)<em>N/2-S是偶数就能得到S，首先(1+N)</em>N/2-S &lt; (1+N)<em>N的也就是偶数 &lt; (1+N)</em>N，我们知道偶数是通过翻转1～N中的若干数得到，只要他不超过(1+N)<em>N就可以翻转得到，因此此N是可以通过加减得到S的，另外N从小到大依次找，第一个能使(1+N)</em>N/2-S为偶数的既是N最小。<br>源代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,i;</span><br><span class="line">	scanf(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	int sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;sum&lt;n||(sum-n)%<span class="number">2</span>==<span class="number">1</span>;i++)</span><br><span class="line">		sum += i;</span><br><span class="line">	printf(<span class="string">"%d\n"</span>,i-<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u524D_u8FF0"><a href="#u524D_u8FF0" class="headerlink" title="前述"></a>前述</h4><p>组合数学：<br>1) C(n,m)=C(n,n-m)经常拿来预处理提高程序的执行效率。<br>还有很多]]>
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[字符串]]></title>
    <link href="http://yoursite.com/year/01/02/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/year/01/02/字符串/</id>
    <published>2016-01-02T07:57:19.000Z</published>
    <updated>2016-01-27T01:00:44.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u524D_u8FF0"><a href="#u524D_u8FF0" class="headerlink" title="前述"></a>前述</h4><p>首先介绍一些技巧总结：<br>1) scanf与gets的区别：scanf读取到空格或换行，gets读取到换行。<br>2) 需要保存最后输出字符串的时候可以自定义数组char ch[max]来保存，记得加串尾。<br>3) string.h里面一些常用的函数memcpy，strcpy，strcmp，strchr，strstr，strlen， strtok。<br>ctype.h里面一些常用函数isalnum, isalpha, isdigit, islower/isupper, tolower/toupper。</p>
<p>现在再谈谈POJ上面的一些处理字符串类型的题目</p>
<h4 id="POJ1598"><a href="#POJ1598" class="headerlink" title="POJ1598"></a>POJ1598</h4><p>题目描述：给你K个小写字母组成的单词，E个句子，先要你输出包含K个单词中的单词数目最多的句子，如有多个这样的句子，不要求顺序的输出。句子匹配不考虑大小写。<br>解题思路：网上可能有些其他的思路比如STL，排序之类的，这里我采用字符处理提取单词的方法，然后进行匹配计数，最后输出等于最大计数的句子。<br>源代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;ctype.h&gt;</span></span><br><span class="line">char pattern[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line">char inStr[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line">int cnt[<span class="number">205</span>];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int k,e,set=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%d%d"</span>,&amp;k,&amp;e)==<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(cnt,<span class="number">0</span>,sizeof(cnt));</span><br><span class="line">		int i,j,m,max=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">			scanf(<span class="string">"%s"</span>,&amp;pattern[i]);</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;e;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			gets(inStr[i]);</span><br><span class="line">			int len=strlen(inStr[i]);</span><br><span class="line">			char ch[<span class="number">105</span>];</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				int a=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">while</span> (isalpha(inStr[i][j]))</span><br><span class="line">				&#123;</span><br><span class="line">					ch[a++] = tolower(inStr[i][j]);</span><br><span class="line">					j++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (a&gt;<span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ch[a]=<span class="string">'\0'</span>;</span><br><span class="line">					<span class="keyword">for</span> (m=<span class="number">0</span>;m&lt;k;m++)</span><br><span class="line">						<span class="keyword">if</span> (strcmp(ch,pattern[m])==<span class="number">0</span>)</span><br><span class="line">						&#123;</span><br><span class="line">							cnt[i]++;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;e;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (cnt[i] &gt; max)</span><br><span class="line">			&#123;</span><br><span class="line">				max = cnt[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(<span class="string">"Excuse Set #%d\n"</span>,set++);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;e;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (max==cnt[i])</span><br><span class="line">				printf(<span class="string">"%s\n"</span>,inStr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1782"><a href="#POJ1782" class="headerlink" title="POJ1782"></a>POJ1782</h4><p>题目描述：题意不容易理解，主要是需要你重新编码。规则如下：<br>1）将连续相同的字符串依次输出个数，字符，如果个数大于9就需要重新使用编码规则<br>2）将不相同的字符串首尾各添加1，在不相同的字符串中如果出现1就将其转换成2个1<br>解题思路：每次记录上一个字符与当前字符比较，如果相等将计数＋1，如果计数达到8就可以输出并且将计数清0，为什么我这里处理是8，因为个数等于9需要比较8次。如果不相等就一直循环到相等的时候退出，在此过程中需要保存不相同的字符串，如果遇到1就保存2个1，最后还需要在前面和后面都添加1，到字符相等的时候就输出。<br>源代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define N 10000+5</span></span><br><span class="line"></span><br><span class="line">char str[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(NULL != gets(str))</span><br><span class="line">	&#123;</span><br><span class="line">		int i,len = strlen(str),cnt=<span class="number">0</span>;</span><br><span class="line">		char c = str[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (cnt==<span class="number">8</span>)&#123;</span><br><span class="line">				printf(<span class="string">"%d%c"</span>,cnt+<span class="number">1</span>,c);</span><br><span class="line">				cnt=<span class="number">0</span>;</span><br><span class="line">				c=str[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (c == str[i])</span><br><span class="line">				cnt++;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (cnt&gt;<span class="number">0</span>&amp;&amp;cnt&lt;<span class="number">9</span>)&#123;</span><br><span class="line">					printf(<span class="string">"%d%c"</span>,cnt+<span class="number">1</span>,c);</span><br><span class="line">					cnt=<span class="number">0</span>;</span><br><span class="line">					c=str[i];</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					char ch[N];</span><br><span class="line">					int j=<span class="number">0</span>;</span><br><span class="line">					ch[j++]=<span class="string">'1'</span>;</span><br><span class="line">					<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span> (str[i]==c||i&gt;=len)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">if</span> (i==len)</span><br><span class="line">							&#123;</span><br><span class="line">								<span class="keyword">if</span> (str[i-<span class="number">1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">									ch[j++]=<span class="string">'1'</span>;</span><br><span class="line">									ch[j++]=<span class="string">'1'</span>;</span><br><span class="line">								&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">									ch[j++]=str[i-<span class="number">1</span>];</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">							ch[j++]=<span class="string">'1'</span>;</span><br><span class="line">							ch[j]=<span class="string">'\0'</span>;</span><br><span class="line">							printf(<span class="string">"%s"</span>,ch);</span><br><span class="line">							<span class="keyword">if</span> (i!=len)</span><br><span class="line">								cnt++;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (str[i-<span class="number">1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">							ch[j++]=<span class="string">'1'</span>;</span><br><span class="line">							ch[j++]=<span class="string">'1'</span>;</span><br><span class="line">						&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">							ch[j++]=str[i-<span class="number">1</span>];</span><br><span class="line">						&#125;</span><br><span class="line">						c=str[i];</span><br><span class="line">						i++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;   </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1936"><a href="#POJ1936" class="headerlink" title="POJ1936"></a>POJ1936</h4><p>题目描述：给你两个字符串s和t，判断s是否是t的子串。这里的子串之意就是s字符串中每个字符的先后顺序在t中的顺序也应该一样。<br>解题思路：此题应该很容易想到字符比较，如果si==ti则都往后推1，否则t往后推。<br>源代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#define N 100000+5</span></span><br><span class="line">char s[N],t[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%s%s"</span>,&amp;s,&amp;t)==<span class="number">2</span>)&#123;</span><br><span class="line">		int lens=strlen(s),lent=strlen(t);</span><br><span class="line">		int i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">		bool flag=false;</span><br><span class="line">		<span class="keyword">while</span> (i&lt;lens&amp;&amp;j&lt;lent)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i]==t[j])&#123;</span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i==lens)</span><br><span class="line">			printf(<span class="string">"Yes\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			printf(<span class="string">"No\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1790"><a href="#POJ1790" class="headerlink" title="POJ1790"></a>POJ1790</h4><p>题目描述：给你一串数字s，分成权数和基数，要求权数小于基数。求解有多少种分法？比如1234可以分成<br>(1-2-3)4, (1-2)34, (12)34, (1)234。<br>解题思路：类似于动态规划的思想，分别处理基数长度为1～数字串长度－1，然后将所有的种数相加，那么怎么比较？使用strncmp()函数。cnt[i]表示以s+i起始的基数总共有多少种分法。cnt[i]应该加上所有以len-i为基数的cnt。<br>源代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line">char s[<span class="number">100</span>+<span class="number">5</span>];</span><br><span class="line">int cnt[<span class="number">100</span>+<span class="number">5</span>];</span><br><span class="line">int len;</span><br><span class="line"></span><br><span class="line">int num(int cur)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (s[len-cur]==<span class="string">'0'</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	int i;</span><br><span class="line">	cnt[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=len-cur;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cnt[i]=<span class="number">0</span>;</span><br><span class="line">		int minn;</span><br><span class="line">		<span class="keyword">if</span> (i-cur&lt;<span class="number">0</span>)</span><br><span class="line">			minn=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			minn=i-cur;</span><br><span class="line">		<span class="keyword">for</span> (int j=minn; j&lt;i; j++)&#123;  </span><br><span class="line">			<span class="keyword">if</span> ((j+<span class="number">1</span>&lt;i || j==<span class="number">0</span> &amp;&amp; len-cur&gt;<span class="number">1</span>) &amp;&amp; s[j]==<span class="string">'0'</span>) <span class="keyword">continue</span>;  </span><br><span class="line">			<span class="keyword">if</span> (j+cur==i) <span class="keyword">if</span> (strncmp(s+j,s+len-cur,cur)&gt;=<span class="number">0</span>) <span class="keyword">continue</span>;  </span><br><span class="line">			cnt[i]+=cnt[j];  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cnt[len-cur];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%s"</span>,&amp;s)==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (s[<span class="number">0</span>]==<span class="string">'#'</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		int ans=<span class="number">0</span>,i;</span><br><span class="line">		len = strlen(s);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">			ans+=num(i);</span><br><span class="line">		<span class="keyword">if</span> (ans&gt;<span class="number">0</span>)</span><br><span class="line">			printf(<span class="string">"The code %s can represent %d numbers.\n"</span>,s,ans);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			printf(<span class="string">"The code %s is invalid.\n"</span>,s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u524D_u8FF0"><a href="#u524D_u8FF0" class="headerlink" title="前述"></a>前述</h4><p>首先介绍一些技巧总结：<br>1) scanf与gets的区别：scanf读取到空格或换行，gets读取]]>
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序]]></title>
    <link href="http://yoursite.com/year/01/02/%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/year/01/02/排序/</id>
    <published>2016-01-02T07:38:22.000Z</published>
    <updated>2016-01-27T01:01:06.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u524D_u8FF0"><a href="#u524D_u8FF0" class="headerlink" title="前述"></a>前述</h4><p>首先介绍一下有关C++里面排序的模板, 包含的头文件是<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>常用的几种用法:</p>
<h5 id="sort_u51FD_u6570"><a href="#sort_u51FD_u6570" class="headerlink" title="sort函数"></a>sort函数</h5><p>1) 比如int x[N], 有n个元素, 直接使用sort(x,x+n);<br>2) 定义比较模式cmp, 然后使用sort(x,x+n,cmp);<br>比如(按下面的方法使用):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"></span><br><span class="line">struct pix&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">&#125;p[<span class="number">1000</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">int cmp(const pix &amp;a, const pix &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (a.x == b.x)</span><br><span class="line">		<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">	<span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(p,p+n,cmp);</span><br></pre></td></tr></table></figure></p>
<h5 id="qsort_u51FD_u6570"><a href="#qsort_u51FD_u6570" class="headerlink" title="qsort函数"></a>qsort函数</h5><p>也需要定义比较模式, 并且可以按照下面所示方法使用<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int cmp(const void* a, const void* b)</span><br><span class="line">&#123;</span><br><span class="line">	Node* m = (Node *)a;</span><br><span class="line">	Node* n = (Node *)b;</span><br><span class="line">	if (m-&gt;x==n-&gt;x)</span><br><span class="line">		return m-&gt;y - n-&gt;y;</span><br><span class="line">	return m-&gt;x-n-&gt;x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">qsort(mid,m,sizeof(mid[0]),cmp);</span><br></pre></td></tr></table></figure></p>
<p>现在言归正传, 讲几道有关排序的POJ</p>
<h4 id="POJ1723"><a href="#POJ1723" class="headerlink" title="POJ1723"></a>POJ1723</h4><p>问题描述:给你一些士兵的坐标，使用尽量少的步数将士兵移到某一横排，并且每个士兵的位置唯一。<br>思路就是先按照y的坐标进行排序，将所有的士兵先移动到y的中位数对应的横排，现在遇到的一个问题就是可能多个士兵占用同一个x，怎么处理？我们的目标是将这些占用同一个x的士兵用尽量少的步数展开。首先想到的是假设有个起点a，这些士兵刚好排列在a+i上，如果没有怎么办？显然应该是abs(a+i-xi)的最小值，这里有个问题xi应该首先排好序否则a+i-xi不对应或者偏离很远。abs(a+i-xi)的最小值也即是abs(a-(xi-i))的最小值，于是a就是xi-i的中位数。<br>比如：x1=x2=x3=2，xi-i=1, 0, -1, 那么中位数a=0, 最小值2。<br>源代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define N 10000+5</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,x[N],y[N];</span><br><span class="line">	scanf("%d",&amp;n);</span><br><span class="line">	for (int i=0;i&lt;n;i++)</span><br><span class="line">		scanf("%d%d",&amp;x[i],&amp;y[i]);</span><br><span class="line">	sort(y,y+n);</span><br><span class="line">	sort(x,x+n);</span><br><span class="line">	for (int i=0;i&lt;n;i++)</span><br><span class="line">		x[i] -= i;</span><br><span class="line">	sort(x,x+n);</span><br><span class="line">	int cntx = (n%2)?x[(n-1)/2]:(x[n/2]+x[n/2-1])/2;</span><br><span class="line">	int cnty = (n%2)?y[(n-1)/2]:(y[n/2]+y[n/2-1])/2;</span><br><span class="line">	int sum=0;</span><br><span class="line">	for (int i=0;i&lt;n;i++)</span><br><span class="line">		sum +=(abs(cntx-x[i])+abs(cnty-y[i]));</span><br><span class="line">	printf("%d\n",sum);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ2376"><a href="#POJ2376" class="headerlink" title="POJ2376"></a>POJ2376</h4><p>问题描述：给你N个时间段和一个时间T，求最少的时间段覆盖时间[1,T]，如果不能覆盖则输出结果-1。<br>解题思路：<br>1）根据所有时间段的起始点从小到大排序，如果起始点相等就根据结束点从小到大排序。<br>2）如果起始点不等于1显然覆盖不了，直接输出－1，否则循环过滤掉前面多个1。<br>3）使用贪心的策略来求解最小的段数。操作就是用end来保存每次符合要求的最大结束点top，此时计数＋1，如果某次的top&lt;=end表明已经难以继续增加，直接退出比较是否比T大，如果比T大则输出计数值，否则输出－1。<br>源代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define N 25000+5</span><br><span class="line"></span><br><span class="line">struct INTER&#123;</span><br><span class="line">	int start;</span><br><span class="line">	int end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">INTER p[N];</span><br><span class="line"></span><br><span class="line">int cmp(const void* a, const void* b)</span><br><span class="line">&#123;</span><br><span class="line">	INTER *m = (INTER *)a;</span><br><span class="line">	INTER *n = (INTER *)b;</span><br><span class="line">	if (m-&gt;start == n-&gt;start)</span><br><span class="line">		return m-&gt;end - n-&gt;end;</span><br><span class="line">	return m-&gt;start - n-&gt;start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,T;</span><br><span class="line">	while (scanf("%d%d",&amp;n,&amp;T)==2)</span><br><span class="line">	&#123;</span><br><span class="line">		int i;</span><br><span class="line">		for (i=0;i&lt;n;i++)</span><br><span class="line">			scanf("%d%d",&amp;p[i].start,&amp;p[i].end);</span><br><span class="line">		qsort(p,n,sizeof(p[0]),cmp);</span><br><span class="line"></span><br><span class="line">		if (p[0].start!=1)&#123;</span><br><span class="line">			printf("-1\n");</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		i=0;</span><br><span class="line">		while (p[i].start==1 &amp;&amp; i&lt;n)</span><br><span class="line">			i++;</span><br><span class="line">		int cnt = 1;</span><br><span class="line">		int end = p[i-1].end;</span><br><span class="line">		int top = p[i-1].end;</span><br><span class="line">		while(i&lt;n)&#123;</span><br><span class="line">			int cur = i;</span><br><span class="line">			while (p[i].start &lt;= end + 1 &amp;&amp; i &lt; n)</span><br><span class="line">			&#123;</span><br><span class="line">				top = max(top,p[i].end);</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			if (cur==i || top&lt;= end)</span><br><span class="line">				break;</span><br><span class="line">			cnt++;</span><br><span class="line">			end = top; </span><br><span class="line">		&#125;</span><br><span class="line">		if (top &gt;= T)</span><br><span class="line">			printf("%d\n",cnt);</span><br><span class="line">		else</span><br><span class="line">			printf("-1\n");</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1971"><a href="#POJ1971" class="headerlink" title="POJ1971"></a>POJ1971</h4><p>问题描述：给你n个点的坐标，要求你找出平行四边形的个数。<br>解题分析：平行四边形有一个显著的特点就是对角线相交于某一点，而该点也是每条对角线的中点，那么比方说有k个点相交于某点，那么就应该有C(k,2)个平行四边形，这里的思路就是将所有坐标与其他点的坐标取平均值等到所有的中点，然后排序所有中点，进而容易查找在某中点的个数k，然后将所有的C(k,2)求和即得到平行四边形的个数。<br>源代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">&#125;in[1005],mid[500005];</span><br><span class="line"></span><br><span class="line">int cmp(const void* a, const void* b)</span><br><span class="line">&#123;</span><br><span class="line">	Node* m = (Node *)a;</span><br><span class="line">	Node* n = (Node *)b;</span><br><span class="line">	if (m-&gt;x==n-&gt;x)</span><br><span class="line">		return m-&gt;y - n-&gt;y;</span><br><span class="line">	return m-&gt;x-n-&gt;x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t,n,m;</span><br><span class="line">	scanf("%d",&amp;t);</span><br><span class="line">	while (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf("%d",&amp;n);</span><br><span class="line">		for (int i=0;i&lt;n;i++)</span><br><span class="line">			scanf("%d%d",&amp;in[i].x,&amp;in[i].y);</span><br><span class="line">		m=0;</span><br><span class="line">		for (int i=0;i&lt;n;i++)</span><br><span class="line">			for (int j=i+1;j&lt;n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				mid[m].x = in[i].x+in[j].x;</span><br><span class="line">				mid[m++].y = in[i].y+in[j].y;</span><br><span class="line">			&#125;</span><br><span class="line">		qsort(mid,m,sizeof(mid[0]),cmp);</span><br><span class="line">		int dk=1,sum=0;</span><br><span class="line">		for (int i=0;i&lt;m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (mid[i].x==mid[i+1].x &amp;&amp; mid[i].y==mid[i+1].y &amp;&amp; i!=m-1)</span><br><span class="line">				dk++;</span><br><span class="line">			else&#123;</span><br><span class="line">				if (dk&gt;1)</span><br><span class="line">					sum += (dk*(dk-1)/2);</span><br><span class="line">				dk = 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf("%d\n",sum);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1788"><a href="#POJ1788" class="headerlink" title="POJ1788"></a>POJ1788</h4><p>题目描述：给你p个点的坐标，要求最小围住这p个点的篱笆长度。<br>解题分析：要求最小的篱笆长度，那么点应该在篱笆的拐角处，这样意味什么？比如你想计算y方向的篱笆长度，你需要先对x排序，如果x相等按y排序，这里有个点需要想到，就是对应每一个x，会有成对的y出现，这样才能求出y方向的篱笆长度，同理计算x方向的篱笆长度。两向篱笆长度想加即得到最小的篱笆长度。<br>源代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node pix[100000+5];</span><br><span class="line"></span><br><span class="line">int cmpx(const void *a, const void *b)</span><br><span class="line">&#123;</span><br><span class="line">	Node* m = (Node *)a;</span><br><span class="line">	Node* n = (Node *)b;</span><br><span class="line">	if (m-&gt;x == n-&gt;x)</span><br><span class="line">		return m-&gt;y - n-&gt;y;</span><br><span class="line">	return m-&gt;x - n-&gt;x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cmpy(const void *a, const void *b)</span><br><span class="line">&#123;</span><br><span class="line">	Node* m = (Node *)a;</span><br><span class="line">	Node* n = (Node *)b;</span><br><span class="line">	if (m-&gt;y == n-&gt;y)</span><br><span class="line">		return m-&gt;x - n-&gt;x;</span><br><span class="line">	return m-&gt;y - n-&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int p,sum;</span><br><span class="line">	while(scanf("%d",&amp;p)==1&amp;&amp;p!=0)&#123;</span><br><span class="line">		for (int i=0;i&lt;p;i++)</span><br><span class="line">			scanf("%d%d",&amp;pix[i].x,&amp;pix[i].y);</span><br><span class="line">		sum=0;</span><br><span class="line">		qsort(pix,p,sizeof(pix[0]),cmpx);</span><br><span class="line">		for (int i=0;i&lt;p;i=i+2)</span><br><span class="line">			sum += (pix[i+1].y-pix[i].y);</span><br><span class="line">		qsort(pix,p,sizeof(pix[0]),cmpy);</span><br><span class="line">		for (int i=0;i&lt;p;i=i+2)</span><br><span class="line">			sum += (pix[i+1].x-pix[i].x);</span><br><span class="line">		printf("The length of the fence will be %d units.\n",sum);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u524D_u8FF0"><a href="#u524D_u8FF0" class="headerlink" title="前述"></a>前述</h4><p>首先介绍一下有关C++里面排序的模板, 包含的头文件是<br><figure class="highli]]>
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数论]]></title>
    <link href="http://yoursite.com/year/01/02/%E6%95%B0%E8%AE%BA/"/>
    <id>http://yoursite.com/year/01/02/数论/</id>
    <published>2016-01-02T07:05:48.000Z</published>
    <updated>2016-01-27T01:01:34.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u6B27_u51E0_u91CC_u5F97_u7B97_u6CD5_u548C_u6269_u5C55_u6B27_u51E0_u91CC_u5F97_u7B97_u6CD5"><a href="#u6B27_u51E0_u91CC_u5F97_u7B97_u6CD5_u548C_u6269_u5C55_u6B27_u51E0_u91CC_u5F97_u7B97_u6CD5" class="headerlink" title="欧几里得算法和扩展欧几里得算法"></a>欧几里得算法和扩展欧几里得算法</h4><p>欧几里得算法看上去高大上，其实质是辗转相除法，用于计算两个整数的a,b的最大公约数。<br>基本算法: 假设 $$ a=q<em>b+r $$ 其中a,b,q,r都是整数, 则gcd(a,b) = gcd(b,r); 证明可以参考链接<a href="http://www.cnblogs.com/frog112111/archive/2012/08/19/2646012.html" target="_blank" rel="external">欧几里得与扩展欧几里得</a><br>扩展欧几里得描述的是: $$a</em>p+b*q=c$$(a,b,c已知, p,q未知), 若存在解则c mod gcd(a,b) = 0, 并且p,q的其中一个解可以通过扩展的欧几里得算法求得。</p>
<p>首先求$$a<em>p + b</em>q = gcd(a,b)$$的解p,q<br>不妨假设 a &gt; b, a, b不同时为0<br>1) 当b = 0, 则p=1, q = 0原等式化为 a = a<br>2) 当a,b都不为0的时候, $$a<em>p1 + b</em>q1 = gcd(a,b)$$<br>$$b<em>p2 + (a mod b)</em>q2 = gcd(b, a mod b)$$<br>推出:<br>$$a<em>p1 + b</em>q1 = b<em>p2 + (a mod b)</em>q2$$<br>=&gt; $$p1 = q2$$<br>$$q1 = p2 - (a/b)*q2$$</p>
<p>即递归的边界在b=0时返回p=1, q = 0, 否则依次按上式递归<br>代码描述:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__int64 exgcd(__int64 a, __int64 b, __int64 &amp;x, __int64 &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (b==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x = <span class="number">1</span>;</span><br><span class="line">		y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	__int64 x2,y2;</span><br><span class="line">	__int64 t = exgcd(b,a%b,x2,y2);</span><br><span class="line">	x = y2;</span><br><span class="line">	y = x2 - (a/b)*y2;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1061"><a href="#POJ1061" class="headerlink" title="POJ1061"></a>POJ1061</h4><p>题目描述:<br>两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。<br>我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。<br>Input<br>输入只包括一行5个整数x，y，m，n，L，其中x≠y &lt; 2000000000，0 &lt; m、n &lt; 2000000000，0 &lt; L &lt; 2100000000。<br>Output<br>输出碰面所需要的跳跃次数，如果永远不可能碰面则输出一行”Impossible”</p>
<p>假设进过次数t, k圈两只青蛙相遇:<br>$$x+m<em>t - (y+n</em>t) = k<em>l$$<br>=&gt; $$(n-m)</em>t + l<em>k = x - y$$<br>和扩展欧几里得公式对应起来<br>$$a = n-m, b = l, c = x - y,<br>    p = t, q = k$$<br>那么调用扩展欧几里得公式后得到的解 $$(gcd(a,b)) = d = exgcd(a,b,p,q)$$<br>p,q是$$a</em>p + b<em>q = gcd(a,b)$$的解, 那么你需要实际的此时应该是$$xx = p</em>c/gcd(a,b) = t<em>(x-y)/d$$ 但是还有一个问题就是你的取值范围问题。<br>如下证明:<br>定理一：如果d = gcd(a, b)，则必能找到正的或负的整数k和l，使d = a</em>x+ b<em>y。<br>定理二：若gcd(a, b) = 1，则方程ax ≡ c (mod b)在[0, b-1]上有唯一解。<br>定理三：若gcd(a, b) = d，则方程ax ≡ c (mod b)在[0, b/d - 1]上有唯一解。<br>证明：上述同余方程等价于ax + by = c，如果有解，两边同除以d，就有a/d </em> x + b/d <em> y = c/d，即a/d </em> x ≡ c/d (mod b/d)，显然gcd(a/d, b/d) = 1，所以由定理二知道x在[0, b/d - 1]上有唯一解。所以ax + by = c的x在[0, b/d - 1]上有唯一解，即ax ≡ c (mod b)在[0, b/d - 1]上有唯一解。<br>如果得到ax ≡ c (mod b)的某一特解X，那么令r = b/gcd(a, b)，可知x在[0, r-1]上有唯一解，所以用x = (X % r + r) % r就可以求出最小非负整数解x了！（X % r可能是负值，此时保持在[-(r-1), 0]内，正值则保持在[0, r-1]内。加上r就保持在[1, 2r - 1]内，所以再模一下r就在[0, r-1]内了）。<br>r = b/gcd(a,b), 所以实际的次数是  (xx%r + r)%r<br>说的这么多该上代码了:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">__int64 exgcd(__int64 a, __int64 b, __int64 &amp;x, __int64 &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (b==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x = <span class="number">1</span>;</span><br><span class="line">		y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	__int64 x2,y2;</span><br><span class="line">	__int64 t = exgcd(b,a%b,x2,y2);</span><br><span class="line">	x = y2;</span><br><span class="line">	y = x2 - (a/b)*y2;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	__int64 x,y,m,n,l;</span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%I64d%I64d%I64d%I64d%I64d"</span>,&amp;x,&amp;y,&amp;m,&amp;n,&amp;l)==<span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		__int64 a,b,c,p,q,d,r,t;</span><br><span class="line">		a = n-m, b = l, c = x-y;</span><br><span class="line">		d = exgcd(a,b,p,q);</span><br><span class="line">		<span class="keyword">if</span> (c%d!=<span class="number">0</span>)</span><br><span class="line">			printf(<span class="string">"Impossible\n"</span>);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			r = b/d;</span><br><span class="line">			t = p*(c/d);</span><br><span class="line">			printf(<span class="string">"%I64d\n"</span>,(t%r+r)%r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ2262"><a href="#POJ2262" class="headerlink" title="POJ2262"></a>POJ2262</h4><p>问题描述: 每一个大于4的偶数都可以被写成两个奇素数相加<br>比如<br>8 = 3 + 5<br>20 = 3 + 17<br>42 = 5 + 37<br>输入一个n&gt;=6, n &lt; 100000寻找间隔最大的两个奇素数相加表示, 如果存在按照上面的格式输出, 否则输出Goldbach’s conjecture is wrong.<br>Sample Input<br>8<br>20<br>42<br>0<br>Sample Output<br>8 = 3 + 5<br>20 = 3 + 17<br>42 = 5 + 37<br>此题很简单, 只需要从最小的素数开始遍历就行, 如果差数也是素数就找到了。<br>代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool isprime(int x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (int i=<span class="number">2</span>;i*i&lt;=x;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (x%i==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> false;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%d"</span>,&amp;n)==<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		bool flag = false;</span><br><span class="line">		<span class="keyword">for</span> (int i=<span class="number">3</span>;i&lt;=n/<span class="number">2</span>;i=i+<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (isprime(i) &amp;&amp; isprime(n-i))</span><br><span class="line">			&#123;</span><br><span class="line">				printf(<span class="string">"%d = %d + %d\n"</span>,n,i,n-i);</span><br><span class="line">				flag = true;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag)</span><br><span class="line">			printf(<span class="string">"Goldbach's conjecture is wrong.\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1730"><a href="#POJ1730" class="headerlink" title="POJ1730"></a>POJ1730</h4><p>问题描述:<br>我们知道25 = 5^2, 1073741824 = 2^30, 等等，现在给你一个32位的int型数n, 你需要找到最大的指数i使得n = a^i<br>这个题有个很巧妙的解法:<br>首先我们来思考一下<br>1.32位的int型数是包括正数和负数的, 我们知道负数是不可能等于某个数的偶数次方的。<br>2.我们知道双精度的double表示是1, 11, 52, 那么我们将一个double x强制转化成__int64 a, 显然如果abs(a-x)&lt; (1.0e-12)或者abs(a-x+1) &lt; (1.0e-12)(这个地方你可以自己检验一下), 就可以保证x == a。<br>3.可以直接对n进行开32~1次方根<br>代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;math.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define esp 1.0e-12        // 1 11 52 double型需要12位</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	long long n;</span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%I64d"</span>,&amp;n)==<span class="number">1</span> &amp;&amp; n!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		bool flag = false;</span><br><span class="line">		<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			flag = true;</span><br><span class="line">			n = -n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (int i=<span class="number">32</span>;i &gt;= <span class="number">1</span>;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!flag || (flag &amp;&amp; (i&amp;<span class="number">1</span>)))   // 负数只能开奇数次方不能开偶数次方</span><br><span class="line">			&#123;</span><br><span class="line">				double x = pow((double)n, <span class="number">1.0</span>/i); // <span class="number">1</span> <span class="number">8</span> <span class="number">23</span>    <span class="number">1</span> <span class="number">11</span> <span class="number">52</span></span><br><span class="line">				long long a = x; </span><br><span class="line">				<span class="keyword">if</span> (abs(a-x) &lt; esp || abs(a-x+<span class="number">1</span>) &lt; esp)</span><br><span class="line">				&#123;</span><br><span class="line">					printf(<span class="string">"%d\n"</span>,i);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1183"><a href="#POJ1183" class="headerlink" title="POJ1183"></a>POJ1183</h4><p>问题描述:根据此题和反正切函数没有半毛钱关系<br>反正切等式: $$ arctan(p)+arctan(q)=arctan[(p+q)/(1-pq)] $$</p>
<p>我们将上述公式写成如下形式<br>$$ arctan(1/a)=arctan(1/b)+arctan(1/c) $$<br>其中a,b和c均为正整数。<br>我们的问题是：对于每一个给定的a(1&lt;=a&lt;=60000)，求b＋c的值。我们保证对于任意的a都存在整数解。如果有多个解，要求你给出b+c最小的解。<br>证明推导:<br>$$ 1/a = (1/b+1/c)/(1-1/b<em>1/c) $$<br>=&gt; $$a</em>(b+c) = b<em>c -1$$<br>利用均值不等式我们可以推出$$b+c &gt;= 2</em>(a+sqrt(a<em>a+1))$$<br>不妨设$$b = a + m, c = a + n$$<br>$$a</em>(b+c) = b<em>c -1 =&gt; m</em>n = a<em>a + 1$$<br>因为需要求b+c的最小值也就是m,n的最小值因而很容易理解m从a开始往下搜, (a</em>a+1)%m==0结束<br>最后$$b+c = 2*a + m + n$$<br>代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	__int64 a,b,c;</span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%I64d"</span>,&amp;a)==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		__int64 m,n;</span><br><span class="line">		<span class="keyword">for</span> (m=a;m&gt;=<span class="number">1</span>;m--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> ((a*a+<span class="number">1</span>) %m ==<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		n = (a*a+<span class="number">1</span>)/m;</span><br><span class="line">		printf(<span class="string">"%I64d\n"</span>,<span class="number">2</span>*a+m+n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u6B27_u51E0_u91CC_u5F97_u7B97_u6CD5_u548C_u6269_u5C55_u6B27_u51E0_u91CC_u5F97_u7B97_u6CD5"><a href="#u6B27_u51E0_u91CC_u5F97_u7B97_u]]>
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ceph:可靠的, 可扩展的高性能分布式系统]]></title>
    <link href="http://yoursite.com/year/01/01/Ceph/"/>
    <id>http://yoursite.com/year/01/01/Ceph/</id>
    <published>2016-01-01T15:36:54.000Z</published>
    <updated>2016-01-27T00:59:40.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u6458_u8981"><a href="#u6458_u8981" class="headerlink" title="摘要"></a>摘要</h4><hr>
<p>随着存储系统容量和性能的需要，文件系统设计者已将目光转向新的方便系统扩展的架构。新兴的基于对象存储明显和基于服务器存储(NFS)，基于SAN存储系统不同。对象存储系统通过连接处理器和带有磁盘设备的内存，允许系统授权底层文件系统操作(比如分配和调度)给对象存储设备(OSD)，并且将元数据(文件open/close)的操作与IO(读/写)分离。甚至最近的基于对象的系统沿袭了多种几十年前的架构选择，仿佛回到早期的UNIX文件系统，然而，限制了它们的高效扩展能力。<br>本文表明设备的智能性能被利用在动态集群环境中提供可靠的，可扩展的高性能文件服务。它提出了一个分布式元数据管理架构能够提供优越的性能和扩展性，在容忍随机节点宕机的时候能够适应高度变化的系统负载。灵活和强大的数据分布函数将数据对象放在大型，动态的存储设备集群中，提供了数据均匀分布，关联设备错误的保护以及高效地数据迁移的同时，简化了元数据且方便系统扩展。这种布局算法有利于可靠的，可扩展的对象存储服务的建立，该服务能够通过一个异构的半自治设备集群分散一致的数据复制，故障检测和恢复的复杂度。<br>这些已经运行在Ceph分布式文件系统上的架构模块，通过一系列的负载测试显示出卓越的IO性能，可扩展的元数据管理和错误恢复。</p>
<h4 id="u4ECB_u7ECD"><a href="#u4ECB_u7ECD" class="headerlink" title="介绍"></a>介绍</h4><hr>
<p>系统设计者一直都在试图改善文件系统的性能，这对于极为广泛的一类应用的整体性能极为重要。学术界尤其是高性能计算组织在分布式存储系统的性能和扩展性保持领先，通常预示着未来几年的更加通用的需要。传统的解决方案，比如NFS，提供一个直接的模型，服务器对外一个文件系统层次使得客户机可以映射到它们的本地名字空间。即使是被广泛使用，客户机/服务器的中心化本质已被证明是扩展性能的极大阻碍。<br>最近更多的分布式文件系统已经采用基于对象存储的架构，原先传统的硬盘已经被智能的对象存储设备(OSDs)替换，OSD是结合了一个CPU，网络接口和带有磁盘或者硬盘的本地缓存的设备。OSD替换传统的客户端进行读写字节的块层接口，使用读写字节数范围更大的对象，将块分配的决定分给设备本身。客户端通常和元数据服务器(MDS)交流去进行元数据操作(open,rename)，同时直接和OSD交流进行文件的IO(read and write)，极大地提高了整体的性能。<br>由于元数据负载分布小或者没有时，采用这种模型的系统会遭受扩展的限制。受限于传统的文件系统设计原则比如分配目录和i节点表不愿意授权OSD的智能导致受限的扩展和性能，从而提高了可靠性的代价。<br>这个架构是基于PB级规模的系统本质上是动态的<strong>假设</strong>，一个大系统中不可避免是逐步建成的，节点的故障应该是常态而不是例外，工作负载的质量和特征是随着时间的推移不断变化的。<br>Ceph通过消除文件分配表，使用新型的生成函数取代他们来实现数据和元数据的分离。这样一来，Ceph可以利用中OSD的智能性分散数据访问，更新序列化，复制性和可靠性，故障检测和恢复的复杂度。Ceph采用自适应分布式元数据集群架构，简化常见的元数据操作，同时显著提高了元数据访问的扩展性，从而提高整个系统的扩展性。作者讨论了架构设计时的针对的目标和负载假设，分析其对系统的扩展性，性能和可靠性的影响，并结合相关的经验实现了功能系统的原型。</p>
<h5 id="u8D21_u732E"><a href="#u8D21_u732E" class="headerlink" title="贡献"></a>贡献</h5><hr>
<p>本文的论点是，智能设备可以被用在一个动态集群环境中提供可靠的，可扩展和高性能的文件服务。<br>这篇论文的基本贡献集中在以下三点:<br>首先，作者提出了一个分布式元数据管理架构，可提供卓越的性能和可扩展性，同时无缝地容忍任意节点崩溃。Ceph的MDS区别于常规的元数据存储技术，这样做有利于适应文件系统和服务器之间的负载分配，改进元数据可用性和故障恢复。具体而言，文件系统元数据的更新最初写入到大的，lazy修剪的MDS日志中，该日志能够吸纳暂时的，重复的更新。文件(i节点)的元数据被嵌入在文件系统名字空间，然后存储在每个目录对象里面，这样能进行有效的读访问和元数据预取。作者对分布式元数据分区技术进行比较分析，并说明Ceph使用的新动态子树划分方法。值得注意的是，作者的MDS针对目录定义了命名空间层次结构，促进细粒度甚至大型或忙碌的目录的负载分配，并且实现了流量控制机制，通过MDS集群中的多个节点分散由客户端节点的并发访问负载。<br>这项工作的第二个贡献是有一个强大的分层数据分布功能，能够将数据放置在一个大的分布式存储系统中。该算法取代了常规分配表的使用，有效地解决了一系列重要的存储相关的放置问题，包括在动态变化的存储集群中的统计数据的均匀分布，以及相关故障解决，数据安全性和数据迁移。具体地讲，该算法利用灵活的规则语言将数据对象(对象副本，或奇偶或擦除编码的片段)集合放置在存储设备的某一层次。当设备添加到集群中或移除，灵活的分层集群能够在高效的位置计算和映射稳定性之间提供调节平衡。它进一步提供了为用户定义错误域副本的强制分离能力，限制由于相关的故障导致的数据损失。<br>作者的第三个贡献是一个分布式对象存储架构，充分利用设备智能化提供的可靠和可扩展的存储，抽象出最小的监控，具体来说，作者描述了一个高效，可扩展，低开销的集群管理协议，有利于通过小集群的映射传播一致性和连贯性的数据访问，来指定设备的成员关系和数据分布。这使得半自治的OSD动态集群能进行自我管理统一的数据副本，故障检测和故障恢复，同时提供对数据进行直接的，高性能的客户端访问单一逻辑对象存储的假象。<br>这些贡献已经被运作在Ceph文件系统原型中，原型系统代码大约4万行，并且已经在LGPL协议下开源，用于研究平台和参考实现。</p>
<h5 id="u7EB2_u8981"><a href="#u7EB2_u8981" class="headerlink" title="纲要"></a>纲要</h5><hr>
<p>在本文的其余部分的结构如下:<br>第三章介绍了文件系统设计现有的方式，以及通用的能影响性能，扩展性和可靠性的架构用于Ceph的情况。具体的相关工作在后面的章节讨论。<br>第四章介绍了Ceph架构和关键的设计特点。系统整体的操作是从客户机展现基本的文件系统的角度来描述的，这样方便看清变化的系统组件交互的概貌。<br>第五章描述了Ceph元数据服务器(MDS)的设计，运行和性能特点。作者关注于Ceph的非常规设计方法对文件(i节点)存储和元数据存储上的日志更新，动态负载分配以及错误恢复的影响。各种静态文件系统快照和工作负载跟踪的分析被用于改进设计决策和性能分析，Ceph的性能是在一系列微基准测试中，正常使用和故障场景下的工作负载下评估的。<br>第六章描述了Ceph中用于在对象存储设备中分布数据的特殊目标数据放置算法CRUSH。具体的讲就是作者通过消除传统的分配映射，取而代之的是低功耗的函数来解决在大型动态集群设备中的数据分布问题。各种关于扩展性，数据安全和性能问题被考虑到了。<br>第七章介绍了RADOS(Reliable Autonomic Distributed Object Store)，Ceph中的可靠的，自治的，分布式对象存储。RADOS提供一个极其可扩展的存储集群管理平台能够暴露一个简单的对象存储抽象。系统组件利用对象存储无需考虑副本的细节，数据的再分配(当集群成员扩展或缩减时)，错误检测以及错误恢复，这样可以预期可扩展的，可靠的高性能的对象访问。<br>第八章描述了EBOFS，是利用了RADOS的底层对象存储库能够在本地直连地磁盘上高效地管理对象集合。<br>第九章提供了一些结论，描述了继续研究的方向。</p>
<h4 id="u76F8_u5173_u7684_u5DE5_u4F5C"><a href="#u76F8_u5173_u7684_u5DE5_u4F5C" class="headerlink" title="相关的工作"></a>相关的工作</h4><hr>
<p>这项研究借鉴了大量的文件和存储系统地研究经验，其中包括本地文件系统(本地直连磁盘)，网络文件系统(连接远程服务器)，以及一系列分布式文件系统架构，这些架构中的文件系统数据都是通过多个主机传输。</p>
<h5 id="u672C_u5730_u6587_u4EF6_u7CFB_u7EDF"><a href="#u672C_u5730_u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="本地文件系统"></a>本地文件系统</h5><hr>
<p>文件系统的设计在过去的三十年里深受原始的Unix文件系统的影响，比如能在BSD Unix的发现快速文件系统(FFS)[65]。这些早期的文件系统形成的接口和行为标准POSIX SUS (单一Unix规范)[12]符合最现代化的系统和应用程序。<br>BSD的FFS，像大多数本地文件系统，被设计用来在本地直连的硬盘中存储固定大小的扇区和块。(对比之，Ceph是操作大量通过网络连接的主机的集群文件系统)。当时的硬盘在块上的定位速度很慢，但一旦定位可以相对快速读取数据。为了尽量避免寻道的延时，FFS加入了Cylinder Group(柱面组)，相关的数据和元数据被存储在同一柱面组中，通过减少磁盘臂的重新定位，也即是利用旋转磁盘的柱面组的局部性原理减少寻道时间。<br>在过去的几十年中，磁盘的性能已显著增加。然而，定位等待时间已经远远落后于磁盘传输速率的提高，使得数据在磁盘上的精心布局，甚至比以前更加重要。减少定位延迟的驱使在Sprite网络操作系统上设计日志结构文件系统（LFS）[26,78]，LFS通过在磁盘上的日志结构顺序记录新的数据来避免写负载的定位延时。元数据结构会被定期刷新到磁盘上的日志，以允许预先写入的数据被定位和重新读。然而，为了从已删除的文件收回磁盘空间，LFS需要一个“清理器”的重新定位日志记录，这会在负载多的情况下降低性能。[87,88]<br>DualFS[73]使用LFS风格的日志来将元数据写入分离的设备，(DualFS分离了数据和元数据的存储)，通过消除庞大的文件数据来减少清理器的影响。虽然DualFS和LFS都需要特殊的索引节点映射文件将索引节点编号翻译到磁盘上，DualFS通过存储最近修改的目录项和索引节点合并到日志中来提高元数据的性能。虽然柱面组的概念多年来一直在完善，但是FFS介绍的基本的元数据结构和分配策略依然存在在典型的本地文件系统中，比如ext3[95]。随着文件系统的大小扩展比硬盘架构快得多，元数据结构也在调整。比如，文件的大小增加了但是硬盘的块大小因为小文件的高效存储仍然很小，经常是4KB。对于大的文件，这会导致非常长的枚举文件数据位置的块分配表。现代的本地文件系统比如XFS取代了分配列表扩展成为描述磁盘大区域(利用起始点和长度描述)。<br>现代的文件系统还引入了可靠的特性能在发生故障后简单的快速恢复，与大多数常用的文件系统一样，XFS在磁盘上保留一个记录元数据更新的日志文件，这个文件存在于即将被执行的状态。在出现故障的情况下，日志能够被读出来以确保更新被成功和正确的应用，或者清除任何部分的应用更新。虽然日志带来性能损失(磁盘需要重新定位自己附加到日志，每个元数据的更新被写入磁盘两次)，但是它们避免了在故障恢复时一致性检查的更加昂贵的代价(当文件系统扩展的时候代价更高)。<br>很多系统还实现了软更新，其中的修改仅写入到磁盘的未分配的区域以确保磁盘上的镜像始终是一致的(或容易修复)[64]。WAFL文件系统，比如当更新层次元数据结构的时候采用写时拷贝的方法，将所有新的数据写到磁盘中未分配的数据，以致于所有的变化提交只是改变一个指针到树的根节点指向。WAFL也维护一个类日志结构，但是只是为了保护提交更新之间的持续性，而不是维护文件系统的一致性。类似的技术也被用到了Ceph中的对象存储部件EBOFS中。</p>
<h5 id="u5BA2_u6237_u7AEF-_u670D_u52A1_u5668_u6587_u4EF6_u7CFB_u7EDF"><a href="#u5BA2_u6237_u7AEF-_u670D_u52A1_u5668_u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="客户端-服务器文件系统"></a>客户端-服务器文件系统</h5><p>在网络计算环境中共享存储资源和数据的愿望产生了许多的客户端-服务器文件系统。最常用的是NFS[72]和CIFS[38]，能允许中央服务器对外输出文件系统，远程系统能映射其到它们自己的名字空间。中心化的存储便于提供专门的，高性能存储系统，这就是所谓的NAS存储区域网络。然而，中心化继承客户端-服务器架构本身严重阻碍了扩展性，因为所有的文件系统都通过单个服务器处理。在大型安装中，管理员通常将数据子集分配到具体的服务器，然后通过每个客户端上挂载多个服务器将这些数据子集映射到客户端上的单个名字空间。虽然相当有效和普遍，这种方法会造成管理问题，比如某些数据集需要增长或收缩时需要手动迁移到其他服务器上。<br>网络文件系统为了保持分布式环境的缓存性能通常放宽了一致性语义。比如NFS客户机异步回写文件数据到服务器，使得来自其他客户端主机并发访问文件，可能不总是返回最新数据的拷贝。类似的，客户端通常隔一段时间缓存文件的元数据来限制客户机和服务器的交互负载，放宽文件系统的一致性会造成很多应用程序的问题，应该避免他们在NFS环境中的使用。</p>
<h5 id="u5206_u5E03_u5F0F_u6587_u4EF6_u7CFB_u7EDF"><a href="#u5206_u5E03_u5F0F_u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h5><p>分布式文件系统试图解决客户端-服务器系统固有的负载平衡和扩展性问题。早期分布式文件系统包括AFS [43], Coda [85], 并且能在Sprite [71]找到。这些系统利用中央服务器协调文件系统访问，服务器向客户端缓存承诺一段时间的数据有效性，在冲突访问的时候可以撤销承诺。然而，Sprite在只写共享事件时简单地关闭缓存，AFS采用按照文件的打开与关闭模型而不是单独的读写事件。相反，NFS(类似于托管的方式)是无状态的设计，牺牲了数据共享时的一致性。<br>Sprite在不同的服务器之间划分文件系统，即是静态地将文件系统的名字空间划分到域里，然后动态地将域映射到服务器。AFS采用了一个混合方案，在多个卷中基于文件的名字和标识符来划分文件，每个卷被分给服务器。在这两个系统中，用户可以通过有限的链接和原子重命名的支持可看到划分边界。与这些系统不同的是，ceph目的在于提供统一的名字命名空间和完全一致的POSIX语义。<br>分布式架构由于需要容错会经常在多个服务期间进行数据的拷贝。Harp [61] 文件系统中:服务器采用主拷贝复制和预写日志能在节点失败的事件中更快的恢复。大量的存储子系统使用类似的技术来提供基于块的存储访问。Petal [56] 提供一个被动态集群服务器管理的稀疏的虚拟磁盘抽象。FAB [82] 提供一个基于少数服从多数的的副本一致性协议。Ceph提供基于对象接口的分布式和一致性存储服务，类似于FAB的相当简单的一致性协议和更好的扩展性。<br>很多本地文件系统通过开发一层分布式存储层的抽象来促使RAID更加可靠。类似的 Boxwood [63] 提供一个块设备的文件服务，是第一个通过B树的数据结构实现的。Ceph也是利用B树在RADOS层进行抽象，是使用的对象存储而不是块接口</p>
<h6 id="u5E7F_u57DF_u6587_u4EF6_u7CFB_u7EDF"><a href="#u5E7F_u57DF_u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="广域文件系统"></a>广域文件系统</h6><p>大多数系统都在研究在广域网或者全球环境下分布式文件系统组件。XFS [99] 基于无效的高速缓存一致性协议，以促使更加积极地的客户端高速缓存，在某些情况下允许从对等的高速缓存中读取数据，虽然有更高的实现复杂度，但是最大限度地减少通过广域网的通信。OceanStore [52]文件系统目标在于提供纠错码的全球文件存储服务和位置无关的路由抽象。Pangaea [83]也是针对类似的广域环境，当文件内容被读的时候就积极复制文件内容，同时在没有明确要求副本一致的时候就放宽副本一致性。基本上所有这些系统都着眼于最大限度地减少网络中的通信(甚至以牺牲一致性为代价)和增加扩展性。集群环境中的高性能访问(集群环境网络相对便宜)不是Ceph的设计目标。</p>
<h6 id="SAN_u6587_u4EF6_u7CFB_u7EDF"><a href="#SAN_u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="SAN文件系统"></a>SAN文件系统</h6><p>意识到大多数文件的IO操作(读写无关的不同文件操作)是本质上的并行是基于底层存储设备的共享。所谓的SAN存储区域网络是基于硬盘或磁盘控制器通过光纤通道网络，允许任何连接主机发出命令来连接任何磁盘。<br>大多数SAN文件系统采用分布式锁管理器(DLM)[51]来协调共享块存储访问。也会采取其他的措施来限制锁争用的可能性，比如GPFS[86]中的块分配中的局部分布。其他系统，类似StorageTank[66]保护文件系统的元数据的锁策略会限制扩展性，于是采用了附加的集群服务器来管理文件系统元数据(层次空间，访问控制和块分配)。</p>
<h6 id="u5BF9_u8C61_u548C_u57FA_u4E8Ebrick_u7684_u5B58_u50A8"><a href="#u5BF9_u8C61_u548C_u57FA_u4E8Ebrick_u7684_u5B58_u50A8" class="headerlink" title="对象和基于brick的存储"></a>对象和基于brick的存储</h6><p>最近，很多文件系统和平台，包括FAB[82], PVFS[55], and pNFS[39]都在围绕网络附加存储集群设计。像StorageTank，元数据是被独立的服务器管理，但是文件的IO是直接发生在与集群服务器交互，而不是光纤通道磁盘。这使得某些功能(比如底层的块分配决定)被分配给设备本身。<br>Lustre[14],Panasas文件系统[104],zFS[76],Sorrento[93],Ursa Minor [1],和Kybos[107]都是和对象存储密切相关的。相对于数据存储在小的，固定的块中的处理方式，对象存储用一个名字(典型的是一个平面的128位的名字空间)，一个变化的大小(从字节到千兆字节)，并且每个对象的元数据都会有访问权限描述。基于对象的存储允许半智能化的设备执行底层的块分配和强制安全能力，减少服务器管理元数据的争用提高整个系统的可扩展性。<br>尽管这些基于对象的系统和ceph相似，但是他们没有Ceph提供的扩展性和适应性强的元数据管理，可靠性和容错性。Lustre and Panasas将底层块设备的分配交给了OSD，减少了文件元数据的数量，但是在其他方面就很少利用设备的智能。除了Sorrento以外的所有这些系统都是显式分配映射来指定对象存储的位置，这限制了对象目录服务器之间的数据迁移。和Ceph一样，Sorrento采用的函数描述而不是依靠传统的传统的分配表来放置存储节点数据位置。Sorrento缺少Ceph的高效数据迁移，设备权重和故障域副本的分离支持。最重要的是ceph的数据分布函数功能允许OSDs管理分布式方式下的数据迁移和故障恢复。<br>Kybos利用设备的智能预留的服务质量，使用两相更行的网络RAID协议存储数据，Ceph采用的是一个更加简单的副本协议。Ursa Minor提供了支持复制，根据编码的奇偶校验，一致性模型的分布式对象存储服务，能根据应用的需求提供分布式对象存储服务。所有这些系统都会有扩展性和性能的限制。</p>
<h6 id="u975E_u53EF_u79FB_u690D_u63A5_u53E3_u7684_u7CFB_u7EDF"><a href="#u975E_u53EF_u79FB_u690D_u63A5_u53E3_u7684_u7CFB_u7EDF" class="headerlink" title="非可移植接口的系统"></a>非可移植接口的系统</h6><p>一些分布式文件系统采用非POSIX文件系统接口。Farsite[2, 25]连接大量不可靠的工作站组成分布式文件系统提供Byzantine容错的windows文件服务。值得注意的是，这不支持硬链接。然而，ceph在可用服务器之间动态地分布文件系统名字空间的管理，动态分区子树在后面被讨论。<br>Sorrento文件系统是POSIX的，但是像AFS一样采用了宽松的一致性模型，简化了元数据的管理和在写共享时的一致性更新。其他系统的简化一致性更为显著。Cedar [32]讲一致性问题转化为共享文件的不变性，而在Venti[75]中所有的数据被认为是不变的。<br>虽然Google文件系统架构和基于对象的系统类似，但是它没有使用标准的文件系统接口，并且在大文件和工作负载组成的读操作和文件追加写上面有所优化。</p>
<h4 id="Ceph_u7ED3_u6784"><a href="#Ceph_u7ED3_u6784" class="headerlink" title="Ceph结构"></a>Ceph结构</h4><h5 id="Ceph"><a href="#Ceph" class="headerlink" title="Ceph"></a>Ceph</h5><h5 id="u5BA2_u6237_u7AEF_u64CD_u4F5C"><a href="#u5BA2_u6237_u7AEF_u64CD_u4F5C" class="headerlink" title="客户端操作"></a>客户端操作</h5><h6 id="u6587_u4EF6IO_u548C_u6027_u80FD"><a href="#u6587_u4EF6IO_u548C_u6027_u80FD" class="headerlink" title="文件IO和性能"></a>文件IO和性能</h6><h6 id="u5BA2_u6237_u7AEF_u540C_u6B65"><a href="#u5BA2_u6237_u7AEF_u540C_u6B65" class="headerlink" title="客户端同步"></a>客户端同步</h6><h6 id="u540D_u5B57_u7A7A_u95F4_u7684_u64CD_u4F5C"><a href="#u540D_u5B57_u7A7A_u95F4_u7684_u64CD_u4F5C" class="headerlink" title="名字空间的操作"></a>名字空间的操作</h6><h5 id="u901A_u4FE1_u6A21_u578B"><a href="#u901A_u4FE1_u6A21_u578B" class="headerlink" title="通信模型"></a>通信模型</h5><h4 id="u5206_u5E03_u5F0F_u5143_u6570_u636E_u7BA1_u7406"><a href="#u5206_u5E03_u5F0F_u5143_u6570_u636E_u7BA1_u7406" class="headerlink" title="分布式元数据管理"></a>分布式元数据管理</h4><h5 id="u80CC_u666F_u548C_u76F8_u5173_u7684_u5DE5_u4F5C"><a href="#u80CC_u666F_u548C_u76F8_u5173_u7684_u5DE5_u4F5C" class="headerlink" title="背景和相关的工作"></a>背景和相关的工作</h5><h6 id="u672C_u5730_u6587_u4EF6_u7CFB_u7EDF-1"><a href="#u672C_u5730_u6587_u4EF6_u7CFB_u7EDF-1" class="headerlink" title="本地文件系统"></a>本地文件系统</h6><h6 id="u5206_u5E03_u5F0F_u6587_u4EF6_u7CFB_u7EDF-1"><a href="#u5206_u5E03_u5F0F_u6587_u4EF6_u7CFB_u7EDF-1" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h6><h5 id="u5143_u6570_u636E_u5B58_u50A8"><a href="#u5143_u6570_u636E_u5B58_u50A8" class="headerlink" title="元数据存储"></a>元数据存储</h5><h6 id="u5D4C_u5165i_u8282_u70B9"><a href="#u5D4C_u5165i_u8282_u70B9" class="headerlink" title="嵌入i节点"></a>嵌入i节点</h6><h6 id="u8FDC_u7A0B_u8FDE_u63A5_u548C_u951A_u8868"><a href="#u8FDC_u7A0B_u8FDE_u63A5_u548C_u951A_u8868" class="headerlink" title="远程连接和锚表"></a>远程连接和锚表</h6><h6 id="u5927_u65E5_u5FD7"><a href="#u5927_u65E5_u5FD7" class="headerlink" title="大日志"></a>大日志</h6><h5 id="u81EA_u9002_u5E94_u7684_u8D1F_u8F7D_u5747_u8861"><a href="#u81EA_u9002_u5E94_u7684_u8D1F_u8F7D_u5747_u8861" class="headerlink" title="自适应的负载均衡"></a>自适应的负载均衡</h5><h6 id="u5B50_u6811_u5212_u5206_u8F6F_u72B6_u6001"><a href="#u5B50_u6811_u5212_u5206_u8F6F_u72B6_u6001" class="headerlink" title="子树划分软状态"></a>子树划分软状态</h6><h6 id="u5143_u6570_u636E_u5197_u4F59"><a href="#u5143_u6570_u636E_u5197_u4F59" class="headerlink" title="元数据冗余"></a>元数据冗余</h6><h6 id="u4E0A_u9501"><a href="#u4E0A_u9501" class="headerlink" title="上锁"></a>上锁</h6><h6 id="u8D1F_u8F7D_u5747_u8861"><a href="#u8D1F_u8F7D_u5747_u8861" class="headerlink" title="负载均衡"></a>负载均衡</h6><h6 id="u5B50_u6811_u8FC1_u79FB"><a href="#u5B50_u6811_u8FC1_u79FB" class="headerlink" title="子树迁移"></a>子树迁移</h6><h6 id="u76EE_u5F55_u788E_u7247"><a href="#u76EE_u5F55_u788E_u7247" class="headerlink" title="目录碎片"></a>目录碎片</h6><h6 id="u4EA4_u6362_u63A7_u5236"><a href="#u4EA4_u6362_u63A7_u5236" class="headerlink" title="交换控制"></a>交换控制</h6><h5 id="u9519_u8BEF_u6062_u590D"><a href="#u9519_u8BEF_u6062_u590D" class="headerlink" title="错误恢复"></a>错误恢复</h5><h6 id="u65E5_u5FD7_u7ED3_u6784"><a href="#u65E5_u5FD7_u7ED3_u6784" class="headerlink" title="日志结构"></a>日志结构</h6><h6 id="u9519_u8BEF_u68C0_u6D4B"><a href="#u9519_u8BEF_u68C0_u6D4B" class="headerlink" title="错误检测"></a>错误检测</h6><h6 id="u6062_u590D"><a href="#u6062_u590D" class="headerlink" title="恢复"></a>恢复</h6><h6 id="u8BA8_u8BBA"><a href="#u8BA8_u8BBA" class="headerlink" title="讨论"></a>讨论</h6><h5 id="u8BC4_u4EF7"><a href="#u8BC4_u4EF7" class="headerlink" title="评价"></a>评价</h5><h6 id="u5143_u6570_u636E_u5212_u5206"><a href="#u5143_u6570_u636E_u5212_u5206" class="headerlink" title="元数据划分"></a>元数据划分</h6><h6 id="u5D4C_u5165i_u8282_u70B9-1"><a href="#u5D4C_u5165i_u8282_u70B9-1" class="headerlink" title="嵌入i节点"></a>嵌入i节点</h6><h6 id="u65E5_u5FD7_u8BB0_u5F55"><a href="#u65E5_u5FD7_u8BB0_u5F55" class="headerlink" title="日志记录"></a>日志记录</h6><h6 id="u81EA_u9002_u5E94_u7684_u5206_u914D"><a href="#u81EA_u9002_u5E94_u7684_u5206_u914D" class="headerlink" title="自适应的分配"></a>自适应的分配</h6><h6 id="u5143_u6570_u636E_u6269_u5C55"><a href="#u5143_u6570_u636E_u6269_u5C55" class="headerlink" title="元数据扩展"></a>元数据扩展</h6><h6 id="u9519_u8BEF_u6062_u590D-1"><a href="#u9519_u8BEF_u6062_u590D-1" class="headerlink" title="错误恢复"></a>错误恢复</h6><h6 id="u5B9E_u7528_u6027"><a href="#u5B9E_u7528_u6027" class="headerlink" title="实用性"></a>实用性</h6><h5 id="u672A_u6765_u7684_u5DE5_u4F5C"><a href="#u672A_u6765_u7684_u5DE5_u4F5C" class="headerlink" title="未来的工作"></a>未来的工作</h5><h5 id="u7ECF_u9A8C"><a href="#u7ECF_u9A8C" class="headerlink" title="经验"></a>经验</h5><h5 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h5><h4 id="u6570_u636E_u5212_u5206"><a href="#u6570_u636E_u5212_u5206" class="headerlink" title="数据划分"></a>数据划分</h4><h5 id="u76F8_u5173_u7684_u5DE5_u4F5C-1"><a href="#u76F8_u5173_u7684_u5DE5_u4F5C-1" class="headerlink" title="相关的工作"></a>相关的工作</h5><h5 id="CRUSH_u7B97_u6CD5"><a href="#CRUSH_u7B97_u6CD5" class="headerlink" title="CRUSH算法"></a>CRUSH算法</h5><h6 id="u5C42_u6B21_u96C6_u7FA4_u6620_u5C04"><a href="#u5C42_u6B21_u96C6_u7FA4_u6620_u5C04" class="headerlink" title="层次集群映射"></a>层次集群映射</h6><h6 id="u526F_u672C_u653E_u7F6E"><a href="#u526F_u672C_u653E_u7F6E" class="headerlink" title="副本放置"></a>副本放置</h6><h6 id="u6620_u5C04_u6539_u53D8_u548C_u6570_u636E_u79FB_u52A8"><a href="#u6620_u5C04_u6539_u53D8_u548C_u6570_u636E_u79FB_u52A8" class="headerlink" title="映射改变和数据移动"></a>映射改变和数据移动</h6><h6 id="u6876_u7C7B_u578B"><a href="#u6876_u7C7B_u578B" class="headerlink" title="桶类型"></a>桶类型</h6><h5 id="u8BC4_u4EF7-1"><a href="#u8BC4_u4EF7-1" class="headerlink" title="评价"></a>评价</h5><h6 id="u6570_u636E_u5206_u914D"><a href="#u6570_u636E_u5206_u914D" class="headerlink" title="数据分配"></a>数据分配</h6><h6 id="u91CD_u7EC4_u7EC7_u548C_u6570_u636E_u79FB_u52A8"><a href="#u91CD_u7EC4_u7EC7_u548C_u6570_u636E_u79FB_u52A8" class="headerlink" title="重组织和数据移动"></a>重组织和数据移动</h6><h6 id="u7B97_u6CD5_u6027_u80FD"><a href="#u7B97_u6CD5_u6027_u80FD" class="headerlink" title="算法性能"></a>算法性能</h6><h6 id="u53EF_u9760_u6027"><a href="#u53EF_u9760_u6027" class="headerlink" title="可靠性"></a>可靠性</h6><h5 id="u672A_u6765_u7684_u5DE5_u4F5C-1"><a href="#u672A_u6765_u7684_u5DE5_u4F5C-1" class="headerlink" title="未来的工作"></a>未来的工作</h5><h5 id="u603B_u7ED3-1"><a href="#u603B_u7ED3-1" class="headerlink" title="总结"></a>总结</h5><h4 id="u5206_u5E03_u5F0F_u5BF9_u8C61_u5B58_u50A8"><a href="#u5206_u5E03_u5F0F_u5BF9_u8C61_u5B58_u50A8" class="headerlink" title="分布式对象存储"></a>分布式对象存储</h4><h5 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h5><h5 id="u5206_u5E03_u5F0F_u5BF9_u8C61_u5B58_u50A8-1"><a href="#u5206_u5E03_u5F0F_u5BF9_u8C61_u5B58_u50A8-1" class="headerlink" title="分布式对象存储"></a>分布式对象存储</h5><h6 id="u6570_u636E_u653E_u7F6E"><a href="#u6570_u636E_u653E_u7F6E" class="headerlink" title="数据放置"></a>数据放置</h6><h6 id="u96C6_u7FA4_u6620_u5C04"><a href="#u96C6_u7FA4_u6620_u5C04" class="headerlink" title="集群映射"></a>集群映射</h6><h6 id="u901A_u4FE1_u548C_u5931_u8BEF_u6A21_u578B"><a href="#u901A_u4FE1_u548C_u5931_u8BEF_u6A21_u578B" class="headerlink" title="通信和失误模型"></a>通信和失误模型</h6><h6 id="u76D1_u89C6_u5668"><a href="#u76D1_u89C6_u5668" class="headerlink" title="监视器"></a>监视器</h6><h6 id="u6620_u5C04_u4F20_u64AD"><a href="#u6620_u5C04_u4F20_u64AD" class="headerlink" title="映射传播"></a>映射传播</h6><h5 id="u53EF_u9760_u7684_u81EA_u6CBB_u5B58_u50A8"><a href="#u53EF_u9760_u7684_u81EA_u6CBB_u5B58_u50A8" class="headerlink" title="可靠的自治存储"></a>可靠的自治存储</h5><h6 id="u91CD_u590D"><a href="#u91CD_u590D" class="headerlink" title="重复"></a>重复</h6><h6 id="u5E8F_u5217_u5316_u4E0E_u5B89_u5168"><a href="#u5E8F_u5217_u5316_u4E0E_u5B89_u5168" class="headerlink" title="序列化与安全"></a>序列化与安全</h6><h6 id="u6620_u5C04_u4E0E_u4E00_u81F4_u6027"><a href="#u6620_u5C04_u4E0E_u4E00_u81F4_u6027" class="headerlink" title="映射与一致性"></a>映射与一致性</h6><h6 id="u7248_u672C_u4E0E_u65E5_u5FD7"><a href="#u7248_u672C_u4E0E_u65E5_u5FD7" class="headerlink" title="版本与日志"></a>版本与日志</h6><h6 id="u9519_u8BEF_u6062_u590D-2"><a href="#u9519_u8BEF_u6062_u590D-2" class="headerlink" title="错误恢复"></a>错误恢复</h6><h6 id="u5BA2_u6237_u7AEF_u4E0A_u9501_u548C_u7F13_u51B2"><a href="#u5BA2_u6237_u7AEF_u4E0A_u9501_u548C_u7F13_u51B2" class="headerlink" title="客户端上锁和缓冲"></a>客户端上锁和缓冲</h6><h5 id="u6027_u80FD_u548C_u53EF_u6269_u5C55_u6027"><a href="#u6027_u80FD_u548C_u53EF_u6269_u5C55_u6027" class="headerlink" title="性能和可扩展性"></a>性能和可扩展性</h5><h6 id="u53EF_u6269_u5C55_u6027"><a href="#u53EF_u6269_u5C55_u6027" class="headerlink" title="可扩展性"></a>可扩展性</h6><h6 id="u9519_u8BEF_u6062_u590D-3"><a href="#u9519_u8BEF_u6062_u590D-3" class="headerlink" title="错误恢复"></a>错误恢复</h6><h5 id="u672A_u6765_u7684_u5DE5_u4F5C-2"><a href="#u672A_u6765_u7684_u5DE5_u4F5C-2" class="headerlink" title="未来的工作"></a>未来的工作</h5><h5 id="u76F8_u5173_u7684_u5DE5_u4F5C-2"><a href="#u76F8_u5173_u7684_u5DE5_u4F5C-2" class="headerlink" title="相关的工作"></a>相关的工作</h5><h5 id="u7ED3_u8BBA"><a href="#u7ED3_u8BBA" class="headerlink" title="结论"></a>结论</h5><h4 id="u672C_u5730_u5BF9_u8C61_u5B58_u50A8"><a href="#u672C_u5730_u5BF9_u8C61_u5B58_u50A8" class="headerlink" title="本地对象存储"></a>本地对象存储</h4><h5 id="u5BF9_u8C61_u5B58_u50A8_u63A5_u53E3"><a href="#u5BF9_u8C61_u5B58_u50A8_u63A5_u53E3" class="headerlink" title="对象存储接口"></a>对象存储接口</h5><h5 id="u6570_u636E_u5E03_u5C40"><a href="#u6570_u636E_u5E03_u5C40" class="headerlink" title="数据布局"></a>数据布局</h5><h5 id="u6570_u636E_u5B89_u5168"><a href="#u6570_u636E_u5B89_u5168" class="headerlink" title="数据安全"></a>数据安全</h5><h5 id="u65E5_u5FD7_u8BB0_u5F55-1"><a href="#u65E5_u5FD7_u8BB0_u5F55-1" class="headerlink" title="日志记录"></a>日志记录</h5><h5 id="u8BC4_u4EF7-2"><a href="#u8BC4_u4EF7-2" class="headerlink" title="评价"></a>评价</h5><h5 id="u76F8_u5173_u7684_u5DE5_u4F5C-3"><a href="#u76F8_u5173_u7684_u5DE5_u4F5C-3" class="headerlink" title="相关的工作"></a>相关的工作</h5><h5 id="u7ED3_u8BBA-1"><a href="#u7ED3_u8BBA-1" class="headerlink" title="结论"></a>结论</h5><h4 id="u7ED3_u8BBA-2"><a href="#u7ED3_u8BBA-2" class="headerlink" title="结论"></a>结论</h4><h5 id="u672A_u6765_u7684_u5DE5_u4F5C-3"><a href="#u672A_u6765_u7684_u5DE5_u4F5C-3" class="headerlink" title="未来的工作"></a>未来的工作</h5><h6 id="MDS_u8D1F_u8F7D_u5E73_u8861"><a href="#MDS_u8D1F_u8F7D_u5E73_u8861" class="headerlink" title="MDS负载平衡"></a>MDS负载平衡</h6><h6 id="u5BA2_u6237_u7AEF_u63A5_u53E3"><a href="#u5BA2_u6237_u7AEF_u63A5_u53E3" class="headerlink" title="客户端接口"></a>客户端接口</h6><h6 id="u5B89_u5168"><a href="#u5B89_u5168" class="headerlink" title="安全"></a>安全</h6><h6 id="u914D_u989D"><a href="#u914D_u989D" class="headerlink" title="配额"></a>配额</h6><h6 id="u670D_u52A1_u7684_u8D28_u91CF"><a href="#u670D_u52A1_u7684_u8D28_u91CF" class="headerlink" title="服务的质量"></a>服务的质量</h6><h6 id="u5FEB_u7167"><a href="#u5FEB_u7167" class="headerlink" title="快照"></a>快照</h6><h5 id="u603B_u7ED3-2"><a href="#u603B_u7ED3-2" class="headerlink" title="总结"></a>总结</h5><h4 id="u4EA4_u6362_u5C42"><a href="#u4EA4_u6362_u5C42" class="headerlink" title="交换层"></a>交换层</h4><h5 id="u62BD_u8C61_u63A5_u53E3"><a href="#u62BD_u8C61_u63A5_u53E3" class="headerlink" title="抽象接口"></a>抽象接口</h5><h5 id="u7B80_u5355_u4FE1_u4F7F"><a href="#u7B80_u5355_u4FE1_u4F7F" class="headerlink" title="简单信使"></a>简单信使</h5><h5 id="u5047_u7684_u4FE1_u4F7F"><a href="#u5047_u7684_u4FE1_u4F7F" class="headerlink" title="假的信使"></a>假的信使</h5><h4 id="MDS_u7684_u5B9E_u73B0_u7EC6_u8282"><a href="#MDS_u7684_u5B9E_u73B0_u7EC6_u8282" class="headerlink" title="MDS的实现细节"></a>MDS的实现细节</h4><h5 id="MDS_u7684_u5206_u5E03_u5F0F_u7F13_u5B58"><a href="#MDS_u7684_u5206_u5E03_u5F0F_u7F13_u5B58" class="headerlink" title="MDS的分布式缓存"></a>MDS的分布式缓存</h5><h6 id="u7F13_u5B58_u7ED3_u6784"><a href="#u7F13_u5B58_u7ED3_u6784" class="headerlink" title="缓存结构"></a>缓存结构</h6><h6 id="u590D_u5236_u548C_u53EF_u9760_u6027"><a href="#u590D_u5236_u548C_u53EF_u9760_u6027" class="headerlink" title="复制和可靠性"></a>复制和可靠性</h6><h6 id="u5B50_u6811_u5212_u5206"><a href="#u5B50_u6811_u5212_u5206" class="headerlink" title="子树划分"></a>子树划分</h6><h5 id="u5143_u6570_u636E_u5B58_u50A8-1"><a href="#u5143_u6570_u636E_u5B58_u50A8-1" class="headerlink" title="元数据存储"></a>元数据存储</h5><h6 id="u76EE_u5F55_u788E_u7247_u548C_u7248_u672C"><a href="#u76EE_u5F55_u788E_u7247_u548C_u7248_u672C" class="headerlink" title="目录碎片和版本"></a>目录碎片和版本</h6><h6 id="u65E5_u5FD7_u5165_u53E3"><a href="#u65E5_u5FD7_u5165_u53E3" class="headerlink" title="日志入口"></a>日志入口</h6><h6 id="u951A_u8868"><a href="#u951A_u8868" class="headerlink" title="锚表"></a>锚表</h6><h5 id="u8FC1_u79FB"><a href="#u8FC1_u79FB" class="headerlink" title="迁移"></a>迁移</h5><h6 id="u7F13_u5B58_u57FA_u7840_u7ED3_u6784"><a href="#u7F13_u5B58_u57FA_u7840_u7ED3_u6784" class="headerlink" title="缓存基础结构"></a>缓存基础结构</h6><h6 id="u6B63_u5E38_u8FC1_u79FB"><a href="#u6B63_u5E38_u8FC1_u79FB" class="headerlink" title="正常迁移"></a>正常迁移</h6><h5 id="u9519_u8BEF_u6062_u590D-4"><a href="#u9519_u8BEF_u6062_u590D-4" class="headerlink" title="错误恢复"></a>错误恢复</h5><h6 id="u65E5_u5FD7_u91CD_u6F14"><a href="#u65E5_u5FD7_u91CD_u6F14" class="headerlink" title="日志重演"></a>日志重演</h6><h6 id="u89E3_u51B3_u9636_u6BB5"><a href="#u89E3_u51B3_u9636_u6BB5" class="headerlink" title="解决阶段"></a>解决阶段</h6><h6 id="u91CD_u8FDE_u9636_u6BB5"><a href="#u91CD_u8FDE_u9636_u6BB5" class="headerlink" title="重连阶段"></a>重连阶段</h6><h6 id="u91CD_u805A_u9636_u6BB5"><a href="#u91CD_u805A_u9636_u6BB5" class="headerlink" title="重聚阶段"></a>重聚阶段</h6><h5 id="u951A_u8868-1"><a href="#u951A_u8868-1" class="headerlink" title="锚表"></a>锚表</h5><h6 id="u8868_u66F4_u65B0"><a href="#u8868_u66F4_u65B0" class="headerlink" title="表更新"></a>表更新</h6><h6 id="u9519_u8BEF_u6062_u590D-5"><a href="#u9519_u8BEF_u6062_u590D-5" class="headerlink" title="错误恢复"></a>错误恢复</h6>]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u6458_u8981"><a href="#u6458_u8981" class="headerlink" title="摘要"></a>摘要</h4><hr>
<p>随着存储系统容量和性能的需要，文件系统设计者已将目光转向新的方便系统扩展的架构。新兴的基于对象]]>
    </summary>
    
      <category term="cloud computing" scheme="http://yoursite.com/tags/cloud-computing/"/>
    
      <category term="ceph" scheme="http://yoursite.com/categories/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://yoursite.com/year/01/01/hello-world/"/>
    <id>http://yoursite.com/year/01/01/hello-world/</id>
    <published>2016-01-01T02:20:30.000Z</published>
    <updated>2016-01-11T13:17:52.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.]]>
    </summary>
    
  </entry>
  
</feed>
