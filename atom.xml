<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Kiss]]></title>
  <subtitle><![CDATA[less is more]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-03-07T14:05:38.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[yankang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[硬盘分区]]></title>
    <link href="http://yoursite.com/year/03/07/%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA/"/>
    <id>http://yoursite.com/year/03/07/硬盘分区/</id>
    <published>2016-03-07T12:15:04.000Z</published>
    <updated>2016-03-07T14:05:38.000Z</updated>
    <content type="html"><![CDATA[<p>磁盘包括硬盘和软盘，都由磁性材料制成。磁盘英文名disk，硬盘英文名hard disk。写这篇博客主要是因为最近在运行ceph的时候突然报错说是无效的GPT头结构，然后就查了下GPT分区和MBR分区，这里记录我学习到的东西，更多详细的内容前辈们都已经提到过不再赘述，引用中大家可以去看。</p>
<h3 id="MBR_u5206_u533A_u548CGPT_u5206_u533A_u7B80_u4ECB"><a href="#MBR_u5206_u533A_u548CGPT_u5206_u533A_u7B80_u4ECB" class="headerlink" title="MBR分区和GPT分区简介"></a>MBR分区和GPT分区简介</h3><p><img src="/about/partition/1.png" alt="logo"><br>我们从上图看到partition table是gpt，可以设置为msdos的。我之前ceph运行出错的原因就是分区表类型是msdos，然后我改成gpt就解决了问题。<br>我的理解是分区表类型代表硬盘是什么分区，msdos代表的是MBR分区，gpt代表的是GPT分区。传统的BIOS只支持MBR分区硬盘启动，一个硬盘只能分成四个分区，并且单个分区最大不超过2TB。EFI支持GPT分区启动的，GPT分区没有分区数目的限制并且单个分区可以超过2TB。</p>
<h3 id="MBR_u5206_u533A_u548CGPT_u5206_u533A_u7684_u8F6C_u6362"><a href="#MBR_u5206_u533A_u548CGPT_u5206_u533A_u7684_u8F6C_u6362" class="headerlink" title="MBR分区和GPT分区的转换"></a>MBR分区和GPT分区的转换</h3><p>比如硬盘/dev/sdb</p>
<p>转换成GPT<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parted /dev/sdb</span><br><span class="line">mklabel gpt</span><br></pre></td></tr></table></figure></p>
<p>转换成MBR<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parted /dev/sdb</span><br><span class="line">mklabel msdos</span><br></pre></td></tr></table></figure></p>
<h3 id="fdisk_2C_sgdisk_u548Cparted_u5206_u533A_u5DE5_u5177"><a href="#fdisk_2C_sgdisk_u548Cparted_u5206_u533A_u5DE5_u5177" class="headerlink" title="fdisk, sgdisk和parted分区工具"></a>fdisk, sgdisk和parted分区工具</h3><h4 id="fdisk_28_u521B_u5EFAMBR_u5206_u533A_29_u5DE5_u5177_u5E38_u7528_u547D_u4EE4"><a href="#fdisk_28_u521B_u5EFAMBR_u5206_u533A_29_u5DE5_u5177_u5E38_u7528_u547D_u4EE4" class="headerlink" title="fdisk(创建MBR分区)工具常用命令"></a>fdisk(创建MBR分区)工具常用命令</h4><p>显示所有硬盘分区情况<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure></p>
<p>显示具体单个硬盘分区情况<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l /dev/sdb</span><br></pre></td></tr></table></figure></p>
<p>交互显示方便提示fdisk的所有命令如何使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure></p>
<h4 id="parted_28_u5B9E_u73B0_u5206_u533A_u7C7B_u578B_u8F6C_u6362_29_u5DE5_u5177_u5E38_u7528_u547D_u4EE4"><a href="#parted_28_u5B9E_u73B0_u5206_u533A_u7C7B_u578B_u8F6C_u6362_29_u5DE5_u5177_u5E38_u7528_u547D_u4EE4" class="headerlink" title="parted(实现分区类型转换)工具常用命令"></a>parted(实现分区类型转换)工具常用命令</h4><p>进入parted交互<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">parted /dev/sdb</span><br><span class="line"><span class="comment"># 打印硬盘信息</span></span><br><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment"># 搜索可用命令</span></span><br><span class="line">help</span><br><span class="line"><span class="comment"># 设置分区类型</span></span><br><span class="line">mklabel gpt</span><br></pre></td></tr></table></figure></p>
<h4 id="sgdisk_28_u521B_u5EFAGPT_u5206_u533A_29_u5DE5_u5177_u5E38_u7528_u547D_u4EE4_28_u5F15_u7528_u81EAhustcat_29"><a href="#sgdisk_28_u521B_u5EFAGPT_u5206_u533A_29_u5DE5_u5177_u5E38_u7528_u547D_u4EE4_28_u5F15_u7528_u81EAhustcat_29" class="headerlink" title="sgdisk(创建GPT分区)工具常用命令(引用自hustcat)"></a>sgdisk(创建GPT分区)工具常用命令(引用自hustcat)</h4><p>查看所有GPT分区<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sgdisk -p /dev/sdb</span><br></pre></td></tr></table></figure></p>
<p><img src="/about/partition/2.png" alt="logo"></p>
<p>查看某个分区的详细信息<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/sgdisk --info=<span class="number">1</span> /dev/sdb</span><br></pre></td></tr></table></figure></p>
<p><img src="/about/partition/3.png" alt="logo"></p>
<h3 id="u5F15_u7528"><a href="#u5F15_u7528" class="headerlink" title="引用"></a>引用</h3><p><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="external">计算机是如何启动的</a><br><a href="http://www.anchor.com.au/blog/2012/10/the-difference-between-booting-mbr-and-gpt-with-grub/" target="_blank" rel="external">The difference between booting MBR and GPT with GRUB</a><br><a href="http://hustcat.github.io/sgdisk-basic/" target="_blank" rel="external">sgdisk常用操作</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>磁盘包括硬盘和软盘，都由磁性材料制成。磁盘英文名disk，硬盘英文名hard disk。写这篇博客主要是因为最近在运行ceph的时候突然报错说是无效的GPT头结构，然后就查了下GPT分区和MBR分区，这里记录我学习到的东西，更多详细的内容前辈们都已经提到过不再赘述，引用中大]]>
    </summary>
    
      <category term="Storage" scheme="http://yoursite.com/tags/Storage/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Running ceph in docker containers]]></title>
    <link href="http://yoursite.com/year/03/05/Running-ceph-in-docker-containers/"/>
    <id>http://yoursite.com/year/03/05/Running-ceph-in-docker-containers/</id>
    <published>2016-03-05T12:35:59.000Z</published>
    <updated>2016-03-05T14:10:35.000Z</updated>
    <content type="html"><![CDATA[<p>由于毕设在研究docker容器中运行的ceph，现记录下我的运行过程。</p>
<h3 id="u73AF_u5883_u8BF4_u660E"><a href="#u73AF_u5883_u8BF4_u660E" class="headerlink" title="环境说明"></a>环境说明</h3><p>运行环境是centOS 7上安装的Docker version1.10.2。共计有三个主机，每个主机上配置两个硬盘，其中一个硬盘用于装系统，另一个硬盘作为OSD对象存储。由于MON所用计算资源和存储资源都很少所以直接在主机上运行。这样就共计三个MON和三个OSD。</p>
<h3 id="u4FEE_u6539_u4E3B_u673A_u540D"><a href="#u4FEE_u6539_u4E3B_u673A_u540D" class="headerlink" title="修改主机名"></a>修改主机名</h3><p>我的三个主机IP分别是192.168.3.65，192.168.3.66，192.168.3.67。将对应的主机名改为ceph1, ceph2, ceph3.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hostname</span><br></pre></td></tr></table></figure></p>
<h3 id="u6539_u53D8_u5BB9_u5668_u548C_u4E3B_u673A_u6620_u5C04_u7684_u76EE_u5F55_u6807_u7B7E"><a href="#u6539_u53D8_u5BB9_u5668_u548C_u4E3B_u673A_u6620_u5C04_u7684_u76EE_u5F55_u6807_u7B7E" class="headerlink" title="改变容器和主机映射的目录标签"></a>改变容器和主机映射的目录标签</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chcon -Rt svirt_sandbox_file_t /etc/ceph</span><br><span class="line">chcon -Rt svirt_sandbox_file_t /var/lib/ceph</span><br></pre></td></tr></table></figure>
<p>上述过程需要设置SELinux是enable的，且三个主机都需要上述步骤。</p>
<h3 id="u8FD0_u884CMON"><a href="#u8FD0_u884CMON" class="headerlink" title="运行MON"></a>运行MON</h3><p>先在ceph1上运行MON<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net=host -v /etc/ceph:/etc/ceph -v /var/lib/ceph/:/var/lib/ceph/ -e MON_IP=<span class="number">192.168</span><span class="number">.3</span><span class="number">.65</span> -e CEPH_PUBLIC_NETWORK=<span class="number">192.168</span><span class="number">.3</span><span class="number">.0</span>/<span class="number">24</span> ceph/daemon mon</span><br></pre></td></tr></table></figure></p>
<p>需要说明CEPH_PUBLIC_NETWORK是你的网卡CIDR值。一般CIDR＝IP &amp; mask。<br>这时候会出现下图的效果:<br><img src="/about/docker/ceph-docker/1.png" alt="logo"></p>
<p>接着在ceph2和ceph3上运行MON，需要将ceph1上的/etc/ceph和/var/lib/ceph目录下的东西都转移到ceph2和ceph3相应的目录中。</p>
<p>然后在ceph2运行:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net=host -v /etc/ceph:/etc/ceph -v /var/lib/ceph/:/var/lib/ceph/ -e MON_IP=<span class="number">192.168</span><span class="number">.3</span><span class="number">.66</span> -e CEPH_PUBLIC_NETWORK=<span class="number">192.168</span><span class="number">.3</span><span class="number">.0</span>/<span class="number">24</span> ceph/daemon mon</span><br></pre></td></tr></table></figure></p>
<p>在ceph3中运行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net=host -v /etc/ceph:/etc/ceph -v /var/lib/ceph/:/var/lib/ceph/ -e MON_IP=<span class="number">192.168</span><span class="number">.3</span><span class="number">.67</span> -e CEPH_PUBLIC_NETWORK=<span class="number">192.168</span><span class="number">.3</span><span class="number">.0</span>/<span class="number">24</span> ceph/daemon mon</span><br></pre></td></tr></table></figure></p>
<p>这时候会看见三个MON都启动了:<br><img src="/about/docker/ceph-docker/2.png" alt="logo">`</p>
<h3 id="u8FD0_u884COSD"><a href="#u8FD0_u884COSD" class="headerlink" title="运行OSD"></a>运行OSD</h3><p>使用mkfs将新添加的硬盘格式化制作ext4或者btrfs文件系统<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t ext4 /dev/sdb</span><br></pre></td></tr></table></figure></p>
<p>挂载OSD<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net=host -v /etc/ceph:/etc/ceph -v /var/lib/ceph:/var/lib/ceph -v /dev:/dev --privileged=true -e OSD_FORCE_ZAP=<span class="number">1</span> -e OSD_DEVICE=/dev/sdb ceph/daemon osd_ceph_disk</span><br></pre></td></tr></table></figure></p>
<p>这时就发现OSD进入了集群<br>同理在ceph2和ceph3中类似操作。</p>
<p>这样我们就完成了在容器中运行ceph，另外我们也可以利用Dockerfile自己构建相关的镜像;ceph/demo镜像提供单机版的容器化的ceph，其中包含一个MON和一个OSD，可以用来学习ceph集群的操作;<br>运行命令如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --net=host -e MON_IP=<span class="number">192.168</span><span class="number">.3</span><span class="number">.66</span> -e CEPH_NETWORK=<span class="number">192.168</span><span class="number">.3</span><span class="number">.0</span>/<span class="number">24</span> ceph/demo</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">exec</span> -t -i ContainID /bin/bash</span><br></pre></td></tr></table></figure>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.youtube.com/watch?v=FUSTjTBA8f8&amp;spfreload=10" target="_blank" rel="external">Demo:running Ceph in Docker containers</a><br><a href="http://bbs.ceph.org.cn/article/29#rd?sukey=014c68f407f2d3e12d6bb2c1d65e8cbed9e267135c4c2e973fe434235a519d84b6418f464512ff0410254dbe32d03dc8" target="_blank" rel="external">在Docker里运行Ceph集群</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>由于毕设在研究docker容器中运行的ceph，现记录下我的运行过程。</p>
<h3 id="u73AF_u5883_u8BF4_u660E"><a href="#u73AF_u5883_u8BF4_u660E" class="headerlink" title="环境说]]>
    </summary>
    
      <category term="Storage" scheme="http://yoursite.com/tags/Storage/"/>
    
      <category term="cloud computing" scheme="http://yoursite.com/tags/cloud-computing/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[过年总结]]></title>
    <link href="http://yoursite.com/year/02/15/%E8%BF%87%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/year/02/15/过年总结/</id>
    <published>2016-02-15T08:24:10.000Z</published>
    <updated>2016-02-20T09:00:17.000Z</updated>
    <content type="html"><![CDATA[<p>其实我只是想贴几张过年喜庆的照片:)<br>这是年初三深夜警察局门口放烟火，嘿嘿!<br><img src="/about/lifestyle/1.jpg" width="300" height="300" alt="logo" align="center"><br><img src="/about/lifestyle/2.jpg" width="300" height="300" alt="logo" align="center"><br><img src="/about/lifestyle/3.jpg" width="500" height="300" alt="logo" align="center"><br>接下来是年初四在KTV给小侄女拍的照片<br><img src="/about/lifestyle/4.JPG" width="500" height="300" alt="logo" align="center"><br><img src="/about/lifestyle/5.JPG" width="500" height="300" alt="logo" align="center"><br>突然想起来一个表情包😊<br><img src="/about/lifestyle/6.jpg" width="500" height="300" alt="logo" align="center"> </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>其实我只是想贴几张过年喜庆的照片:)<br>这是年初三深夜警察局门口放烟火，嘿嘿!<br><img src="/about/lifestyle/1.jpg" width="300" height="300" alt="logo" align="center"><br><im]]>
    </summary>
    
      <category term="lifestyle" scheme="http://yoursite.com/tags/lifestyle/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[大话存储2学习笔记]]></title>
    <link href="http://yoursite.com/year/02/09/%E5%A4%A7%E8%AF%9D%E5%AD%98%E5%82%A82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/year/02/09/大话存储2学习笔记/</id>
    <published>2016-02-08T23:17:17.000Z</published>
    <updated>2016-02-14T12:34:06.000Z</updated>
    <content type="html"><![CDATA[<p>今天是大年初二，睡得早醒得也早。想想最近除了拜年也不算很忙，打算看看冬瓜头写的《大话存储2》，其实我刚开始也不知道这本书，我组栋梁给我墙裂推荐这本书，并且还将他的书借给我过年回家看，承蒙我组栋梁的厚爱，所以开此博客，分章纪录自己的学习心得。以下所有内容都是自己学习总结，不一定准备表达作者的意思，仅供参考。</p>
<h3 id="u5B58_u50A8_u7CFB_u7EDF_u7684_u524D_u4E16_u4ECA_u751F"><a href="#u5B58_u50A8_u7CFB_u7EDF_u7684_u524D_u4E16_u4ECA_u751F" class="headerlink" title="存储系统的前世今生"></a>存储系统的前世今生</h3><p>这个章节主要讲了存储设备的发展: 竹筒和纸张–&gt;选数管–&gt;穿孔卡–&gt;穿孔纸带–&gt;磁带–&gt;磁鼓存储器–&gt;硬盘驱动器–&gt;软盘–&gt;光盘–&gt;Flash芯片和卡式存储–&gt;磁盘阵列–&gt;大型网络化磁盘阵列。最后作者介绍了自己理解的信息，数据，数据存储，讲了信息如何影响到人类的行为以及对比人类的行为理解计算机的行为。</p>
<h3 id="u8D70_u8FDB_u8BA1_u7B97_u673AIO_u4E16_u754C"><a href="#u8D70_u8FDB_u8BA1_u7B97_u673AIO_u4E16_u754C" class="headerlink" title="走进计算机IO世界"></a>走进计算机IO世界</h3><p>理解计算机的IO世界就应该要知道计算机系统的组成。当前计算机的组成都是冯罗伊曼结构，本质上是计算，存储，控制三大部件。CPU，内存和IO设备(IO设备需要控制器读写)通过总线连接。作者将CPU，内存和磁盘比作本地的网络，通过总线连接而不是TCP/IP协议的连接。作者也讲到了CPU和内存属于同一个冲突域(连接在北桥上)，IO设备(鼠标，键盘之类的)是另一个冲突域(连接在南桥上)，但是并没有指明当前的性能瓶颈在IO。</p>
<h3 id="u78C1_u76D8_u539F_u7406_u4E0E_u6280_u672F_u8BE6_u89E3"><a href="#u78C1_u76D8_u539F_u7406_u4E0E_u6280_u672F_u8BE6_u89E3" class="headerlink" title="磁盘原理与技术详解"></a>磁盘原理与技术详解</h3><p>首先介绍了磁盘的组件概念，诸如盘面，磁道，柱面和扇区。磁盘的工作原理是先读写柱面上的数据再寻道到下一个磁道读写。然后作者类比打字机讲解了磁盘的读写过程，寻道是径向位移由步进电机来驱动，扇区是由盘片旋转移动，磁头不动来确定的，所以影响磁盘性能的关键因素分别是盘片的转速(影响连续读写)和寻道的速度(影响随机IO)。讲完磁盘以后就需要将磁盘连接到计算机系统中，这时候需要一些接口协议标准，诸如ATA(分为SATA和PATA，PATA又名IDE)和SCSI。计算机完整的使用磁盘过程是:</p>
<blockquote>
<p>1) 系统BIOS初始化执行基本的磁盘控制器驱动程序<br>2) CPU可以产生SCSI或ATA指令CDB来控制磁盘控制器<br>3) 磁盘控制器通过SCSI接口或ATA接口访问磁盘上的磁盘驱动器的控制电路，该控制电路解析指令驱动磁头臂完成IO操作。</p>
</blockquote>
<p>作者接着讲述了IOPS(IO/s)和MBPS(MB/s)来描述磁盘的性能，其实不光是磁盘，存储设备的性能都会说明这些参数。IOPS=队列深度/IO延时，队列深度增加，IO延迟也会随即增加。而IOPS就有点类似于存储设备的IO消化能力。MBPS就是吞吐量。<br>作者还介绍了固态硬盘，主要是讲了Flash介质的，其实新型存储材料的研究还包括PCM，MRAM，RRAM，FeRAM等。Flash介质的固态硬盘相对于磁盘性能快得不只一个数量级，Flash不用寻道，但是Flash也有不完美的地方比如写前擦除，写放大之类的。相应的解决策略作者也讲了一些，感觉就是野路子不够专业，其实概括起来就是磨损均衡，垃圾回收，写前预处理，预留备用空间。</p>
<h3 id="u5927_u8BDD/_u8BE6_u89E3_u4E03_u79CDRAID"><a href="#u5927_u8BDD/_u8BE6_u89E3_u4E03_u79CDRAID" class="headerlink" title="大话/详解七种RAID"></a>大话/详解七种RAID</h3><h3 id="RAID_2C__u865A_u62DF_u78C1_u76D8_2C__u5377_u548C_u6587_u4EF6_u7CFB_u7EDF_u5B9E_u6218"><a href="#RAID_2C__u865A_u62DF_u78C1_u76D8_2C__u5377_u548C_u6587_u4EF6_u7CFB_u7EDF_u5B9E_u6218" class="headerlink" title="RAID, 虚拟磁盘, 卷和文件系统实战"></a>RAID, 虚拟磁盘, 卷和文件系统实战</h3><h3 id="u5927_u8BDD_u5B58_u50A8_u9635_u5217"><a href="#u5927_u8BDD_u5B58_u50A8_u9635_u5217" class="headerlink" title="大话存储阵列"></a>大话存储阵列</h3><h3 id="u7CFB_u7EDF_u4E0E_u7CFB_u7EDF_u4E4B_u95F4_u7684_u8BED_u8A00OSI"><a href="#u7CFB_u7EDF_u4E0E_u7CFB_u7EDF_u4E4B_u95F4_u7684_u8BED_u8A00OSI" class="headerlink" title="系统与系统之间的语言OSI"></a>系统与系统之间的语言OSI</h3><h3 id="Fibre_Channel_u534F_u8BAE_u8BE6_u89E3"><a href="#Fibre_Channel_u534F_u8BAE_u8BE6_u89E3" class="headerlink" title="Fibre Channel协议详解"></a>Fibre Channel协议详解</h3><h3 id="FC_u534F_u8BAE_u7684_u5DE8_u5927_u529B_u91CF"><a href="#FC_u534F_u8BAE_u7684_u5DE8_u5927_u529B_u91CF" class="headerlink" title="FC协议的巨大力量"></a>FC协议的巨大力量</h3><h3 id="DAS_2C_SAN_u548CNAS"><a href="#DAS_2C_SAN_u548CNAS" class="headerlink" title="DAS, SAN和NAS"></a>DAS, SAN和NAS</h3><h3 id="u5927_u8BDD_u4EE5_u592A_u7F51_u548CTCP/IP_u534F_u8BAE"><a href="#u5927_u8BDD_u4EE5_u592A_u7F51_u548CTCP/IP_u534F_u8BAE" class="headerlink" title="大话以太网和TCP/IP协议"></a>大话以太网和TCP/IP协议</h3><h3 id="u5B58_u50A8_u7F51_u7EDC_u7684_u65B0_u519BIP_SAN"><a href="#u5B58_u50A8_u7F51_u7EDC_u7684_u65B0_u519BIP_SAN" class="headerlink" title="存储网络的新军IP SAN"></a>存储网络的新军IP SAN</h3><h3 id="IP_u548CFC_u878D_u5408_u7684_u7ED3_u679C"><a href="#IP_u548CFC_u878D_u5408_u7684_u7ED3_u679C" class="headerlink" title="IP和FC融合的结果"></a>IP和FC融合的结果</h3><h3 id="u865A_u62DF_u5316"><a href="#u865A_u62DF_u5316" class="headerlink" title="虚拟化"></a>虚拟化</h3><h3 id="u5B58_u50A8_u96C6_u7FA4"><a href="#u5B58_u50A8_u96C6_u7FA4" class="headerlink" title="存储集群"></a>存储集群</h3><h3 id="u6570_u636E_u4FDD_u62A4_u548C_u5907_u4EFD_u6280_u672F"><a href="#u6570_u636E_u4FDD_u62A4_u548C_u5907_u4EFD_u6280_u672F" class="headerlink" title="数据保护和备份技术"></a>数据保护和备份技术</h3><h3 id="u5927_u8BDD_u6570_u636E_u5BB9_u707E"><a href="#u5927_u8BDD_u6570_u636E_u5BB9_u707E" class="headerlink" title="大话数据容灾"></a>大话数据容灾</h3><h3 id="u6570_u636E_u524D_u5904_u7406_u4E0E_u540E_u5904_u7406"><a href="#u6570_u636E_u524D_u5904_u7406_u4E0E_u540E_u5904_u7406" class="headerlink" title="数据前处理与后处理"></a>数据前处理与后处理</h3><h3 id="u7CFB_u7EDFIO_u8DEF_u5F84_u53CA_u4F18_u5316"><a href="#u7CFB_u7EDFIO_u8DEF_u5F84_u53CA_u4F18_u5316" class="headerlink" title="系统IO路径及优化"></a>系统IO路径及优化</h3><h3 id="u5927_u8BDD_u4E91_u5B58_u50A8"><a href="#u5927_u8BDD_u4E91_u5B58_u50A8" class="headerlink" title="大话云存储"></a>大话云存储</h3>]]></content>
    <summary type="html">
    <![CDATA[<p>今天是大年初二，睡得早醒得也早。想想最近除了拜年也不算很忙，打算看看冬瓜头写的《大话存储2》，其实我刚开始也不知道这本书，我组栋梁给我墙裂推荐这本书，并且还将他的书借给我过年回家看，承蒙我组栋梁的厚爱，所以开此博客，分章纪录自己的学习心得。以下所有内容都是自己学习总结，不一]]>
    </summary>
    
      <category term="Storage" scheme="http://yoursite.com/tags/Storage/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker 实践总结]]></title>
    <link href="http://yoursite.com/year/02/06/docker-%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/year/02/06/docker-自己的实践总结/</id>
    <published>2016-02-06T12:45:33.000Z</published>
    <updated>2016-03-05T12:38:13.000Z</updated>
    <content type="html"><![CDATA[<p>这两天终于把《docker 从入门到实践》看完了，原本打算写写总结，但是感觉书中的内容太过死板，还不如从自己使用docker的过程中总结出一些好玩的docker应用方法分享给大家，欢迎有更多的人分享自己使用docker时一些好玩的项目，私信我给友情链接。</p>
<h3 id="u5236_u4F5C_u548C_u4F7F_u7528Vim_u63D2_u4EF6_u7684_u955C_u50CF"><a href="#u5236_u4F5C_u548C_u4F7F_u7528Vim_u63D2_u4EF6_u7684_u955C_u50CF" class="headerlink" title="制作和使用Vim插件的镜像"></a>制作和使用Vim插件的镜像</h3><p>如果你用关键词Vim搜索我的博客会发现有篇博客专门介绍如何使用Vim的插件来配置类似于VS的集成开发环境。现在我使用docker制作Vim插件的镜像来实现在多机上快速建立这样的VS集成开发环境。</p>
<h4 id="u5229_u7528Dockerfile_u5236_u4F5C_u955C_u50CF"><a href="#u5229_u7528Dockerfile_u5236_u4F5C_u955C_u50CF" class="headerlink" title="利用Dockerfile制作镜像"></a><font size="2"> 利用Dockerfile制作镜像 </font></h4><p>将需要打包的插件放在某个目录下:<br><img src="/about/docker/practice/1.png" alt="logo"><br>当前目录下编辑Dockerfile，将插件打包到基于ubuntu镜像创建的镜像中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:<span class="number">14.04</span></span><br><span class="line">MAINTAINER Kang Yan &lt;wowyk@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ADD . /tool</span><br></pre></td></tr></table></figure></p>
<p>制作镜像，命令如下(happymain是我在daocloud上注册的用户名，主要的原因是国内有时候无法访问docker hub，所以就使用daocloud):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t daocloud.io/happymain/tool .</span><br></pre></td></tr></table></figure></p>
<h4 id="push_u955C_u50CF_u5230daocloud"><a href="#push_u955C_u50CF_u5230daocloud" class="headerlink" title="push镜像到daocloud"></a><font size="2"> push镜像到daocloud </font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push daocloud.io/happymain/tool</span><br></pre></td></tr></table></figure>
<h4 id="u5728_u90E8_u7F72_u673A_u4E0Apull_u955C_u50CF"><a href="#u5728_u90E8_u7F72_u673A_u4E0Apull_u955C_u50CF" class="headerlink" title="在部署机上pull镜像"></a><font size="2"> 在部署机上pull镜像 </font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull daocloud.io/happymain/tool</span><br></pre></td></tr></table></figure>
<p>在一个会话中运行容器:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i daocloud.io/happymain/tool</span><br></pre></td></tr></table></figure></p>
<p>在另一个会话中导出到test.tar:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps(得到containerID)</span><br><span class="line">docker export containerID &gt; test.tar</span><br></pre></td></tr></table></figure></p>
<p>这个test.tar就是整个文件系统的所有文件，找个目录将其解压，其中的tool目录就是Vim的插件。</p>
<h4 id="u5728_u90E8_u7F72_u673A_u4E0A_u7B80_u5355_u64CD_u4F5C_u5B8C_u6210_u5B89_u88C5"><a href="#u5728_u90E8_u7F72_u673A_u4E0A_u7B80_u5355_u64CD_u4F5C_u5B8C_u6210_u5B89_u88C5" class="headerlink" title="在部署机上简单操作完成安装"></a><font size="2"> 在部署机上简单操作完成安装 </font></h4><p>1) ctags需要单独编译安装<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar xvf ctags-<span class="number">5.8</span>.tar</span><br><span class="line">cd ctags-<span class="number">5.8</span></span><br><span class="line">./configure</span><br><span class="line">make &amp; make install</span><br></pre></td></tr></table></figure></p>
<p>2) 需要将插件移到~/.vim目录下，将hello中的配置拷贝到~/.vimrc<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv * ~/.vim</span><br><span class="line">cd ~/.vim</span><br><span class="line">cp hello ~/.vimrc</span><br></pre></td></tr></table></figure></p>
<p>这样就实现了VS集成开发环境的移植，其实Github也可以做类似的工作;)</p>
<h3 id="u5F00_u53D1_u4E0E_u8FD0_u7EF4_u7684_u9694_u79BB"><a href="#u5F00_u53D1_u4E0E_u8FD0_u7EF4_u7684_u9694_u79BB" class="headerlink" title="开发与运维的隔离"></a>开发与运维的隔离</h3><p>比如说我在主机上编写代码，容器中同步更新并且可以直接运行:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i -v $(pwd):/test ubuntu:<span class="number">14.04</span></span><br></pre></td></tr></table></figure></p>
<p>结果如下:<br><img src="/about/docker/practice/2.png" alt="logo"><br>我们可以看出主机的docker目录下的文件被映射到容器中的test目录下，你可以尝试编辑主机上的test.c文件，然后观察容器中的test.c完全同步更新。所以我们甚至可以想象如果只映射test可执行文件就相当于只在容器中运维，这样的话就可以实现开发和运维的隔离。再往大的讲，我可以映射上述那样的目录后，开启多个容器共享该目录，从而实现多个用户同时编辑，运维。如下所示:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -v $(pwd):/test --name test training/postgres echo hello!		 </span><br><span class="line">docker run -d --volumes-<span class="keyword">from</span> test --name test1 training/postgres</span><br><span class="line">docker run -d --volumes-<span class="keyword">from</span> test --name test2 training/postgres</span><br></pre></td></tr></table></figure></p>
<p> 在主机中编辑test.c文件并且编译以后，test1，test2容器都会同步更新并且直接可以运行，也就是说如果我只暴露test可执行文件给test1,test2，那么就可以实现开发与测试运维的隔离。 </p>
<h3 id="mysql_u5BB9_u5668_u4E0Ewordpress_u5BB9_u5668_u7684_u8FDE_u63A5"><a href="#mysql_u5BB9_u5668_u4E0Ewordpress_u5BB9_u5668_u7684_u8FDE_u63A5" class="headerlink" title="mysql容器与wordpress容器的连接"></a>mysql容器与wordpress容器的连接</h3><p>拉取mysql和wordpress镜像(使用daocloud加速器来拉取):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dao pull mysql</span><br><span class="line">dao pull wordpress</span><br></pre></td></tr></table></figure></p>
<p>运行mysql容器:</p>
<pre><code class="python">docker run -d --name mysql -e MYSQL_ROOT_PASSWORD=<span class="number">123456</span> mysql
</code></pre>
<p>连接mysql容器，运行wordpress容器:</p>
<pre><code class="python">docker run -d --name wordpress --link mysql:mysql -p <span class="number">8888</span>:<span class="number">80</span> wordpress
</code></pre>
<p>这样以后在浏览器中输入0.0.0.0:8888就可以使用wordpress，剩下的你就可以自己玩博客了。当然还有很多好玩的东西没有列举出来，欢迎大家继续分享！</p>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="http://dockerpool.com/static/books/docker_practice/index.html" target="_blank" rel="external">docker 从入门到实践</a>    </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这两天终于把《docker 从入门到实践》看完了，原本打算写写总结，但是感觉书中的内容太过死板，还不如从自己使用docker的过程中总结出一些好玩的docker应用方法分享给大家，欢迎有更多的人分享自己使用docker时一些好玩的项目，私信我给友情链接。</p>
<h3 i]]>
    </summary>
    
      <category term="Vim" scheme="http://yoursite.com/tags/Vim/"/>
    
      <category term="cloud computing" scheme="http://yoursite.com/tags/cloud-computing/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker 背后的技术]]></title>
    <link href="http://yoursite.com/year/01/23/docker%E8%83%8C%E5%90%8E%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/year/01/23/docker背后的技术/</id>
    <published>2016-01-23T15:33:41.000Z</published>
    <updated>2016-03-05T12:38:31.000Z</updated>
    <content type="html"><![CDATA[<p>最近一直都在学习使用docker，当你使用docker越久你就越发的想了解docker背后是如何实现的。其实docker的一些功能之前就已经在Linux内核中实现了，只是有些没有进入内核主线中，但是技术就是这样不会凭空产生，总是靠大量的积累，由量变到质变最后在某个时刻绽放。本文主要是介绍docker背后的内核技术namespace，cgroup，aufs。</p>
<h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a><strong>namespace</strong></h2><p>Linux namespace主要的功能就是提供内核级别的环境隔离，这有点类似于Unix中的chroot系统调用，通过修改根目录将用户jail在一个特定的目录下，这样的jail就无法访问外部的内容，而且每一个jail的pid都是1，1意味着是当前环境下的所有进程的根节点，从而实现了环境隔离。<br>Linux namespace提供如下名字空间：(官方的文档<a href="http://lwn.net/Articles/531114/" target="_blank" rel="external">namespaces in operation</a>)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|       分类        |  系统调用参数   |     内核版本     </span><br><span class="line">| UTS namespace     |  CLONE_NEWUTS   |   Linux <span class="number">2.6</span><span class="number">.19</span></span><br><span class="line">| IPC namespace     |  CLONE_NEWIPC   |   Linux <span class="number">2.6</span><span class="number">.19</span></span><br><span class="line">| PID namespace     |  CLONE_NEWPID   |   Linux <span class="number">2.6</span><span class="number">.24</span></span><br><span class="line">| Mount namespace   |  CLONE_NEWNS    |   Linux <span class="number">2.4</span><span class="number">.19</span>    </span><br><span class="line">| USER namespace    |  CLONE_NEWUSER  |started <span class="keyword">in</span> Linux <span class="number">2.6</span><span class="number">.23</span> <span class="keyword">and</span> completed <span class="keyword">in</span> Linux <span class="number">3.8</span></span><br><span class="line">| Network namespace |  CLONE_NEWNET   |started <span class="keyword">in</span> Linux <span class="number">2.6</span><span class="number">.24</span> <span class="keyword">and</span> largely completed by about Linux <span class="number">2.6</span><span class="number">.29</span></span><br></pre></td></tr></table></figure></p>
<p>接下来介绍上述namespace的用法，可以体会一下环境隔离。(我的运行环境是ubuntu14.04，内核版本是4.3.3)<br>与namespace相关的API主要是以下三个:<br>clone():创建一个新进程，具体里面的参数自己man一下<br>unshare():使某个进程脱离某个namespace<br>setns():把某个进程加入到某个namespace          </p>
<h3 id="UTS_namespace"><a href="#UTS_namespace" class="headerlink" title="UTS namespace"></a><font size="2"> UTS namespace </font></h3><p>UTS namespace主要实现环境隔离中的hostname隔离(<a href="http://stackoverflow.com/questions/5582211/what-does-define-gnu-source-imply" target="_blank" rel="external">测试代码加_GNU_SOURCE理由</a>)<br>测试代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _GNU_SOURCE</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sched.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"> </span><br><span class="line">/* 定义一个给 clone 用的栈，栈大小<span class="number">1</span>M */</span><br><span class="line"><span class="comment">#define STACK_SIZE (1024 * 1024)</span></span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"> </span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Container - inside the container!\n"</span>);</span><br><span class="line">    /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span><br><span class="line">    sethostname(<span class="string">"container"</span>,<span class="number">10</span>);	 </span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args); </span><br><span class="line">    printf(<span class="string">"Something's wrong!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Parent - start a container!\n"</span>);</span><br><span class="line">    /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span><br><span class="line">    int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | SIGCHLD, NULL);</span><br><span class="line">    /* 等待子进程结束 */</span><br><span class="line">    waitpid(container_pid, NULL, <span class="number">0</span>);</span><br><span class="line">    printf(<span class="string">"Parent - container stopped!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试结果如下:<br><img src="/about/docker/namespace/1.png" alt="logo"><br>从上面的结果可以看出clone创建的进程hostname是container，和主机的ubuntu不同，从而实现了hostname的隔离。</p>
<h3 id="IPC_namespace"><a href="#IPC_namespace" class="headerlink" title="IPC namespace"></a><font size="2"> IPC namespace </font></h3><p>IPC全称是Inter-Process Communication，也就是<a href="http://songlee24.github.io/2015/04/21/linux-IPC/" target="_blank" rel="external">进程间通信</a>。IPC包括<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">| 进程间通信方式 |                             主要用途                                 </span><br><span class="line">|  无名管道      |半双工，只能用于父子进程或兄弟进程之间通信                            </span><br><span class="line">|  命名管道(FIFO)|半双工，可以用于无关进程间通信                                        </span><br><span class="line">|  消息队列      |消息队列不一定要以先进先出的次序读取,也可以按消息的类型读取          </span><br><span class="line">|  共享内存      |多个进程访问同一块内存空间，信号量结合使用，来达到进程间的同步及互斥 </span><br><span class="line">|  信号量        |作为进程间以及同一进程不同线程之间的同步手段                         </span><br><span class="line">|  套接字        |可用于不同机器之间的进程间通信</span><br></pre></td></tr></table></figure></p>
<p>IPC namespace实现的是限制进程间通信只能发生在同一个namespace。要启动IPC隔离，只需要在调用clone时加上CLONE_NEWIPC:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWIPC  | SIGCHLD, NULL);</span><br></pre></td></tr></table></figure></p>
<p>完整代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _GNU_SOURCE</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sched.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"> </span><br><span class="line">/* 定义一个给 clone 用的栈，栈大小<span class="number">1</span>M */</span><br><span class="line"><span class="comment">#define STACK_SIZE (1024 * 1024)</span></span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"> </span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Container - inside the container!\n"</span>);</span><br><span class="line">    /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span><br><span class="line">    sethostname(<span class="string">"contain"</span>,<span class="number">10</span>);	 </span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args); </span><br><span class="line">    printf(<span class="string">"Something's wrong!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Parent - start a container!\n"</span>);</span><br><span class="line">    /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span><br><span class="line">    int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWIPC  | SIGCHLD, NULL);</span><br><span class="line">    /* 等待子进程结束 */</span><br><span class="line">    waitpid(container_pid, NULL, <span class="number">0</span>);</span><br><span class="line">    printf(<span class="string">"Parent - container stopped!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试如下：<br>无CLONE_NEWIPC时:<br><img src="/about/docker/namespace/2.png" alt="logo"><br>有CLONE_NEWIPC时:<br><img src="/about/docker/namespace/3.png" alt="logo"><br>从上面的结果可以看出，IPC被隔离了，在新创建的进程中无法看到消息队列。</p>
<h3 id="PID_namespace"><a href="#PID_namespace" class="headerlink" title="PID namespace"></a><font size="2"> PID namespace </font></h3><p>PID namespace实现的是隔离进程空间，使得新建的进程的PID是1，在传统的UNIX系统中，PID为1的进程是init，地位非常特殊。他作为所有进程的父进程，有很多特权(比如:屏蔽信号等)，另外，其还会为检查所有进程的状态，我们知道，如果某个子进程脱离了父进程(父进程没有wait它)，那么init就会负责回收资源并结束这个子进程。所以，要做到进程空间的隔离，首先要创建出PID为1的进程，最好就像chroot那样，把子进程的PID在容器内变成1。<br>现在我们在clone子进程中添加PID隔离:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD, NULL);</span><br></pre></td></tr></table></figure></p>
<p>完整代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _GNU_SOURCE</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sched.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"> </span><br><span class="line">/* 定义一个给 clone 用的栈，栈大小<span class="number">1</span>M */</span><br><span class="line"><span class="comment">#define STACK_SIZE (1024 * 1024)</span></span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"> </span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Container [%5d] - inside the container!\n"</span>,getpid());</span><br><span class="line">    /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span><br><span class="line">    sethostname(<span class="string">"container"</span>,<span class="number">10</span>);	 </span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args); </span><br><span class="line">    printf(<span class="string">"Something's wrong!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Parent [%5d] - start a container!\n"</span>,getpid());</span><br><span class="line">    /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span><br><span class="line">    int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD, NULL);</span><br><span class="line">    /* 等待子进程结束 */</span><br><span class="line">    waitpid(container_pid, NULL, <span class="number">0</span>);</span><br><span class="line">    printf(<span class="string">"Parent - container stopped!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试结果如下:<br><img src="/about/docker/namespace/4.png" alt="logo"><br>我们可以看到container的PID是1，但是有个问题，当你在子进程中输入top的时候还是会看到很多其他进程，而这些其他进程是只有父进程才看得到的，也就是说并没有完全隔离进程啊，这是因为ps, top这些命令会去读/proc文件系统，而文件系统对于父进程和子进程来说是一样的，所以还需要隔离文件系统。</p>
<h3 id="Mount_namespace"><a href="#Mount_namespace" class="headerlink" title="Mount namespace"></a><font size="2"> Mount namespace </font></h3><p>Mount namespace实现的是隔离挂载点，顾名思义，也就是说启动Mount namespace后不同进程挂载的文件系统是相互看不到的。所以测试代码中添加了CLONE_NEWNS，并且在子进程中加入了”mount -t proc proc /proc”来挂载/proc文件系统。<br>完整代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _GNU_SOURCE</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sched.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"> </span><br><span class="line">/* 定义一个给 clone 用的栈，栈大小<span class="number">1</span>M */</span><br><span class="line"><span class="comment">#define STACK_SIZE (1024 * 1024)</span></span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"> </span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Container [%5d] - inside the container!\n"</span>,getpid());</span><br><span class="line">    /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */</span><br><span class="line">    sethostname(<span class="string">"container"</span>,<span class="number">10</span>);	 </span><br><span class="line">    system(<span class="string">"mount -t proc proc /proc"</span>);</span><br><span class="line">    execv(container_args[<span class="number">0</span>], container_args); </span><br><span class="line">    printf(<span class="string">"Something's wrong!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Parent [%5d] - start a container!\n"</span>,getpid());</span><br><span class="line">    /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */</span><br><span class="line">    int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD, NULL);</span><br><span class="line">    /* 等待子进程结束 */</span><br><span class="line">    waitpid(container_pid, NULL, <span class="number">0</span>);</span><br><span class="line">    printf(<span class="string">"Parent - container stopped!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试结果如下:<br><img src="/about/docker/namespace/5.png" alt="logo"><br>从上图可以看出子进程的所有进程，PID为1的正好是新建的bash，另一个进程就是PS命令，这样mount的文件系统就看不到父进程空间中的进程，再比如输入top命令，也会发现进程很干净，结果如下:<br><img src="/about/docker/namespace/6.png" alt="logo"></p>
<h3 id="USER_namespace"><a href="#USER_namespace" class="headerlink" title="USER namespace"></a><font size="2"> USER namespace </font></h3><p>User namespace主要是提供了用户与用户组的隔离。使用CLONE_NEWUSER这个参数，容器内部看到的UID和GID已经与外部不同了，默认显示为65534。因为容器中找不到其真正的UID，所以设置了最大的UID，可通过如下命令查看:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/overflowuid</span><br></pre></td></tr></table></figure></p>
<p>要把容器中的uid和真实系统的uid给映射在一起，需要修改/proc/pid/uid_map和/proc/pid/gid_map这两个文件。这两个文件的格式是:<br>ID-inside-ns    ID-outside-ns    length</p>
<blockquote>
<p>ID-inside-ns表示容器里面显示的UID或GID。<br>ID-outside-ns表示容器外映射的真实UID或GID。<br>length表示映射范围，为1表示一一对应。</p>
</blockquote>
<p>除了上述的格式要求，对于uid/gid的映射还有几点约束:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*)写入uid_map/gid_map的进程，必须对PID进程所属user namespace拥有[CAP_SETUID/CAP_SETGID](http://man7.org/linux/man-pages/man7/capabilities<span class="number">.7</span>.html)权限</span><br><span class="line">*)写入uid_map/gid_map的进程，必须位于PID进程的parent或者child USER namespace</span><br><span class="line">*)另外需要满足如下条件之一:</span><br><span class="line">	<span class="number">1</span>)父进程将有效uid/gid映射到子进程的user namespace中</span><br><span class="line">	<span class="number">2</span>)父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid</span><br></pre></td></tr></table></figure></p>
<p>你可以通过如下命令查看(pid表示进程编号):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/&lt;pid&gt;/uid_map</span><br></pre></td></tr></table></figure></p>
<p>比如下面的例子表示把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形<br><img src="/about/docker/namespace/7.png" alt="logo"><br>现在我们来测试如下代码，如有不懂可以和我联系:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/mount.h&gt;</span><br><span class="line">#include &lt;sys/capability.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">#define STACK_SIZE (1024 * 1024)</span><br><span class="line"> </span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    "/bin/bash",</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int pipefd[2];</span><br><span class="line"> </span><br><span class="line">void set_map(char* file, int inside_id, int outside_id, int len) &#123;</span><br><span class="line">    FILE* mapfd = fopen(file, "w");</span><br><span class="line">    if (NULL == mapfd) &#123;</span><br><span class="line">        perror("open file error");</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    fprintf(mapfd, "%d %d %d", inside_id, outside_id, len);</span><br><span class="line">    fclose(mapfd);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void set_uid_map(pid_t pid, int inside_id, int outside_id, int len) &#123;</span><br><span class="line">    char file[256];</span><br><span class="line">    sprintf(file, "/proc/%d/uid_map", pid);</span><br><span class="line">    set_map(file, inside_id, outside_id, len);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void set_gid_map(pid_t pid, int inside_id, int outside_id, int len) &#123;</span><br><span class="line">    char file[256];</span><br><span class="line">    sprintf(file, "/proc/%d/gid_map", pid);</span><br><span class="line">    set_map(file, inside_id, outside_id, len);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    printf("Container [%5d] - inside the container!\n", getpid());</span><br><span class="line"> </span><br><span class="line">    printf("Container: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n",</span><br><span class="line">            (long) geteuid(), (long) getegid(), (long) getuid(), (long) getgid());</span><br><span class="line"> </span><br><span class="line">    /* 等待父进程通知后再往下执行（进程间的同步） */</span><br><span class="line">    char ch;</span><br><span class="line">    close(pipefd[1]);</span><br><span class="line">    read(pipefd[0], &amp;ch, 1);</span><br><span class="line"> </span><br><span class="line">    printf("Container [%5d] - setup hostname!\n", getpid());</span><br><span class="line">    //set hostname</span><br><span class="line">    sethostname("container",10);</span><br><span class="line"> </span><br><span class="line">    //remount "/proc" to make sure the "top" and "ps" show container's information</span><br><span class="line">    mount("proc", "/proc", "proc", 0, NULL);</span><br><span class="line"> </span><br><span class="line">    execv(container_args[0], container_args);</span><br><span class="line">    printf("Something's wrong!\n");</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int gid=getgid(), uid=getuid();</span><br><span class="line"> </span><br><span class="line">    printf("Parent: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\n",</span><br><span class="line">            (long) geteuid(), (long) getegid(), (long) getuid(), (long) getgid());</span><br><span class="line"> </span><br><span class="line">    pipe(pipefd);</span><br><span class="line">  </span><br><span class="line">    printf("Parent [%5d] - start a container!\n", getpid());</span><br><span class="line"> </span><br><span class="line">    int container_pid = clone(container_main, container_stack+STACK_SIZE, </span><br><span class="line">            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | SIGCHLD, NULL);</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    printf("Parent [%5d] - Container [%5d]!\n", getpid(), container_pid);</span><br><span class="line"> </span><br><span class="line">    //To map the uid/gid, </span><br><span class="line">    //   we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent</span><br><span class="line">    //The file format is</span><br><span class="line">    //   ID-inside-ns   ID-outside-ns   length</span><br><span class="line">    //if no mapping, </span><br><span class="line">    //   the uid will be taken from /proc/sys/kernel/overflowuid</span><br><span class="line">    //   the gid will be taken from /proc/sys/kernel/overflowgid</span><br><span class="line">    set_uid_map(container_pid, 0, uid, 1);</span><br><span class="line">    set_gid_map(container_pid, 0, gid, 1);</span><br><span class="line"> </span><br><span class="line">    printf("Parent [%5d] - user/group mapping done!\n", getpid());</span><br><span class="line"> </span><br><span class="line">    /* 通知子进程 */</span><br><span class="line">    close(pipefd[1]);</span><br><span class="line"> </span><br><span class="line">    waitpid(container_pid, NULL, 0);</span><br><span class="line">    printf("Parent - container stopped!\n");</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序运行结果如下:<br><img src="/about/docker/namespace/8.png" alt="logo"><br>我们使用一个pipe来对父子进程进行同步，因为子进程中使用execv的系统调用，这个系统调用会把当前子进程的进程空间给全部覆盖掉，我们希望在execv之前就做好user namespace的uid/gid的映射，基于上述uid/gid的映射规则，我们需要父进程映射uid/gid，然后通知子进程可以执行execv。从而我们可以看到uid=0，就是说在容器中已经是root用户了，但是gid还不是0，是因为进程同步还没有完成，当你进入container的root用户时输入id就会发现如下的结果:<br><img src="/about/docker/namespace/9.png" alt="logo"><br>如果你的gid还不是0的话，有可能是内核版本问题，因为user namespace是在3.8以后才实现绝大部分的功能也就是说还会存在问题，比如安全性问题等。你可以想到的是我们运行程序的权限是普通用户，但是运行出来的容器是root，这样的安全性就可以得到提高，因为本质上还是普通用户，如果你想运行多个namespace可以在容器里使用root权限再创建多个namespace。</p>
<h3 id="Network_namespace"><a href="#Network_namespace" class="headerlink" title="Network namespace"></a><font size="2"> Network namespace </font></h3><p>首先我想用一张图介绍Docker网络部分是如何连接的:<br><img src="/about/docker/namespace/10.png" width="500" height="200" alt="logo" align="center"><br>如上图所示docker0是一个虚拟网桥，可以看成是一个软件交换机。当你安装完docker后可以使用ifconfig查看docker0分配的IP，所有的容器都可以通过docker0进行通信，当然docker0上接着的容器IP和docker0的IP处于同一网段。当创建一个Docker容器的时候，同时会创建了一对veth pair接口(当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包)。这对接口一端在容器内，即eth0;另一端在本地并被挂载到docker0网桥，名称以veth开头(例如vethAQI2QT)。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker就创建了在主机和所有容器之间一个虚拟共享网络。<br>那么上述的Network命名空间如何实现的呢?<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先我们先增加一个虚拟网桥lxcbr0, 类似于docker0</span></span><br><span class="line">brctl addbr lxcbr0</span><br><span class="line">brctl stp lxcbr0 off</span><br><span class="line">ifconfig lxcbr0 <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span>/<span class="number">24</span> up <span class="comment">#为网桥设置IP地址</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 增加一个namesapce命令为ns1(使用ip netns add命令）</span></span><br><span class="line">ip netns add ns1 </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 激活namespace中的loopback，即127.0.0.1(使用ip netns exec ns1来操作ns1中的命令)</span></span><br><span class="line">ip netns <span class="keyword">exec</span> ns1 ip link set dev lo up </span><br><span class="line"> </span><br><span class="line"><span class="comment">## 然后，我们需要增加一对虚拟网卡</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中</span></span><br><span class="line">ip link add veth-ns1 type veth peer name lxcbr0<span class="number">.1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 把veth-ns1按到namespace ns1中，这样容器中就会有一个新的网卡了</span></span><br><span class="line">ip link set veth-ns1 netns ns1</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 把容器里的veth-ns1改名为eth0（容器外会冲突，容器内就不会了）</span></span><br><span class="line">ip netns <span class="keyword">exec</span> ns1 ip link set dev veth-ns1 name eth0 </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 为容器中的网卡分配一个IP地址，并激活它</span></span><br><span class="line">ip netns <span class="keyword">exec</span> ns1 ifconfig eth0 <span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span>/<span class="number">24</span> up</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上</span></span><br><span class="line">brctl addif lxcbr0 lxcbr0<span class="number">.1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 为容器增加一个路由规则，让容器可以访问外面的网络</span></span><br><span class="line">ip netns <span class="keyword">exec</span> ns1     ip route add default via <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在/etc/netns下创建network namespce名称为ns1的目录，</span></span><br><span class="line"><span class="comment"># 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了</span></span><br><span class="line">mkdir -p /etc/netns/ns1</span><br><span class="line">echo <span class="string">"nameserver 8.8.8.8"</span> &gt; /etc/netns/ns1/resolv.conf</span><br></pre></td></tr></table></figure></p>
<p>上面基本上就是docker网络的原理了，只不过，<br>Docker的resolv.conf没有用这样的方式，而是用了之前介绍的Mount Namesapce的那种方式<br>另外，docker是用进程的PID来做Network Namespace的名称的。<br>理解了上述过程后你可以给运行的docker容器增加一个新的网卡:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ip link add peerA type veth peer name peerB </span><br><span class="line">brctl addif docker0 peerA </span><br><span class="line">ip link set peerA up </span><br><span class="line">ip link set peerB netns $&#123;container-pid&#125; </span><br><span class="line">ip netns <span class="keyword">exec</span> $&#123;container-pid&#125; ip link set dev peerB name eth1 </span><br><span class="line">ip netns <span class="keyword">exec</span> $&#123;container-pid&#125; ip link set eth1 up</span><br><span class="line">ip netns <span class="keyword">exec</span> $&#123;container-pid&#125; ip addr add $&#123;ROUTEABLE_IP&#125; dev eth1</span><br></pre></td></tr></table></figure></p>
<p>你也可以实现点对点的连接:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开两个sessions, 分别运行如下命令会得到两个容器ID, 比如我得到的是481和3b8</span></span><br><span class="line">docker run -i -t --rm --net=none ubuntu:<span class="number">14.04</span> /bin/bash</span><br><span class="line">docker run -i -t --rm --net=none ubuntu:<span class="number">14.04</span> /bin/bash</span><br><span class="line"><span class="comment"># 找到这两个运行容器的进程编号9166和9206</span></span><br><span class="line">docker inspect -f <span class="string">'&#123;&#123;.State.Pid&#125;&#125;'</span> <span class="number">481</span></span><br><span class="line">docker inspect -f <span class="string">'&#123;&#123;.State.Pid&#125;&#125;'</span> <span class="number">3</span>b8</span><br><span class="line"><span class="comment"># 创建网络名字空间的跟踪文件</span></span><br><span class="line">mkdir -p /var/run/netns</span><br><span class="line">ln -s /proc/<span class="number">9166</span>/ns/net /var/run/netns/<span class="number">9166</span></span><br><span class="line">ln -s /proc/<span class="number">9206</span>/ns/net /var/run/netns/<span class="number">9206</span></span><br><span class="line"><span class="comment"># 创建一对peer接口，然后配置路由</span></span><br><span class="line">ip link add A type veth peer name B</span><br><span class="line"></span><br><span class="line">ip link set A netns <span class="number">9166</span></span><br><span class="line">ip netns <span class="keyword">exec</span> <span class="number">9166</span> ip addr add <span class="number">10.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span> dev A</span><br><span class="line">ip netns <span class="keyword">exec</span> <span class="number">9166</span> ip link set A up</span><br><span class="line">ip netns <span class="keyword">exec</span> <span class="number">9166</span> ip route add <span class="number">10.1</span><span class="number">.1</span><span class="number">.2</span>/<span class="number">32</span> dev A</span><br><span class="line"></span><br><span class="line">ip link set B netns <span class="number">9206</span></span><br><span class="line">ip netns <span class="keyword">exec</span> <span class="number">9206</span> ip addr add <span class="number">10.1</span><span class="number">.1</span><span class="number">.2</span>/<span class="number">32</span> dev B</span><br><span class="line">ip netns <span class="keyword">exec</span> <span class="number">9206</span> ip link set B up</span><br><span class="line">ip netns <span class="keyword">exec</span> <span class="number">9206</span> ip route add <span class="number">10.1</span><span class="number">.1</span><span class="number">.1</span>/<span class="number">32</span> dev B</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在这2个容器就可以相互ping通(在A中ping 10.1.1.2, B中ping 10.1.1.1)，并成功建立连接。点到点链路不需要子网和子网掩码。</span></span><br></pre></td></tr></table></figure></p>
<p>至此我们介绍了docker的网络命名空间，docker容器与docker0网桥连接原理，docker容器之间点对点连接的实现。</p>
<h2 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a><strong>cgroup</strong></h2><p>Linux cgroup全称是linux control group，是Linux内核的一个功能，主要用来限制，控制与分离一个进程组群的资源(包括CPU计算资源,内存,磁盘IO)。<br>cgroup主要提供了如下功能：</p>
<blockquote>
<p>Resource limitation: 限制资源使用，比如内存使用上限以及文件系统的缓存限制。<br>Prioritization: 优先级控制，比如：CPU利用和磁盘IO吞吐。<br>Accounting: 一些审计或一些统计，主要目的是为了计费。<br>Control: 挂起进程，恢复执行进程。</p>
</blockquote>
<p>本质上来说，cgroup是内核附加在程序上的一系列钩子(hooks)，通过程序运行时对资源的调度触发相应的钩子以达到资源追踪和限制的目的。<br>接下来我们通过三个小实验来感受一下如何限制CPU资源，memory资源，磁盘IO资源。其实Linux已经把cgroup做成一个file system，可以直接mount。</p>
<h3 id="u9650_u5236CPU"><a href="#u9650_u5236CPU" class="headerlink" title="限制CPU"></a><font size="2"> 限制CPU </font></h3><p>首先我们挂载cgroup子系统。然后查看/sys/fs/cgroup/<br><img src="/about/docker/cgroup/1.png" alt="logo"><br>你也可以用lssubsys命令查看cgroup能够限制哪些资源，初次使用会让你下载cgroup-bin，cgroup-bin会装上cgroup的所有子系统，如下图，我这里的测试主要是cpu，memory，blkio。<br><img src="/about/docker/cgroup/2.png" alt="logo"><br>正式进入限制CPU的测试:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /sys/fs/cgroup/cpu</span><br><span class="line">mkdir test</span><br><span class="line"><span class="comment"># 然后你会发现test目录下会生长出许多文件，表示的是限制CPU使用,限制进程数等</span></span><br></pre></td></tr></table></figure></p>
<p>现在我们运行一个main.c程序如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们会发现该程序极其损耗CPU资源，几乎达到100%:<br><img src="/about/docker/cgroup/3.png" alt="logo"><br>我们将之前建立的test组做一些限制，然后发现该进程的PID是4008，将该PID加入到test组中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">20000</span> &gt; /sys/fs/cgroup/cpu/test/cpu.cfs_quota_us</span><br><span class="line">echo <span class="number">4008</span> &gt; /sys/fs/cgroup/cpu/test/tasks</span><br></pre></td></tr></table></figure></p>
<p>我们会发现CPU的利用率瞬间降到20%(与我们之前设置test组的20000有关):<br><img src="/about/docker/cgroup/4.png" alt="logo"><br>于是就这样我们对CPU资源进行了限制的测试，当然也可以写多线程来对每个线程使用的CPU资源进行限制，类似上述的方法可以自己试试。</p>
<h3 id="u9650_u5236memory"><a href="#u9650_u5236memory" class="headerlink" title="限制memory"></a><font size="2"> 限制memory </font></h3><p>同理我们在memory目录中建一个test组:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /sys/fs/cgroup/memory/</span><br><span class="line">mkdir test</span><br></pre></td></tr></table></figure></p>
<p>现在我们运行一个程序不停的分配内存:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int size = <span class="number">0</span>;</span><br><span class="line">    int chunk_size = <span class="number">512</span>;</span><br><span class="line">    char *p = NULL;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ((p = (char *)malloc(sizeof(char)*chunk_size)) == NULL) &#123;</span><br><span class="line">            printf(<span class="string">"out of memory!!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        memset(p, <span class="number">1</span>, chunk_size);</span><br><span class="line">        size += chunk_size;</span><br><span class="line">        printf(<span class="string">"[%d] - memory is allocated [%8d] bytes \n"</span>, getpid(), size);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行上述程序:<br><img src="/about/docker/cgroup/6.png" alt="logo"><br>我们将之前建立的test组做一些限制，然后发现该进程的PID是3133，将该PID加入到test组中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">10</span>k &gt; /sys/fs/cgroup/memory/test/memory.limit_in_bytes</span><br><span class="line">echo <span class="number">3133</span> &gt; /sys/fs/cgroup/memory/test/tasks</span><br></pre></td></tr></table></figure></p>
<p>于是就出现了上图中的分配到超过10kBytes时kill的情况，从而达到了限制内存的目的。</p>
<h3 id="u9650_u5236_u78C1_u76D8IO"><a href="#u9650_u5236_u78C1_u76D8IO" class="headerlink" title="限制磁盘IO"></a><font size="2"> 限制磁盘IO </font></h3><p>我们来测试如何限制硬盘的IO，模拟命令如下:(从/dev/sda1上读入数据,输出到/dev/null,/dev/null是一个“黑洞”,只能写入不能读，而且写入的文件不保存)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/sda1 of=/dev/null</span><br></pre></td></tr></table></figure></p>
<p>我们使用iotop命令测试速度如下，发现IO的速度是316.3MB/s:<br><img src="/about/docker/cgroup/7.png" alt="logo"><br>当我们使用IO限制，将该IO的PID 3382加入到test组里面时，如下代码(8:0是设备号可以通过ls -l /dev/sda1获得，1048576刚好是1M):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">'8:0 1048576'</span> &gt; /sys/fs/cgroup/blkio/test/blkio.throttle.read_bps_device</span><br><span class="line">echo <span class="number">3382</span>  &gt; /sys/fs/cgroup/blkio/test/tasks</span><br></pre></td></tr></table></figure></p>
<p>于是结果如下<br><img src="/about/docker/cgroup/8.png" alt="logo"><br>从上图可以发现我们确实将磁盘的IO操作限制在了1M，达到了限制磁盘IO的目的。</p>
<h2 id="aufs"><a href="#aufs" class="headerlink" title="aufs"></a><strong>aufs</strong></h2><p>aufs是一种union file system，所谓UnionFS就是将不同物理位置的目录合并mount到同一个目录。UnionFS的一个最主要的应用是，把一张CD/DVD和一个硬盘目录给联合mount在一起，然后，你就可以对这个只读的CD/DVD上的文件进行修改(当然，修改的文件存于硬盘上的目录里)。之前在上篇博客<a href="http://mainboy.github.io/2016/01/11/docker-入门/#more" target="_blank" rel="external">docker入门</a>中介绍过，docker的镜像都是只读的模版，当镜像运行在容器中的时候会在镜像的最上层添加一层可写层。如下图所示:<br><img src="/about/docker/aufs/1.png" width="400" height="100" alt="logo" align="center"><br>docker的分层镜像正是基于aufs实现。但是aufs并没有进入Linux内核主线(内核主线是打算发展overlayFS来取代aufs，最新的Linux内核应该已经包含overlay。)，主要是Linus不让，可能是觉得aufs写得烂，也有可能是不喜欢aufs，但是很多Linux发行版都支持aufs，比如Debian，Ubuntu。Centos不支持aufs，所以其采用的是DeviceMapper(然而并没有aufs好用)。可以查看发行版是否支持aufs<br><img src="/about/docker/aufs/2.png" alt="logo"><br>也可以看看docker是aufs驱动还是DeviceMapper驱动<br><img src="/about/docker/aufs/3.png" alt="logo"><br>docker的分层镜像，除了aufs，devicemapper，docker还支持btrfs和vfs，你可以使用-s或–storage-driver= 选项来指定相关的镜像存储</p>
<p>接下来通过几个例子来介绍aufs<br>1) 测试1<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建fruits vegetables mnt三个目录</span></span><br><span class="line">mkdir fruits vegetables mnt</span><br><span class="line"><span class="comment"># 在fruits里创建apple，tomato两个文件，vegetables里创建carrots，tomato两个文件</span></span><br><span class="line">cd ./fruits</span><br><span class="line">touch apple tomato</span><br><span class="line">cd ../vegetables</span><br><span class="line">touch carrots tomato</span><br><span class="line"><span class="comment"># 将fruits和vegetables目录union mount到./mnt目录中</span></span><br><span class="line">mount -t aufs -o dirs=./fruits:./vegetables none ./mnt</span><br><span class="line"><span class="comment"># mnt目录下会出现三个文件apple，carrots，tomato，你可能会疑问tomato是属于fruits还是vegetables，我可以先告诉你是属于fruits，后面解释为什么。</span></span><br><span class="line"><span class="comment"># 接下来做两个小测试</span></span><br><span class="line"><span class="comment"># First</span></span><br><span class="line">echo mnt &gt; ./mnt/apple</span><br><span class="line">cat ./mnt/apple</span><br><span class="line">cat ./fruits/apple</span><br><span class="line"><span class="comment"># 你会发现上述两个cat输出一样</span></span><br><span class="line"><span class="comment"># Second</span></span><br><span class="line">echo mnt_carrots &gt; ./mnt/carrots</span><br><span class="line">cat ./vegetables/carrots</span><br><span class="line">cat ./fruits/carrots</span><br><span class="line"><span class="comment"># 第一个cat没有任何输出，第二个cat输出了mnt_carrots，我们修改了./mnt/carrots的文件内容，./vegetables/carrots并没有变化，反而是./fruits目录中出现了carrots文件，其内容是我们在./mnt/carrots里的内容</span></span><br><span class="line"><span class="comment"># 原因在于我们在mount aufs命令中，并没有指定vegetables和fruits的目录权限，默认上来说，命令行上第一个(最左边)的目录是可读可写的，后面的全都是只读的，这是不是很类似docker的分层镜像？</span></span><br></pre></td></tr></table></figure></p>
<p>2) 测试2<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现在我们来设置指定权限来mount aufs，先把./fruits/carrots删掉以免干扰。</span></span><br><span class="line">mount -t aufs -o dirs=./fruits=rw:./vegetables=rw none ./mnt</span><br><span class="line"><span class="comment"># 接下来我们再做两个小实验</span></span><br><span class="line"><span class="comment"># First</span></span><br><span class="line">echo <span class="string">"mnt_carrots"</span> &gt; ./mnt/carrots</span><br><span class="line">cat ./vegetables/carrots</span><br><span class="line">cat ./fruits/carrots</span><br><span class="line"><span class="comment"># 我们设置vegetables和fruits两个目录都是可读写的，所以第一个cat有输出，第二个cat无输出符合我们的预期。</span></span><br><span class="line"><span class="comment"># Second 我们来解释tomato</span></span><br><span class="line">echo <span class="string">"mnt_tomato"</span> &gt; ./mnt/tomato</span><br><span class="line">cat ./fruits/tomato</span><br><span class="line">cat ./vegetables/tomato</span><br><span class="line"><span class="comment"># 我们发现第一个cat有输出，第二个cat没有输出，即是当有重复文件名的时候，在mount命令行上，越往前的优先级越高。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a><strong>reference</strong></h2><p>进程间通信<br><a href="http://songlee24.github.io/2015/04/21/linux-IPC/" target="_blank" rel="external">Inter-Process Communication</a></p>
<p>namespace<br><a href="http://lwn.net/Articles/531114/" target="_blank" rel="external">Namespaces in operation</a><br><a href="http://man7.org/linux/man-pages/man7/namespaces.7.html" target="_blank" rel="external">Linux Namespace Man Page</a><br><a href="http://crosbymichael.com/creating-containers-part-1.html" target="_blank" rel="external">Creating containers - Part 1</a><br><a href="http://blog.yadutaf.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/" target="_blank" rel="external">Introduction to Linux namespaces</a></p>
<p>cgroup<br><a href="https://lwn.net/Articles/484251/" target="_blank" rel="external">Fixing control groups</a><br><a href="http://lwn.net/Articles/601840/" target="_blank" rel="external">The unified control group hierarchy in 3.16</a><br><a href="http://events.linuxfoundation.org/sites/events/files/slides/2014-KLF.pdf" target="_blank" rel="external">Cgroup v2(PDF)</a></p>
<p>aufs<br><a href="http://www.linuxjournal.com/article/7714" target="_blank" rel="external">Introduce UnionFS</a><br><a href="http://lwn.net/Articles/325369/" target="_blank" rel="external">Union file systems: Implementations, part I</a><br><a href="http://lwn.net/Articles/327738/" target="_blank" rel="external">Union file systems: Implementations, part 2</a><br><a href="http://lwn.net/Articles/403012/" target="_blank" rel="external">Another union filesystem approach</a><br><a href="http://lwn.net/Articles/324291/" target="_blank" rel="external">Unioning file systems: Architecture, features, and design choices</a></p>
<p><a href="http://coolshell.cn/articles/17010.html" target="_blank" rel="external">酷壳</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近一直都在学习使用docker，当你使用docker越久你就越发的想了解docker背后是如何实现的。其实docker的一些功能之前就已经在Linux内核中实现了，只是有些没有进入内核主线中，但是技术就是这样不会凭空产生，总是靠大量的积累，由量变到质变最后在某个时刻绽放。]]>
    </summary>
    
      <category term="cloud computing" scheme="http://yoursite.com/tags/cloud-computing/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker 入门]]></title>
    <link href="http://yoursite.com/year/01/11/docker-%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/year/01/11/docker-入门/</id>
    <published>2016-01-11T05:26:05.000Z</published>
    <updated>2016-03-05T12:37:56.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/about/docker/1.png" width="500" height="200" alt="logo" align="center">        </p>
<h3 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h3><p>docker是基于LXC的容器技术，它利用Linux内核中namespace隔离进程环境，cgroup限制进程使用物理设备资源，同时创新性的将只读镜像分层，当需要在容器中运行镜像时，只需要在镜像的最外面添加一层可写层。你可以简单的将docker容器理解为进程以及运行进程所需要的轻量级环境。</p>
<p><img src="/about/docker/2.png" width="500" height="200" alt="logo" align="center"><br>如上图所示，左边是VM，右边是docker的工作层次，可以看出容器是在操作系统层面上实现的虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现的管理器。docker的优势在于比VM更轻，无需整个系统的资源环境，直接在容器中运行应用，而且支持Build once, run anywhere。缺点就是所有的容器都是运行在Linux内核上的进程，安全性值得考量，尤其是docker用在大量租户的云计算环境中。</p>
<h3 id="u955C_u50CF"><a href="#u955C_u50CF" class="headerlink" title="镜像"></a>镜像</h3><p>docker的镜像是一个只读的模版。对于镜像，你既可以从docker hub中pull下来，也可以自己利用本地文件系统创建上传到docker hub上，当然首先你需要到docker hub上注册一个账号。</p>
<h4 id="u663E_u793A_u672C_u5730_u955C_u50CF"><a href="#u663E_u793A_u672C_u5730_u955C_u50CF" class="headerlink" title="显示本地镜像"></a><font size="2"> 显示本地镜像 </font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<h4 id="pull_u955C_u50CF"><a href="#pull_u955C_u50CF" class="headerlink" title="pull镜像"></a><font size="2"> pull镜像 </font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:<span class="number">14.04</span></span><br></pre></td></tr></table></figure>
<h4 id="push_u955C_u50CF"><a href="#push_u955C_u50CF" class="headerlink" title="push镜像"></a><font size="2"> push镜像 </font></h4><p>首先需要将镜像打个标签，然后上传(af8表示镜像的ID,mainboy代表docker上注册的用户名)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag af8 mainboy/ubuntu:<span class="number">14.04</span></span><br><span class="line">docker push mainboy/ubuntu</span><br></pre></td></tr></table></figure></p>
<h4 id="u5229_u7528Dockerfile_u6765_u521B_u5EFA_u955C_u50CF"><a href="#u5229_u7528Dockerfile_u6765_u521B_u5EFA_u955C_u50CF" class="headerlink" title="利用Dockerfile来创建镜像"></a><font size="2"> 利用Dockerfile来创建镜像 </font></h4><p>利用Dockerfile创建镜像方便管理，便于上传给团队其他人分享。<br>1) 首先创建Dockerfile如下操作:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir test</span><br><span class="line">cd test</span><br><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure></p>
<p>2) 然后在Dockerfile中加入如下指令，注意每条指令都会新建镜像的一层，层数不要超过127层:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#This is a comment</span></span><br><span class="line">FROM ubuntu:<span class="number">14.04</span></span><br><span class="line">MAINTAINER mainboy &lt;wowyk@qq.com&gt;</span><br><span class="line">RUN apt-get -qq update</span><br><span class="line">RUN apt-get -qqy install ruby ruby-dev</span><br><span class="line">RUN gem install sinatra</span><br></pre></td></tr></table></figure></p>
<p>Dockerfile的基本语法:</p>
<blockquote>
<p>使用#注释<br>FROM指令告诉docker使用那个镜像作为基础<br>MAINTAINER是维护者的信息<br>RUN开头的指令会在创建中运行，比如上述的安装一些软件包</p>
</blockquote>
<p>3) 创建镜像:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t mainboy/test test/</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>-t 表示给镜像添加标签名<br>test/ 表示Dockerfile所在目录<br>创建成功后会在docker images中看到名为mainboy/test的镜像</p>
</blockquote>
<h3 id="u5BB9_u5668"><a href="#u5BB9_u5668" class="headerlink" title="容器"></a>容器</h3><p>容器是从镜像创建运行的实例。启动容器有两种方式，一种是基于镜像新建一个容器启动，另一种是将在终止状态的容器重新启动。<br>运行hello world:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu:<span class="number">14.04</span> /bin/echo <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure></p>
<p>启动一个bash终端:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu:<span class="number">14.04</span> /bin/bash</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>-t 表示给docker分配一个伪终端<br>-i 表示让容器的接受输入</p>
</blockquote>
<p>查看运行中的容器:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></p>
<p>终止一个运行中的容器:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop imageID(表示镜像的ID)</span><br></pre></td></tr></table></figure></p>
<p><font size="2"> <strong>清理容器，镜像的快捷方式:</strong> </font><br>1) 在~/.bash_aliases中加入下面快捷键<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kill all running docker</span></span><br><span class="line">alias dockerkill=<span class="string">'docker kill $(docker ps -a -q)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove all stop docker</span></span><br><span class="line">alias dockercleanc=<span class="string">'docker rm $(docker ps -a -q)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove no tag images</span></span><br><span class="line">alias dockercleani=<span class="string">'docker rmi $(docker images -q -f dangling=true)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove all stop docker and no tag images</span></span><br><span class="line">alias dockerclean=<span class="string">'dockercleanc||true&amp;&amp;dockercleani'</span></span><br></pre></td></tr></table></figure></p>
<p>2) 应用~/.bash_aliases<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_aliases</span><br></pre></td></tr></table></figure></p>
<p>3) 如上所示<br>dockercleanc直接清理掉所有停止的容器</p>
<p><font size="2"> <strong>容器的导入导出，镜像的存出载入:</strong> </font><br>1) 镜像的存出载入:<br>存出:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o ubuntu_14<span class="number">.04</span>.tar ubuntu:<span class="number">14.04</span></span><br></pre></td></tr></table></figure></p>
<p>载入:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load --input ubuntu_14<span class="number">.04</span>.tar</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; ubuntu_14<span class="number">.04</span>.tar</span><br></pre></td></tr></table></figure></p>
<p>2) 容器的导出导入:<br>导出:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export ContainerID &gt; ubuntu.tar</span><br></pre></td></tr></table></figure></p>
<p>导入:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ubuntu.tar | sudo docker <span class="keyword">import</span> - mainboy/ubuntu:<span class="number">14</span>:<span class="number">04</span></span><br></pre></td></tr></table></figure></p>
<p>或者通过指定URL或者某个目录来导入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">import</span> http://example.com/exampleimage.gz example/imagerepo</span><br></pre></td></tr></table></figure></p>
<p>3) 两者的区别:<br>容器快照文件将丢弃所有的历史记录和元数据信息(即仅保存容器当时的快照状态)，所以从容器快照文件导入时可以重新指定标签等元数据信息，而镜像存储文件将保存完整记录，体积也要大一些。</p>
<h3 id="u4ED3_u5E93"><a href="#u4ED3_u5E93" class="headerlink" title="仓库"></a>仓库</h3><p>仓库是存放镜像文件的场所。仓库又分为公开仓库和私有仓库，一般情况公开仓库指的是docker hub，类似于github。私有仓库指的是本地网络下搭建的私有仓库。<br>如何向docker hub上传镜像之前已经说过，如果你想让其他人和你一起修改你的镜像，可以在docker hub的Collaborators中添加那个人，这和github是类似的，下面简单介绍一下如何在本地建立自己的私有仓库来管理镜像。<br>1) 运行docker-registry镜像，这是官方提供的用于构建私有镜像的仓库<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p <span class="number">5000</span>:<span class="number">5000</span> -v /home/de66/registry:/tmp/registry registry</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，仓库会被创建在容器的<em>/tmp/registry</em>下，如果是按照上面的方式运行registry，如果你在本地上传的镜像会存储在<em>/home/de66/registry/repositories/library/</em>下<br>2) 上传镜像方式和上传到docker hub上的方式相同，原本应该是本地IP，但是docker只支持https的方式，默认是http，这个问题还没有解决，现在也没有这个需求，所以我暂时就只是用localhost上传。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag imageID localhost:<span class="number">5000</span>/test</span><br></pre></td></tr></table></figure></p>
<p>3) push镜像<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push localhost:<span class="number">5000</span>/test</span><br></pre></td></tr></table></figure></p>
<p>4) pull镜像<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull localhost:<span class="number">5000</span>/test</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/about/docker/1.png" width="500" height="200" alt="logo" align="center">        </p>
<h3 id="u7B80_u4ECB"><a href="#u7B80_u4ECB]]>
    </summary>
    
      <category term="cloud computing" scheme="http://yoursite.com/tags/cloud-computing/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gem5]]></title>
    <link href="http://yoursite.com/year/01/06/gem5/"/>
    <id>http://yoursite.com/year/01/06/gem5/</id>
    <published>2016-01-06T12:50:17.000Z</published>
    <updated>2016-01-12T14:31:56.000Z</updated>
    <content type="html"><![CDATA[<h4 id="gem5_u7B80_u4ECB"><a href="#gem5_u7B80_u4ECB" class="headerlink" title="gem5简介"></a>gem5简介</h4><p>GEM5是一款模块化的离散事件驱动全系统模拟器，它结合了M5和GEMS中最优秀的部分，是一款高度可配置、集成多种ISA和多种CPU模型的体系结构模拟器。M5是由Michigan大学开发的一款开源的多处理机模拟器，受到了业内的广泛关注，很多高水平论文都采用M5作为研究工具。另一方面，Wisconsin推出的GEMS能够对储存层次进行详细而灵活的模拟，包括对多种不同的cache一致性协议和互联模型的支持。目前的GEM5是M5和GEMS的一个紧耦合版本。<br>GEM5已经能够支持多种商用ISA，包括X86、ARM、ALPHA、MIPS、Power、SPARC等，并且能够在X86、ARM、ALPHA上加载操作系统。</p>
<h4 id="gem5_u7CFB_u7EDF_u6A21_u578B"><a href="#gem5_u7CFB_u7EDF_u6A21_u578B" class="headerlink" title="gem5系统模型"></a>gem5系统模型</h4><p>gem5支持两种不同的系统模型:SE(syscall emulation)和FS(full system)。</p>
<blockquote>
<p>SE模型<br>SE模型能够仿真大部分操作系统级服务，能够取得很好功能模拟加速比。<br>FS模型<br>FS模型模拟完整的全系统，包括OS，运行在用户态和核心态的线程调度以及各种设备。能够精确模拟系统时间等开销。</p>
</blockquote>
<h4 id="gem5_u7684_u5B89_u88C5_u4F7F_u7528"><a href="#gem5_u7684_u5B89_u88C5_u4F7F_u7528" class="headerlink" title="gem5的安装使用"></a>gem5的安装使用</h4><p>首先需要介绍一下我的运行环境,我的环境是在虚拟机上安装的ubuntu14.04, 分配了2个CPU, 当然CPU越多越好,后面会讲为什么。其次是内存尽量足够, 4G应该是够的, 不然编译的过程中可能会出错。安装时将ubuntu提升到root权限。<br><strong>1)安装相关的工具</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install mercurial scons swig gcc m4 python python-dev libprotobuf-dev libgoogle-perftools-dev g++</span><br></pre></td></tr></table></figure></p>
<p>简要介绍一下上述工具:<br>mercurial是一个类似于git的软件版本控制工具,主要是负责下载和更新gem5的。<br>scons是类似于make的自动编译链接工具。区别就是make是寻找当前目录的Makefile文件, scons是寻找当前目录的SConstruct配置文件。<br>swig是将C++程序封装以后供给python调用。<br>gcc与g++是C/C++的编译和链接工具,因为gem5对其版本有要求,所以我们这里相当于更新一下。<br>python和python-dev是支持python的工具<br>libprotobuf-dev和libgoogle-perftools-dev是google的一套序列化工具。类似于XML的功能, 将结构化的数据进行序列化存储或传输, 在另一端进行反序列化。protobuf支持C++、Java、Python 三种语言的 API, 它的主要优点就是快, 简单易学。</p>
<p><strong>2)下载gem5</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hg clone http://repo.gem5.org/gem5</span><br></pre></td></tr></table></figure></p>
<p><strong>3)构建gem5</strong>(-j<n>中,n=2*cpu的个数,为编译过程分配n个人物,多线程编译,速度会提升)我选择的是ALPHA指令集架构,当然也可以用其他的架构ARM/X86等。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scons build/ALPHA/gem5.opt -j4</span><br></pre></td></tr></table></figure></n></p>
<p>上述过程可能会失败：<br><strong>问题1)</strong>如果zlib.h文件没找到就需要安装<a href="http://www.zlib.net" target="_blank" rel="external">zlib-1.2.8</a>下载以后将zlib-1.2.8加入gem5<br>进入zlib-1.2.8目录执行下面命令：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p><strong>问题2)</strong>如果出现有关protobuf相关的问题就去下载<a href="https://developers.google.com/protocol-buffers/docs/downloads?hl=zh-cn" target="_blank" rel="external">protobuf-2.6.1</a>, 完成以后将protobuf-2.6.1加入gem5<br>同样进入protobuf-2.6.1目录执行下面命令：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p>同时需要将下面的代码加入~/.bashrc文件里面(下面第三行的/home/yankang/MyItem/gem5/protobuf-2.6.1替换成你的protobuf-2.6.1所在目录)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export LIBRARY_PATH=$LIBRARY_PATH:/usr/local/lib</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib</span><br><span class="line">export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/home/yankang/MyItem/gem5/protobuf-<span class="number">2.6</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></p>
<p>如果不加上述三行，会找不到protobuf-2.6.1的。</p>
<p><strong>4)测试hello world</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/ALPHA/gem5.opt configs/example/se.py -c tests/test-progs/hello/bin/alpha/linux/hello</span><br></pre></td></tr></table></figure></p>
<p>可以清楚的看见hello world被打印出来。<br><img src="/about/gem5/1.png" alt="logo"><br>可以看出几点:<br>Gem5是精确级模拟, 因为它内部的最小计时单位是tick, 而1秒=1万亿ticks。<br>可以通过gdb访问7000端口从而进行调试工作。</p>
<h4 id="gem5_u5168_u7CFB_u7EDF_u6A21_u62DF"><a href="#gem5_u5168_u7CFB_u7EDF_u6A21_u62DF" class="headerlink" title="gem5全系统模拟"></a>gem5全系统模拟</h4><p>*)首先下载系统<a href="http://www.m5sim.org/dist/current/m5_system_2.0b3.tar.bz2" target="_blank" rel="external">镜像</a></p>
<p>*)新建一个目录full_system_images, 将上述压缩包解压到full_system_images目录中, 并用pwd得到镜像所在目录, 我的目录在<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/yankang/MyItem/full_system_images/</span><br></pre></td></tr></table></figure></p>
<p>*)将镜像目录重定向到~/.bashrc中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"export M5_PATH=/home/yankang/MyItem/full_system_images/"</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<p>*)开启全系统仿真:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/ALPHA/gem5.opt configs/example/fs.py</span><br></pre></td></tr></table></figure></p>
<p>如图:<br><img src="/about/gem5/2.png" alt="logo"><br>从该结果可以看出:<br>通过3456端口可以访问全系统。<br>于是开启另一个终端, 在gem5目录中输入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd util/term/</span><br></pre></td></tr></table></figure></p>
<p>进入上述目录以后输入make, 即可编译出m5term。<br>接着输入:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m5term localhost <span class="number">3456</span></span><br></pre></td></tr></table></figure></p>
<p>就可以进入系统结果如图:<br><img src="/about/gem5/3.png" alt="logo"><br>输入clear即可清屏:<br>再输入ls就可以看到如下图:<br><img src="/about/gem5/4.png" alt="logo"><br>benchmarks中有一些测试程序:<br>进入以后可以看到下图:<br><img src="/about/gem5/5.png" alt="logo"><br>我们可以测试一下pthread_mutex_test:<br><img src="/about/gem5/6.png" alt="logo"><br>同时我们也可以尝试将hello world程序加入到这个系统里面<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ./tests/test-progs/hello/bin/alpha/linux/hello ./hello</span><br></pre></td></tr></table></figure></p>
<p>然后将镜像系统挂载在/mnt上:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o,loop,offset=<span class="number">32256</span> ../full_system_images/disks/linux-latest.img /mnt/</span><br></pre></td></tr></table></figure></p>
<p>将hello拷贝到/mnt<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp hello /mnt</span><br></pre></td></tr></table></figure></p>
<p>ls的结果如下图:<br><img src="/about/gem5/7.png" alt="logo"><br>可以看到hello进入了镜像系统然后解挂载:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount /mnt</span><br></pre></td></tr></table></figure></p>
<p>重新进入全系统模拟结果如图:<br><img src="/about/gem5/8.png" alt="logo"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="gem5_u7B80_u4ECB"><a href="#gem5_u7B80_u4ECB" class="headerlink" title="gem5简介"></a>gem5简介</h4><p>GEM5是一款模块化的离散事件驱动全系统模拟器，它结合了M5和GEM]]>
    </summary>
    
      <category term="Architecture" scheme="http://yoursite.com/tags/Architecture/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim]]></title>
    <link href="http://yoursite.com/year/01/06/Vim/"/>
    <id>http://yoursite.com/year/01/06/Vim/</id>
    <published>2016-01-06T08:20:55.000Z</published>
    <updated>2016-01-06T08:49:58.000Z</updated>
    <content type="html"><![CDATA[<p>在Linux下编写程序时，拥有一套类似于VS的集成开发环境可以大大提高程序的阅读和编写效率。本文介绍如何安装vim, ctags, cscope, Taglist, SuperTab, OmniCppComplete, Winmanager, NERDTree和MiniBufExplorer等组件。最后的界面类似于如下:<br><img src="/about/Vim/1.png" alt="logo"></p>
<p>在安装之前将权限提升到root, 以后尽量使用root权限<br>ubuntu下：sudo su然后输入密码</p>
<h4 id="u5B89_u88C5vim"><a href="#u5B89_u88C5vim" class="headerlink" title="安装vim"></a>安装vim</h4><pre><code>apt-get install vim
</code></pre><h4 id="u5B89_u88C5_u4F7F_u7528ctags"><a href="#u5B89_u88C5_u4F7F_u7528ctags" class="headerlink" title="安装使用ctags"></a>安装使用ctags</h4><p>ctags是利用堆栈实现的能快速定位符号的工具。<br>安装方法：<br>1)从<a href="http://ctags.sourceforge.net/" target="_blank" rel="external">http://ctags.sourceforge.net/</a>下载源代码包后，解压缩生成源代码目录<br>2)然后进入源代码根目录执行./configure<br>3)然后执行make<br>4)编译成功后执行make install<br>5)最后将ctrl-F12组合键映射到生成ctags的命令，需要在~/.vimrc(没有就新建)里面添加<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map &lt;C-F12&gt; :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .&lt;CR&gt;</span><br></pre></td></tr></table></figure></p>
<p>使用ctags的方法:<br>使用vim打开源代码目录里面的文件，然后同时按下ctrl和F12键生成tags。<br>简单的使用就是<br>Ctrl-]    跳转到光标所在符号的定义。<br>Ctrl-t    回到上次跳转前的位置</p>
<p>更多的功能通过命令man ctags或在vim的命令行模式下(命令行模式就是在正常打开vim后输入:就进入命令行模式)执行help ctags查询。</p>
<h4 id="u5B89_u88C5_u4F7F_u7528cscope"><a href="#u5B89_u88C5_u4F7F_u7528cscope" class="headerlink" title="安装使用cscope"></a>安装使用cscope</h4><p>安装cscope的方法:<br>1)从<a href="http://cscope.sourceforge.net/" target="_blank" rel="external">http://cscope.sourceforge.net/</a>下载源代码包后，解压缩生成源代码目录<br>2)然后进入源代码根目录执行./configure<br>3)然后执行make<br>4)编译成功后执行make install<br>5)将文件<a href="http://cscope.sourceforge.net/cscope_maps.vim" target="_blank" rel="external">http://cscope.sourceforge.net/cscope_maps.vim</a>下载到~/.vim/plugin目录，如果没有该目录就新建。</p>
<p>使用cscope的方法:<br>1) 生成cscope数据库文件，进入项目代码根目录运行命令<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscope -Rbq -f ./a.out</span><br></pre></td></tr></table></figure></p>
<p>2)打开源代码的根目录下的文件在vim的命令下输入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cs add ./a.out</span><br></pre></td></tr></table></figure></p>
<p>将数据库加载进来</p>
<p>Cscope常用快捷键<br>Ctrl-\ s 查找所有当前光标所在符号出现过位置。<br>Ctrl-\ c 查找所有调用当前光标所在函数的函数。</p>
<p>在命令行下输入cw还可以重选。<br>为了使cscope展现的更好看，在~/.vimrc里面添加如下行<br>set cscopequickfix=s-,c-,d-,i-,t-,e-</p>
<h4 id="u5B89_u88C5_u4F7F_u7528Taglist"><a href="#u5B89_u88C5_u4F7F_u7528Taglist" class="headerlink" title="安装使用Taglist"></a>安装使用Taglist</h4><p>1）从<a href="http://www.vim.org/scripts/script.php?script_id=273" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=273</a>下载安装包，也可以从<a href="http://vim-taglist.sourceforge.net/index.html" target="_blank" rel="external">http://vim-taglist.sourceforge.net/index.html</a>下载。<br>2）进入~/.vim目录，将Taglist安装包解压，解压后会在~/.vim目录中生成几个新子目录，如plugin和doc（安装其它插件时，可能还会新建autoload等其它目录）。<br>3）进入~/.vim/doc目录，在Vim下运行”helptags .”命令。此步骤是将doc下的帮助文档加入到Vim的帮助主题中，这样我们就可以通过在Vim中运行“help taglist.txt”查看taglist帮助。<br>4）打开配置文件~/.vimrc，加入以下两行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let Tlist_Show_One_File=<span class="number">1</span></span><br><span class="line">let Tlist_Exit_OnlyWindow=<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>在命令行下输入TlistToggle命令就可以打开Taglist窗口。</p>
<h4 id="u5B89_u88C5_u4F7F_u7528OmniCppComplete"><a href="#u5B89_u88C5_u4F7F_u7528OmniCppComplete" class="headerlink" title="安装使用OmniCppComplete"></a>安装使用OmniCppComplete</h4><p>OmniCppComplete主要提供输入时实时提供类或结构体的属性或方法的提示和补全。跟Talist一样，OmniCppComplete也是一个Vim插件，同样依赖与Ctags工具生成的tags文件。安装步骤跟Taglist类似。<br>从<a href="http://www.vim.org/scripts/script.php?script_id=1520" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=1520</a>下载安装包后。<br>1）进入~/.vim目录，将安装版解压缩<br>2）进入~/.vim/doc目录，在Vim命令行下运行”helptags .”<br>3）在~/.vimrc中加入以下几行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set nocp</span><br><span class="line">filetype plugin on</span><br></pre></td></tr></table></figure></p>
<h4 id="u5B89_u88C5_u4F7F_u7528SuperTab"><a href="#u5B89_u88C5_u4F7F_u7528SuperTab" class="headerlink" title="安装使用SuperTab"></a>安装使用SuperTab</h4><p>SuperTab使Tab快捷键具有更快捷的上下文提示功能。跟OmniCppComplete一样，SuperTab也是一个Vim插件。<br>从<a href="http://www.vim.org/scripts/script.php?script_id=1643" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=1643</a>下载安装版。这个安装包跟先前的几个Vim插件不同，它是一个vba文件，即Vimball格式的安装包，这种格式安装包提供傻瓜式的安装插件的方法。<br>1）用Vim打开.vba安装包文件。<br>2）在Vim命令行下运行命令“UseVimball ~/.vim”。此命令将安装包解压缩到~/.vim目录。VImball安装方式的便利之处在于你可以在任何目录打开.vba包安装，而不用切换到安装目的地目录。而且不用运行helptags命令安装帮助文档。<br>3）在~/.vimrc文件中加入以下这行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let g:SuperTabDefaultCompletionType=<span class="string">"context"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="u5B89_u88C5_u4F7F_u7528Winmanager_2C_NERDTree_u548CMiniBufExplorer"><a href="#u5B89_u88C5_u4F7F_u7528Winmanager_2C_NERDTree_u548CMiniBufExplorer" class="headerlink" title="安装使用Winmanager, NERDTree和MiniBufExplorer"></a>安装使用Winmanager, NERDTree和MiniBufExplorer</h4><p>前面介绍的几个工具和插件，主要提供快捷的编辑功能，如定义跳转，符号查询，符号提示与补全等。这里的三个插件，主要优化布置VIm的界面。具体来说，NERDTree提供树形浏览文件系统的界面，MiniBufExplorer提供多文件同时编辑功能，而Winmanager将这NERDTree界面和Taglist界面整合起来，使Vim更像VS！<br>分别从<a href="http://www.vim.org/scripts/script.php?script_id=1658" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=1658</a><br><a href="http://www.vim.org/scripts/script.php?script_id=159" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=159</a><br><a href="http://www.vim.org/scripts/script.php?script_id=95" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=95</a><br>下载NERDTree，MiniBufExplorer和Winmanager安装包（Winmanager还有个更新的vba版本<a href="http://www.vim.org/scripts/script.php?script_id=1440" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=1440</a>，这里选用旧版本的Winmanger）。<br>1）像其它插件一样，将NERDTree安装包解压到~/.vim目录。并进入doc目录，在Vim命令行下运行”helptags .”命令。<br>2）MiniBufExplorer只有一个.vim文件，将其拷贝到~/.vim/plugin目录。<br>3）在~/.vimrc文件中加入以下几行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let g:miniBufExplMapWindowNavVim = <span class="number">1</span> </span><br><span class="line">let g:miniBufExplMapWindowNavArrows = <span class="number">1</span> </span><br><span class="line">let g:miniBufExplMapCTabSwitchBufs = <span class="number">1</span> </span><br><span class="line">let g:miniBufExplModSelTarget = <span class="number">1</span></span><br><span class="line">let g:miniBufExplMoreThanOne=<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>4）将Winmanager安装包解压到~/.vim目录。<br>5）在~/.vimrc文件中加入以下几行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let g:NERDTree_title=<span class="string">"[NERDTree]"</span></span><br><span class="line">let g:winManagerWindowLayout=<span class="string">"NERDTree|TagList"</span></span><br><span class="line"></span><br><span class="line">function! NERDTree_Start()</span><br><span class="line">	<span class="keyword">exec</span> <span class="string">'NERDTree'</span></span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">function! NERDTree_IsValid()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">nmap wm :WMToggle&lt;CR&gt;</span><br></pre></td></tr></table></figure></p>
<p>6）这个版本的Winmanager好像有个小bug，你在打开Winmanager界面时，会同时打开一个空的文件。这会影响后续使用，所以我们要在打开Winmanager时关掉这个空文件。在~/.vim/plugin目录下的winmanager.vim文件中找到以下函数定义并在第5行下添加第6行的内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function! &lt;SID&gt;ToggleWindowsManager()</span><br><span class="line">	<span class="keyword">if</span> IsWinManagerVisible()</span><br><span class="line">		call s:CloseWindowsManager()</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		call s:StartWindowsManager()</span><br><span class="line">	exe <span class="string">'q'</span></span><br><span class="line">	end</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure></p>
<p>这样同时按下w-m就可以打开集成环境。</p>
<h4 id="u5176_u4ED6_u6709_u7528_u7684_7E/-vimrc_u914D_u7F6E"><a href="#u5176_u4ED6_u6709_u7528_u7684_7E/-vimrc_u914D_u7F6E" class="headerlink" title="其他有用的~/.vimrc配置"></a>其他有用的~/.vimrc配置</h4><p>在~/.vimrc里面加入：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">colo evening</span><br><span class="line">set nu</span><br><span class="line">set autoindent</span><br><span class="line">set tabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line">set mouse=a</span><br><span class="line">set hlsearch</span><br><span class="line"></span><br><span class="line">" 执行特定命令并保留光标位置及搜索历史</span><br><span class="line">function! Preserve(command)</span><br><span class="line">	let _s=@/</span><br><span class="line">	let l = line(".")</span><br><span class="line">	let c = col(".")</span><br><span class="line">	execute a:command</span><br><span class="line"></span><br><span class="line">	let @/=_s</span><br><span class="line">		call cursor(l, c)</span><br><span class="line">	endfunction</span><br><span class="line">" 格式化全文</span><br><span class="line">function! FullFormat()</span><br><span class="line">	call Preserve("normal gg=G")</span><br><span class="line">endfunction</span><br><span class="line">nmap &lt;M-F9&gt; :call FullFormat()&lt;CR&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Linux下编写程序时，拥有一套类似于VS的集成开发环境可以大大提高程序的阅读和编写效率。本文介绍如何安装vim, ctags, cscope, Taglist, SuperTab, OmniCppComplete, Winmanager, NERDTree和MiniBu]]>
    </summary>
    
      <category term="Vim" scheme="http://yoursite.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图着色问题]]></title>
    <link href="http://yoursite.com/year/01/03/%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/year/01/03/图着色问题/</id>
    <published>2016-01-03T04:12:08.000Z</published>
    <updated>2016-01-06T11:57:56.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u95EE_u9898_u63CF_u8FF0_3A"><a href="#u95EE_u9898_u63CF_u8FF0_3A" class="headerlink" title="问题描述:"></a>问题描述:</h4><p>给出一张图，节点有n个，总共有k种颜色，将k种颜色分配给这n个点，使得在图中的每条边所连接的两个点的颜色不同。这是一个NP问题，如果从精确算法去求解，则会很难在多项式时间内确定求解，所以我们从组合优化的角度对其进行求解。下面描述了禁忌搜索算法和多种混合进化算法处理思路。</p>
<h4 id="u542F_u53D1_u5F0F_u641C_u7D22"><a href="#u542F_u53D1_u5F0F_u641C_u7D22" class="headerlink" title="启发式搜索"></a>启发式搜索</h4><h5 id="1-_u7981_u5FCC_u641C_u7D22"><a href="#1-_u7981_u5FCC_u641C_u7D22" class="headerlink" title="1.禁忌搜索"></a>1.禁忌搜索</h5><p>第一步:随机产生一个初始解，即将每个点随机分配一种颜色，并计算f, f代表当前解的矛盾数(矛盾是指相邻节点颜色相同)。可以利用所有的矛盾数相加除以2求得。<br>第二步:初始化M矩阵,M是一个二维矩阵(如下图)，记录每个点着不同的颜色的不同矛盾数。<br><img src="/about/Graphcoloring/1.jpeg" alt="logo"><br><img src="/about/Graphcoloring/2.png" alt="logo"><br>第三步:判断是否有解即每个点涂色后对应的M都是0。可以用f=0表示有解, 若有解则退出。<br>第四步:若不解,则需考虑能使f最快下降的Δf, Δf理应是个负数, 但是陷入局部最优的时候也是可以接受正数的, 考虑非禁忌的最好解, 保存最小的Δf, 若有多组最好解则按照1/n的概率选择新的最好解。禁忌的最好解的处理方式也是同样的。<br>第五步:若禁忌的最好解严格优于非禁忌的最好解且严格优于历史最优f_best，则接受禁忌的最好解，否则接受非禁忌的最好解。<br>第六步:更新M表，并且将新加入的解设为禁忌解，禁忌长度为当前迭代次数+当前矛盾数+1到10的随机数。再走第三步。(如何区分禁忌解与非禁忌解,如果禁忌长度大于当前迭代次数则是禁忌解, 否则解禁为非禁忌解。)</p>
<h5 id="2-_u6DF7_u5408_u8FDB_u5316_u641C_u7D22"><a href="#2-_u6DF7_u5408_u8FDB_u5316_u641C_u7D22" class="headerlink" title="2.混合进化搜索"></a>2.混合进化搜索</h5><p>混合方式: 交替选择父代中图同颜色最多的组，依次标上1~k种颜色, 然后去掉属于该组的所有元素, 最后若有未被分配的节点, 则随机涂色。如图所示<br><img src="/about/Graphcoloring/3.jpeg" alt="logo"></p>
<p>混合进化1:<br>十个子代构成种群，随机选择两个进行杂交(杂交方式如上图)，然后将结果进行禁忌搜索，用得到的新解，替换原先的十个种群中最差的解，(ps：一种是直接替换最差的解，一种是新解比原先最差的解要好的时候才替换。其实测试两种效果差不多。)</p>
<p>混合进化2:<br>只有两个初始解,将两个解作为父代s1,s2.s1杂交s2得到一种解s1’,s2杂交s1得到一种解s2’,将s1’禁忌得到的解直接替换替换s1,将s2’禁忌得到的解直接替换替换s2,重复操作。直至求解。</p>
<p>混合进化3:<br>思想和第二种大致相同,但是它会在每次把上一个十代的最好解替换当前的某个父代。这种方法是考虑到疏散性与集中性的平衡,其实生活的哲学也是一种平衡。这种处理方法是最快能够求解的，如果需要源码和测试案例可以邮箱联系我。</p>
<h4 id="u7ED3_u8BBA"><a href="#u7ED3_u8BBA" class="headerlink" title="结论"></a>结论</h4><p>对于NP问题的研究感觉需要很多灵感，需要借鉴各个领域的知识，这也从另一方面说明了计算机科学是一个舶来品的科学。关于NP?=P一直都无法解决，很多研究人员所做的事情更像是炼丹，炼出来的结果不错就可以发论文。当然解决这些问题本身也是很有趣的，也很有价值，如果将每个点都赋予权值，就会有sum-coloring问题，如果再把每个点当成集群的节点，就会有比如负载均衡，资源分配的问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u95EE_u9898_u63CF_u8FF0_3A"><a href="#u95EE_u9898_u63CF_u8FF0_3A" class="headerlink" title="问题描述:"></a>问题描述:</h4><p>给出一张图，节点有n个，总共有k]]>
    </summary>
    
      <category term="NP" scheme="http://yoursite.com/tags/NP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MicroBlaze Simple IO Test]]></title>
    <link href="http://yoursite.com/year/01/03/MicroBlaze-Simple-IO-Test/"/>
    <id>http://yoursite.com/year/01/03/MicroBlaze-Simple-IO-Test/</id>
    <published>2016-01-03T02:03:31.000Z</published>
    <updated>2016-01-06T14:30:31.000Z</updated>
    <content type="html"><![CDATA[<p>本实验使用Digilent Anvyl Spartan6 FPGA开发套件，只需要使用EDK中的Xilinx Platform Studio.(XPS) 务必注意后面的备注Could not detect MDM peripheral on hardware.这是我写博文的主要原因,竟然被这么一个愚蠢的问题给卡住了。。。</p>
<p>第一步：在XPS操作<br>(1)点击Create New Project Using Base System Builder<br><img src="/about/microblaze/1.jpeg" alt="logo"><br>(2)选择安装路径及命名<br><img src="/about/microblaze/2.png" alt="logo"><br>(3)FPGA选择XC6SLX45，封装为csg484，按下图配置，一定要记住你是高电平复位还是低电平复位(这是我写这篇文档的重要原因)<br><img src="/about/microblaze/3.jpeg" alt="logo"><br>(4)按下图配置, 需要在Add Device中找到开关, LED灯, 串口加入。点击Finish<br><img src="/about/microblaze/4.jpeg" alt="logo"><br>(5)去掉CLK_N, 将CLK_P改成CLK得到下图<br><img src="/about/microblaze/5.png" alt="logo"><br>(6)进入.mhs和.ucf文件<br>进入.mhs将DIFFERENTIAL_POLARITY = P去掉<br><img src="/about/microblaze/6.jpeg" alt="logo"><br>进入.ucf加入以下引脚绑定<br><img src="/about/microblaze/7.png" alt="logo"><br>(7)点击Generate BitStream 开始生成, 若出现bug再重新点击Generate BitStream生成</p>
<p>第二步：进入SDK平台<br>(1)在XPS环境中导出SDK：<br>先选择XPS环境中Project下的“Export Hardware Design To SDK …”<br><img src="/about/microblaze/8.jpeg" alt="logo"><br>在弹出的对话框中选择“Export &amp; Launch SDK”<br><img src="/about/microblaze/9.png" alt="logo"><br>(2)选择工作目录，最好在SDK下面新建一个SDK_workspace文件夹, 点击OK<br><img src="/about/microblaze/10.png" alt="logo"><br>(3)如下图所示界面，稍等片刻<br><img src="/about/microblaze/11.jpeg" alt="logo"><br>导入完成，出现如下界面，此时的CPU_SYS_hw_platform平台为默认的平台，我们可以理解为硬件平台。现在就完全进入了SDK环境，此后就可以从Windows界面直接进入。<br><img src="/about/microblaze/12.png" alt="logo"><br>(4)新建一个工程，选择Xilinx C Project，点击Next<br><img src="/about/microblaze/13.jpeg" alt="logo"><br>(5)选择 Hello World 模板，点Next<br><img src="/about/microblaze/14.jpeg" alt="logo"><br>(6)生成成功，点击Finish 即可<br><img src="/about/microblaze/15.jpeg" alt="logo"><br>此时的模版已经生成，在里面hello_world_0下展开会有src文件夹，其中的helloworld.c可以进行编写，但是此时的程序已经是一个完整的程序，运行即可。</p>
<p>(7)由于要点亮LED灯，为简单起见，我们类似于上面的模版生成一个Peripheral Tests模版，如下图，点Next<br><img src="/about/microblaze/16.jpeg" alt="logo"><br>弹出下图所示界面后等待，如下图，完成后点Finish<br><img src="/about/microblaze/17.jpeg" alt="logo"><br>(8)Build Project<br>右键点击peripheral_test_o在弹出的选项中选择Build Project，或者在工具栏中的Project下选择Build Project<br><img src="/about/microblaze/18.png" alt="logo"><br>(9)Program FPGA<br>单击工具栏的Program FPGA图标，如下图所示，或者在Xilinx Tools中选择Program FPGA<br><img src="/about/microblaze/19.jpeg" alt="logo"><br>在弹出的下图中选择相应目录下的.bit文件和.bmm文件（一般选择_bd的那一个），然后点击Program即可<br><img src="/about/microblaze/20.png" alt="logo"><br>当进度条跑满的时候就表示下载成功</p>
<p>重新认识下工具栏中比较常用的几个，如下图所示。<br>第一个红色框框住的图标表示Program FPGA，这在前面已经用到过；<br>绿色框所示的图标为Debug模式下进行调试用的，一般会在完善程序的时候用到；<br>紫色框所示图标即为最常用的验证程序是否运行正确时使用到的，本次实验我们就点击这个图标，然后观察FPGA开发板上面的外围设备有没有按照预期的结果运行。<br><img src="/about/microblaze/21.jpeg" alt="logo"><br>(10)运行程序<br>点击上面提到的紫色框中图标右侧的小三角，选择“Run Configurations … ”或者在直接在菜单栏Run下面的选项中选择“Run Configurations … ”弹出如下图所示对话框<br>先选中左侧的peripheral_test_0.elf，在右侧的STDIO Connection下，先选中Connect STDIO to Console复选框，再在Port下拉菜单中选择COM1(这要看你的设备也可能是COM4等等)，点击右下的Apply后，点Run即可<br><img src="/about/microblaze/22.jpeg" alt="logo"><br>此时，程序已经运行起来，因为是第一次设置，所以上述步骤不可省略。<br>运行完后观察FPGA开发板，可以看到8个LED灯依次亮起，打开串口调试工具并正确设置后也可以看到在接收区出现如下图所示输出，这充分表明Microblaze和SDK中的程序均正确运行起来。(如果我们在硬件平台设计时使用了“调试串口”，不需要专用的串口调试软件，在SDK的Console中就可以看到下面的信息)<br><img src="/about/microblaze/23.png" alt="logo"><br>备注:如果你出现下面这种错误, 处理方法, 想想之前是RESET设置的高电平还是低电平重置, 如果是高电平重置,则当你Program一定要将RESET置为低电平, 否则置为高电平, 切记！<br><img src="/about/microblaze/24.png" alt="logo"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本实验使用Digilent Anvyl Spartan6 FPGA开发套件，只需要使用EDK中的Xilinx Platform Studio.(XPS) 务必注意后面的备注Could not detect MDM peripheral on hardware.这是我写博文的]]>
    </summary>
    
      <category term="Hardware" scheme="http://yoursite.com/tags/Hardware/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[组合数学]]></title>
    <link href="http://yoursite.com/year/01/02/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    <id>http://yoursite.com/year/01/02/组合数学/</id>
    <published>2016-01-02T08:04:42.000Z</published>
    <updated>2016-01-27T01:01:54.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u524D_u8FF0"><a href="#u524D_u8FF0" class="headerlink" title="前述"></a>前述</h4><p>组合数学：<br>1) C(n,m)=C(n,n-m)经常拿来预处理提高程序的执行效率。<br>还有很多需要总结的，还没想好，先放着。</p>
<h4 id="POJ2249"><a href="#POJ2249" class="headerlink" title="POJ2249"></a>POJ2249</h4><p>题目描述：求组合数C(n,2)。<br>解题思路：如果直接相乘肯定会在中途溢出，所以用贪心的策略，每乘一个数，用尽量多的除数去把它除掉，如果再用64保存结果应该更加保险一点。<br>源代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,k;</span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;k)==<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (n==<span class="number">0</span>&amp;&amp;k==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (n-k&lt;k)</span><br><span class="line">			k=n-k;</span><br><span class="line">		int i,m=k;</span><br><span class="line">		__int64 mul=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=k;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			mul = mul*(n-m+i);</span><br><span class="line">			<span class="keyword">while</span> (mul%k==<span class="number">0</span>&amp;&amp;k&gt;<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				mul /= k;</span><br><span class="line">				k--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(<span class="string">"%I64d\n"</span>,mul);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1833"><a href="#POJ1833" class="headerlink" title="POJ1833"></a>POJ1833</h4><p>题目描述：大家知道，给出正整数n，则1到n这n个数可以构成n！种排列，把这些排列按照从小到大的顺序（字典顺序）列出，如n=3时，列出1 2 3，1 3 2，2 1 3，2 3 1，3 1 2，3 2 1六个排列。 </p>
<p>任务描述：<br>给出某个排列，求出这个排列的下k个排列，如果遇到最后一个排列，则下1排列为第1个排列，即排列1 2 3…n。<br>比如：n = 3，k=2 给出排列2 3 1，则它的下1个排列为3 1 2，下2个排列为3 2 1，因此答案为3 2 1。</p>
<p>解决思路：1. 使用next_permutation函数  2.模拟这个查找过程，先找右边第一个逆序的数，将其右边略大于它的数放在其位置，将右边剩下的数和它按从小到大排序即完成一次next_permutation。</p>
<p>源代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int m,n,k,i,a[<span class="number">1024</span>+<span class="number">5</span>];</span><br><span class="line">	scanf(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			scanf(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">		<span class="keyword">while</span> (k--)</span><br><span class="line">			next_permutation(a,a+n);</span><br><span class="line">		printf(<span class="string">"%d"</span>,a[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">			printf(<span class="string">" %d"</span>,a[i]);</span><br><span class="line">		printf(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1844"><a href="#POJ1844" class="headerlink" title="POJ1844"></a>POJ1844</h4><p>题目描述：给你一个数S让你用1～N，用这些自然数通过加减得到S，要求N最小。<br>比如12=－1+2+3+4+5+6-7<br>解题思路：S＝(1+N)<em>N/2  - 偶数，这很容易想到。那么偶数等于(1+N)</em>N/2-S, 现在要证明为什么(1+N)<em>N/2-S是偶数就能得到S，首先(1+N)</em>N/2-S &lt; (1+N)<em>N的也就是偶数 &lt; (1+N)</em>N，我们知道偶数是通过翻转1～N中的若干数得到，只要他不超过(1+N)<em>N就可以翻转得到，因此此N是可以通过加减得到S的，另外N从小到大依次找，第一个能使(1+N)</em>N/2-S为偶数的既是N最小。<br>源代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,i;</span><br><span class="line">	scanf(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	int sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;sum&lt;n||(sum-n)%<span class="number">2</span>==<span class="number">1</span>;i++)</span><br><span class="line">		sum += i;</span><br><span class="line">	printf(<span class="string">"%d\n"</span>,i-<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u524D_u8FF0"><a href="#u524D_u8FF0" class="headerlink" title="前述"></a>前述</h4><p>组合数学：<br>1) C(n,m)=C(n,n-m)经常拿来预处理提高程序的执行效率。<br>还有很多]]>
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[字符串]]></title>
    <link href="http://yoursite.com/year/01/02/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/year/01/02/字符串/</id>
    <published>2016-01-02T07:57:19.000Z</published>
    <updated>2016-01-27T01:00:44.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u524D_u8FF0"><a href="#u524D_u8FF0" class="headerlink" title="前述"></a>前述</h4><p>首先介绍一些技巧总结：<br>1) scanf与gets的区别：scanf读取到空格或换行，gets读取到换行。<br>2) 需要保存最后输出字符串的时候可以自定义数组char ch[max]来保存，记得加串尾。<br>3) string.h里面一些常用的函数memcpy，strcpy，strcmp，strchr，strstr，strlen， strtok。<br>ctype.h里面一些常用函数isalnum, isalpha, isdigit, islower/isupper, tolower/toupper。</p>
<p>现在再谈谈POJ上面的一些处理字符串类型的题目</p>
<h4 id="POJ1598"><a href="#POJ1598" class="headerlink" title="POJ1598"></a>POJ1598</h4><p>题目描述：给你K个小写字母组成的单词，E个句子，先要你输出包含K个单词中的单词数目最多的句子，如有多个这样的句子，不要求顺序的输出。句子匹配不考虑大小写。<br>解题思路：网上可能有些其他的思路比如STL，排序之类的，这里我采用字符处理提取单词的方法，然后进行匹配计数，最后输出等于最大计数的句子。<br>源代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;ctype.h&gt;</span></span><br><span class="line">char pattern[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line">char inStr[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line">int cnt[<span class="number">205</span>];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int k,e,set=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%d%d"</span>,&amp;k,&amp;e)==<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(cnt,<span class="number">0</span>,sizeof(cnt));</span><br><span class="line">		int i,j,m,max=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">			scanf(<span class="string">"%s"</span>,&amp;pattern[i]);</span><br><span class="line">		getchar();</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;e;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			gets(inStr[i]);</span><br><span class="line">			int len=strlen(inStr[i]);</span><br><span class="line">			char ch[<span class="number">105</span>];</span><br><span class="line">			<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				int a=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">while</span> (isalpha(inStr[i][j]))</span><br><span class="line">				&#123;</span><br><span class="line">					ch[a++] = tolower(inStr[i][j]);</span><br><span class="line">					j++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (a&gt;<span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ch[a]=<span class="string">'\0'</span>;</span><br><span class="line">					<span class="keyword">for</span> (m=<span class="number">0</span>;m&lt;k;m++)</span><br><span class="line">						<span class="keyword">if</span> (strcmp(ch,pattern[m])==<span class="number">0</span>)</span><br><span class="line">						&#123;</span><br><span class="line">							cnt[i]++;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;e;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (cnt[i] &gt; max)</span><br><span class="line">			&#123;</span><br><span class="line">				max = cnt[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(<span class="string">"Excuse Set #%d\n"</span>,set++);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;e;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (max==cnt[i])</span><br><span class="line">				printf(<span class="string">"%s\n"</span>,inStr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1782"><a href="#POJ1782" class="headerlink" title="POJ1782"></a>POJ1782</h4><p>题目描述：题意不容易理解，主要是需要你重新编码。规则如下：<br>1）将连续相同的字符串依次输出个数，字符，如果个数大于9就需要重新使用编码规则<br>2）将不相同的字符串首尾各添加1，在不相同的字符串中如果出现1就将其转换成2个1<br>解题思路：每次记录上一个字符与当前字符比较，如果相等将计数＋1，如果计数达到8就可以输出并且将计数清0，为什么我这里处理是8，因为个数等于9需要比较8次。如果不相等就一直循环到相等的时候退出，在此过程中需要保存不相同的字符串，如果遇到1就保存2个1，最后还需要在前面和后面都添加1，到字符相等的时候就输出。<br>源代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define N 10000+5</span></span><br><span class="line"></span><br><span class="line">char str[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(NULL != gets(str))</span><br><span class="line">	&#123;</span><br><span class="line">		int i,len = strlen(str),cnt=<span class="number">0</span>;</span><br><span class="line">		char c = str[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (cnt==<span class="number">8</span>)&#123;</span><br><span class="line">				printf(<span class="string">"%d%c"</span>,cnt+<span class="number">1</span>,c);</span><br><span class="line">				cnt=<span class="number">0</span>;</span><br><span class="line">				c=str[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (c == str[i])</span><br><span class="line">				cnt++;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (cnt&gt;<span class="number">0</span>&amp;&amp;cnt&lt;<span class="number">9</span>)&#123;</span><br><span class="line">					printf(<span class="string">"%d%c"</span>,cnt+<span class="number">1</span>,c);</span><br><span class="line">					cnt=<span class="number">0</span>;</span><br><span class="line">					c=str[i];</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					char ch[N];</span><br><span class="line">					int j=<span class="number">0</span>;</span><br><span class="line">					ch[j++]=<span class="string">'1'</span>;</span><br><span class="line">					<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span> (str[i]==c||i&gt;=len)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">if</span> (i==len)</span><br><span class="line">							&#123;</span><br><span class="line">								<span class="keyword">if</span> (str[i-<span class="number">1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">									ch[j++]=<span class="string">'1'</span>;</span><br><span class="line">									ch[j++]=<span class="string">'1'</span>;</span><br><span class="line">								&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">									ch[j++]=str[i-<span class="number">1</span>];</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">							ch[j++]=<span class="string">'1'</span>;</span><br><span class="line">							ch[j]=<span class="string">'\0'</span>;</span><br><span class="line">							printf(<span class="string">"%s"</span>,ch);</span><br><span class="line">							<span class="keyword">if</span> (i!=len)</span><br><span class="line">								cnt++;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (str[i-<span class="number">1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">							ch[j++]=<span class="string">'1'</span>;</span><br><span class="line">							ch[j++]=<span class="string">'1'</span>;</span><br><span class="line">						&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">							ch[j++]=str[i-<span class="number">1</span>];</span><br><span class="line">						&#125;</span><br><span class="line">						c=str[i];</span><br><span class="line">						i++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;   </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1936"><a href="#POJ1936" class="headerlink" title="POJ1936"></a>POJ1936</h4><p>题目描述：给你两个字符串s和t，判断s是否是t的子串。这里的子串之意就是s字符串中每个字符的先后顺序在t中的顺序也应该一样。<br>解题思路：此题应该很容易想到字符比较，如果si==ti则都往后推1，否则t往后推。<br>源代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#define N 100000+5</span></span><br><span class="line">char s[N],t[N];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%s%s"</span>,&amp;s,&amp;t)==<span class="number">2</span>)&#123;</span><br><span class="line">		int lens=strlen(s),lent=strlen(t);</span><br><span class="line">		int i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">		bool flag=false;</span><br><span class="line">		<span class="keyword">while</span> (i&lt;lens&amp;&amp;j&lt;lent)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i]==t[j])&#123;</span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i==lens)</span><br><span class="line">			printf(<span class="string">"Yes\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			printf(<span class="string">"No\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1790"><a href="#POJ1790" class="headerlink" title="POJ1790"></a>POJ1790</h4><p>题目描述：给你一串数字s，分成权数和基数，要求权数小于基数。求解有多少种分法？比如1234可以分成<br>(1-2-3)4, (1-2)34, (12)34, (1)234。<br>解题思路：类似于动态规划的思想，分别处理基数长度为1～数字串长度－1，然后将所有的种数相加，那么怎么比较？使用strncmp()函数。cnt[i]表示以s+i起始的基数总共有多少种分法。cnt[i]应该加上所有以len-i为基数的cnt。<br>源代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line">char s[<span class="number">100</span>+<span class="number">5</span>];</span><br><span class="line">int cnt[<span class="number">100</span>+<span class="number">5</span>];</span><br><span class="line">int len;</span><br><span class="line"></span><br><span class="line">int num(int cur)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (s[len-cur]==<span class="string">'0'</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	int i;</span><br><span class="line">	cnt[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=len-cur;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cnt[i]=<span class="number">0</span>;</span><br><span class="line">		int minn;</span><br><span class="line">		<span class="keyword">if</span> (i-cur&lt;<span class="number">0</span>)</span><br><span class="line">			minn=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			minn=i-cur;</span><br><span class="line">		<span class="keyword">for</span> (int j=minn; j&lt;i; j++)&#123;  </span><br><span class="line">			<span class="keyword">if</span> ((j+<span class="number">1</span>&lt;i || j==<span class="number">0</span> &amp;&amp; len-cur&gt;<span class="number">1</span>) &amp;&amp; s[j]==<span class="string">'0'</span>) <span class="keyword">continue</span>;  </span><br><span class="line">			<span class="keyword">if</span> (j+cur==i) <span class="keyword">if</span> (strncmp(s+j,s+len-cur,cur)&gt;=<span class="number">0</span>) <span class="keyword">continue</span>;  </span><br><span class="line">			cnt[i]+=cnt[j];  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cnt[len-cur];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%s"</span>,&amp;s)==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (s[<span class="number">0</span>]==<span class="string">'#'</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		int ans=<span class="number">0</span>,i;</span><br><span class="line">		len = strlen(s);</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">			ans+=num(i);</span><br><span class="line">		<span class="keyword">if</span> (ans&gt;<span class="number">0</span>)</span><br><span class="line">			printf(<span class="string">"The code %s can represent %d numbers.\n"</span>,s,ans);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			printf(<span class="string">"The code %s is invalid.\n"</span>,s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u524D_u8FF0"><a href="#u524D_u8FF0" class="headerlink" title="前述"></a>前述</h4><p>首先介绍一些技巧总结：<br>1) scanf与gets的区别：scanf读取到空格或换行，gets读取]]>
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序]]></title>
    <link href="http://yoursite.com/year/01/02/%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/year/01/02/排序/</id>
    <published>2016-01-02T07:38:22.000Z</published>
    <updated>2016-01-27T01:01:06.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u524D_u8FF0"><a href="#u524D_u8FF0" class="headerlink" title="前述"></a>前述</h4><p>首先介绍一下有关C++里面排序的模板, 包含的头文件是<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>常用的几种用法:</p>
<h5 id="sort_u51FD_u6570"><a href="#sort_u51FD_u6570" class="headerlink" title="sort函数"></a>sort函数</h5><p>1) 比如int x[N], 有n个元素, 直接使用sort(x,x+n);<br>2) 定义比较模式cmp, 然后使用sort(x,x+n,cmp);<br>比如(按下面的方法使用):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"></span><br><span class="line">struct pix&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">&#125;p[<span class="number">1000</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">int cmp(const pix &amp;a, const pix &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (a.x == b.x)</span><br><span class="line">		<span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">	<span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(p,p+n,cmp);</span><br></pre></td></tr></table></figure></p>
<h5 id="qsort_u51FD_u6570"><a href="#qsort_u51FD_u6570" class="headerlink" title="qsort函数"></a>qsort函数</h5><p>也需要定义比较模式, 并且可以按照下面所示方法使用<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int cmp(const void* a, const void* b)</span><br><span class="line">&#123;</span><br><span class="line">	Node* m = (Node *)a;</span><br><span class="line">	Node* n = (Node *)b;</span><br><span class="line">	if (m-&gt;x==n-&gt;x)</span><br><span class="line">		return m-&gt;y - n-&gt;y;</span><br><span class="line">	return m-&gt;x-n-&gt;x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">qsort(mid,m,sizeof(mid[0]),cmp);</span><br></pre></td></tr></table></figure></p>
<p>现在言归正传, 讲几道有关排序的POJ</p>
<h4 id="POJ1723"><a href="#POJ1723" class="headerlink" title="POJ1723"></a>POJ1723</h4><p>问题描述:给你一些士兵的坐标，使用尽量少的步数将士兵移到某一横排，并且每个士兵的位置唯一。<br>思路就是先按照y的坐标进行排序，将所有的士兵先移动到y的中位数对应的横排，现在遇到的一个问题就是可能多个士兵占用同一个x，怎么处理？我们的目标是将这些占用同一个x的士兵用尽量少的步数展开。首先想到的是假设有个起点a，这些士兵刚好排列在a+i上，如果没有怎么办？显然应该是abs(a+i-xi)的最小值，这里有个问题xi应该首先排好序否则a+i-xi不对应或者偏离很远。abs(a+i-xi)的最小值也即是abs(a-(xi-i))的最小值，于是a就是xi-i的中位数。<br>比如：x1=x2=x3=2，xi-i=1, 0, -1, 那么中位数a=0, 最小值2。<br>源代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define N 10000+5</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,x[N],y[N];</span><br><span class="line">	scanf("%d",&amp;n);</span><br><span class="line">	for (int i=0;i&lt;n;i++)</span><br><span class="line">		scanf("%d%d",&amp;x[i],&amp;y[i]);</span><br><span class="line">	sort(y,y+n);</span><br><span class="line">	sort(x,x+n);</span><br><span class="line">	for (int i=0;i&lt;n;i++)</span><br><span class="line">		x[i] -= i;</span><br><span class="line">	sort(x,x+n);</span><br><span class="line">	int cntx = (n%2)?x[(n-1)/2]:(x[n/2]+x[n/2-1])/2;</span><br><span class="line">	int cnty = (n%2)?y[(n-1)/2]:(y[n/2]+y[n/2-1])/2;</span><br><span class="line">	int sum=0;</span><br><span class="line">	for (int i=0;i&lt;n;i++)</span><br><span class="line">		sum +=(abs(cntx-x[i])+abs(cnty-y[i]));</span><br><span class="line">	printf("%d\n",sum);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ2376"><a href="#POJ2376" class="headerlink" title="POJ2376"></a>POJ2376</h4><p>问题描述：给你N个时间段和一个时间T，求最少的时间段覆盖时间[1,T]，如果不能覆盖则输出结果-1。<br>解题思路：<br>1）根据所有时间段的起始点从小到大排序，如果起始点相等就根据结束点从小到大排序。<br>2）如果起始点不等于1显然覆盖不了，直接输出－1，否则循环过滤掉前面多个1。<br>3）使用贪心的策略来求解最小的段数。操作就是用end来保存每次符合要求的最大结束点top，此时计数＋1，如果某次的top&lt;=end表明已经难以继续增加，直接退出比较是否比T大，如果比T大则输出计数值，否则输出－1。<br>源代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define N 25000+5</span><br><span class="line"></span><br><span class="line">struct INTER&#123;</span><br><span class="line">	int start;</span><br><span class="line">	int end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">INTER p[N];</span><br><span class="line"></span><br><span class="line">int cmp(const void* a, const void* b)</span><br><span class="line">&#123;</span><br><span class="line">	INTER *m = (INTER *)a;</span><br><span class="line">	INTER *n = (INTER *)b;</span><br><span class="line">	if (m-&gt;start == n-&gt;start)</span><br><span class="line">		return m-&gt;end - n-&gt;end;</span><br><span class="line">	return m-&gt;start - n-&gt;start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,T;</span><br><span class="line">	while (scanf("%d%d",&amp;n,&amp;T)==2)</span><br><span class="line">	&#123;</span><br><span class="line">		int i;</span><br><span class="line">		for (i=0;i&lt;n;i++)</span><br><span class="line">			scanf("%d%d",&amp;p[i].start,&amp;p[i].end);</span><br><span class="line">		qsort(p,n,sizeof(p[0]),cmp);</span><br><span class="line"></span><br><span class="line">		if (p[0].start!=1)&#123;</span><br><span class="line">			printf("-1\n");</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		i=0;</span><br><span class="line">		while (p[i].start==1 &amp;&amp; i&lt;n)</span><br><span class="line">			i++;</span><br><span class="line">		int cnt = 1;</span><br><span class="line">		int end = p[i-1].end;</span><br><span class="line">		int top = p[i-1].end;</span><br><span class="line">		while(i&lt;n)&#123;</span><br><span class="line">			int cur = i;</span><br><span class="line">			while (p[i].start &lt;= end + 1 &amp;&amp; i &lt; n)</span><br><span class="line">			&#123;</span><br><span class="line">				top = max(top,p[i].end);</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			if (cur==i || top&lt;= end)</span><br><span class="line">				break;</span><br><span class="line">			cnt++;</span><br><span class="line">			end = top; </span><br><span class="line">		&#125;</span><br><span class="line">		if (top &gt;= T)</span><br><span class="line">			printf("%d\n",cnt);</span><br><span class="line">		else</span><br><span class="line">			printf("-1\n");</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1971"><a href="#POJ1971" class="headerlink" title="POJ1971"></a>POJ1971</h4><p>问题描述：给你n个点的坐标，要求你找出平行四边形的个数。<br>解题分析：平行四边形有一个显著的特点就是对角线相交于某一点，而该点也是每条对角线的中点，那么比方说有k个点相交于某点，那么就应该有C(k,2)个平行四边形，这里的思路就是将所有坐标与其他点的坐标取平均值等到所有的中点，然后排序所有中点，进而容易查找在某中点的个数k，然后将所有的C(k,2)求和即得到平行四边形的个数。<br>源代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">&#125;in[1005],mid[500005];</span><br><span class="line"></span><br><span class="line">int cmp(const void* a, const void* b)</span><br><span class="line">&#123;</span><br><span class="line">	Node* m = (Node *)a;</span><br><span class="line">	Node* n = (Node *)b;</span><br><span class="line">	if (m-&gt;x==n-&gt;x)</span><br><span class="line">		return m-&gt;y - n-&gt;y;</span><br><span class="line">	return m-&gt;x-n-&gt;x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int t,n,m;</span><br><span class="line">	scanf("%d",&amp;t);</span><br><span class="line">	while (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf("%d",&amp;n);</span><br><span class="line">		for (int i=0;i&lt;n;i++)</span><br><span class="line">			scanf("%d%d",&amp;in[i].x,&amp;in[i].y);</span><br><span class="line">		m=0;</span><br><span class="line">		for (int i=0;i&lt;n;i++)</span><br><span class="line">			for (int j=i+1;j&lt;n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				mid[m].x = in[i].x+in[j].x;</span><br><span class="line">				mid[m++].y = in[i].y+in[j].y;</span><br><span class="line">			&#125;</span><br><span class="line">		qsort(mid,m,sizeof(mid[0]),cmp);</span><br><span class="line">		int dk=1,sum=0;</span><br><span class="line">		for (int i=0;i&lt;m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (mid[i].x==mid[i+1].x &amp;&amp; mid[i].y==mid[i+1].y &amp;&amp; i!=m-1)</span><br><span class="line">				dk++;</span><br><span class="line">			else&#123;</span><br><span class="line">				if (dk&gt;1)</span><br><span class="line">					sum += (dk*(dk-1)/2);</span><br><span class="line">				dk = 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf("%d\n",sum);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1788"><a href="#POJ1788" class="headerlink" title="POJ1788"></a>POJ1788</h4><p>题目描述：给你p个点的坐标，要求最小围住这p个点的篱笆长度。<br>解题分析：要求最小的篱笆长度，那么点应该在篱笆的拐角处，这样意味什么？比如你想计算y方向的篱笆长度，你需要先对x排序，如果x相等按y排序，这里有个点需要想到，就是对应每一个x，会有成对的y出现，这样才能求出y方向的篱笆长度，同理计算x方向的篱笆长度。两向篱笆长度想加即得到最小的篱笆长度。<br>源代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node pix[100000+5];</span><br><span class="line"></span><br><span class="line">int cmpx(const void *a, const void *b)</span><br><span class="line">&#123;</span><br><span class="line">	Node* m = (Node *)a;</span><br><span class="line">	Node* n = (Node *)b;</span><br><span class="line">	if (m-&gt;x == n-&gt;x)</span><br><span class="line">		return m-&gt;y - n-&gt;y;</span><br><span class="line">	return m-&gt;x - n-&gt;x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cmpy(const void *a, const void *b)</span><br><span class="line">&#123;</span><br><span class="line">	Node* m = (Node *)a;</span><br><span class="line">	Node* n = (Node *)b;</span><br><span class="line">	if (m-&gt;y == n-&gt;y)</span><br><span class="line">		return m-&gt;x - n-&gt;x;</span><br><span class="line">	return m-&gt;y - n-&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int p,sum;</span><br><span class="line">	while(scanf("%d",&amp;p)==1&amp;&amp;p!=0)&#123;</span><br><span class="line">		for (int i=0;i&lt;p;i++)</span><br><span class="line">			scanf("%d%d",&amp;pix[i].x,&amp;pix[i].y);</span><br><span class="line">		sum=0;</span><br><span class="line">		qsort(pix,p,sizeof(pix[0]),cmpx);</span><br><span class="line">		for (int i=0;i&lt;p;i=i+2)</span><br><span class="line">			sum += (pix[i+1].y-pix[i].y);</span><br><span class="line">		qsort(pix,p,sizeof(pix[0]),cmpy);</span><br><span class="line">		for (int i=0;i&lt;p;i=i+2)</span><br><span class="line">			sum += (pix[i+1].x-pix[i].x);</span><br><span class="line">		printf("The length of the fence will be %d units.\n",sum);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u524D_u8FF0"><a href="#u524D_u8FF0" class="headerlink" title="前述"></a>前述</h4><p>首先介绍一下有关C++里面排序的模板, 包含的头文件是<br><figure class="highli]]>
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数论]]></title>
    <link href="http://yoursite.com/year/01/02/%E6%95%B0%E8%AE%BA/"/>
    <id>http://yoursite.com/year/01/02/数论/</id>
    <published>2016-01-02T07:05:48.000Z</published>
    <updated>2016-01-27T01:01:34.000Z</updated>
    <content type="html"><![CDATA[<h4 id="u6B27_u51E0_u91CC_u5F97_u7B97_u6CD5_u548C_u6269_u5C55_u6B27_u51E0_u91CC_u5F97_u7B97_u6CD5"><a href="#u6B27_u51E0_u91CC_u5F97_u7B97_u6CD5_u548C_u6269_u5C55_u6B27_u51E0_u91CC_u5F97_u7B97_u6CD5" class="headerlink" title="欧几里得算法和扩展欧几里得算法"></a>欧几里得算法和扩展欧几里得算法</h4><p>欧几里得算法看上去高大上，其实质是辗转相除法，用于计算两个整数的a,b的最大公约数。<br>基本算法: 假设 $$ a=q<em>b+r $$ 其中a,b,q,r都是整数, 则gcd(a,b) = gcd(b,r); 证明可以参考链接<a href="http://www.cnblogs.com/frog112111/archive/2012/08/19/2646012.html" target="_blank" rel="external">欧几里得与扩展欧几里得</a><br>扩展欧几里得描述的是: $$a</em>p+b*q=c$$(a,b,c已知, p,q未知), 若存在解则c mod gcd(a,b) = 0, 并且p,q的其中一个解可以通过扩展的欧几里得算法求得。</p>
<p>首先求$$a<em>p + b</em>q = gcd(a,b)$$的解p,q<br>不妨假设 a &gt; b, a, b不同时为0<br>1) 当b = 0, 则p=1, q = 0原等式化为 a = a<br>2) 当a,b都不为0的时候, $$a<em>p1 + b</em>q1 = gcd(a,b)$$<br>$$b<em>p2 + (a mod b)</em>q2 = gcd(b, a mod b)$$<br>推出:<br>$$a<em>p1 + b</em>q1 = b<em>p2 + (a mod b)</em>q2$$<br>=&gt; $$p1 = q2$$<br>$$q1 = p2 - (a/b)*q2$$</p>
<p>即递归的边界在b=0时返回p=1, q = 0, 否则依次按上式递归<br>代码描述:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__int64 exgcd(__int64 a, __int64 b, __int64 &amp;x, __int64 &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (b==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x = <span class="number">1</span>;</span><br><span class="line">		y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	__int64 x2,y2;</span><br><span class="line">	__int64 t = exgcd(b,a%b,x2,y2);</span><br><span class="line">	x = y2;</span><br><span class="line">	y = x2 - (a/b)*y2;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1061"><a href="#POJ1061" class="headerlink" title="POJ1061"></a>POJ1061</h4><p>题目描述:<br>两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。<br>我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。<br>Input<br>输入只包括一行5个整数x，y，m，n，L，其中x≠y &lt; 2000000000，0 &lt; m、n &lt; 2000000000，0 &lt; L &lt; 2100000000。<br>Output<br>输出碰面所需要的跳跃次数，如果永远不可能碰面则输出一行”Impossible”</p>
<p>假设进过次数t, k圈两只青蛙相遇:<br>$$x+m<em>t - (y+n</em>t) = k<em>l$$<br>=&gt; $$(n-m)</em>t + l<em>k = x - y$$<br>和扩展欧几里得公式对应起来<br>$$a = n-m, b = l, c = x - y,<br>    p = t, q = k$$<br>那么调用扩展欧几里得公式后得到的解 $$(gcd(a,b)) = d = exgcd(a,b,p,q)$$<br>p,q是$$a</em>p + b<em>q = gcd(a,b)$$的解, 那么你需要实际的此时应该是$$xx = p</em>c/gcd(a,b) = t<em>(x-y)/d$$ 但是还有一个问题就是你的取值范围问题。<br>如下证明:<br>定理一：如果d = gcd(a, b)，则必能找到正的或负的整数k和l，使d = a</em>x+ b<em>y。<br>定理二：若gcd(a, b) = 1，则方程ax ≡ c (mod b)在[0, b-1]上有唯一解。<br>定理三：若gcd(a, b) = d，则方程ax ≡ c (mod b)在[0, b/d - 1]上有唯一解。<br>证明：上述同余方程等价于ax + by = c，如果有解，两边同除以d，就有a/d </em> x + b/d <em> y = c/d，即a/d </em> x ≡ c/d (mod b/d)，显然gcd(a/d, b/d) = 1，所以由定理二知道x在[0, b/d - 1]上有唯一解。所以ax + by = c的x在[0, b/d - 1]上有唯一解，即ax ≡ c (mod b)在[0, b/d - 1]上有唯一解。<br>如果得到ax ≡ c (mod b)的某一特解X，那么令r = b/gcd(a, b)，可知x在[0, r-1]上有唯一解，所以用x = (X % r + r) % r就可以求出最小非负整数解x了！（X % r可能是负值，此时保持在[-(r-1), 0]内，正值则保持在[0, r-1]内。加上r就保持在[1, 2r - 1]内，所以再模一下r就在[0, r-1]内了）。<br>r = b/gcd(a,b), 所以实际的次数是  (xx%r + r)%r<br>说的这么多该上代码了:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">__int64 exgcd(__int64 a, __int64 b, __int64 &amp;x, __int64 &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (b==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x = <span class="number">1</span>;</span><br><span class="line">		y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	__int64 x2,y2;</span><br><span class="line">	__int64 t = exgcd(b,a%b,x2,y2);</span><br><span class="line">	x = y2;</span><br><span class="line">	y = x2 - (a/b)*y2;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	__int64 x,y,m,n,l;</span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%I64d%I64d%I64d%I64d%I64d"</span>,&amp;x,&amp;y,&amp;m,&amp;n,&amp;l)==<span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		__int64 a,b,c,p,q,d,r,t;</span><br><span class="line">		a = n-m, b = l, c = x-y;</span><br><span class="line">		d = exgcd(a,b,p,q);</span><br><span class="line">		<span class="keyword">if</span> (c%d!=<span class="number">0</span>)</span><br><span class="line">			printf(<span class="string">"Impossible\n"</span>);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			r = b/d;</span><br><span class="line">			t = p*(c/d);</span><br><span class="line">			printf(<span class="string">"%I64d\n"</span>,(t%r+r)%r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ2262"><a href="#POJ2262" class="headerlink" title="POJ2262"></a>POJ2262</h4><p>问题描述: 每一个大于4的偶数都可以被写成两个奇素数相加<br>比如<br>8 = 3 + 5<br>20 = 3 + 17<br>42 = 5 + 37<br>输入一个n&gt;=6, n &lt; 100000寻找间隔最大的两个奇素数相加表示, 如果存在按照上面的格式输出, 否则输出Goldbach’s conjecture is wrong.<br>Sample Input<br>8<br>20<br>42<br>0<br>Sample Output<br>8 = 3 + 5<br>20 = 3 + 17<br>42 = 5 + 37<br>此题很简单, 只需要从最小的素数开始遍历就行, 如果差数也是素数就找到了。<br>代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool isprime(int x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (int i=<span class="number">2</span>;i*i&lt;=x;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (x%i==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> false;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%d"</span>,&amp;n)==<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		bool flag = false;</span><br><span class="line">		<span class="keyword">for</span> (int i=<span class="number">3</span>;i&lt;=n/<span class="number">2</span>;i=i+<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (isprime(i) &amp;&amp; isprime(n-i))</span><br><span class="line">			&#123;</span><br><span class="line">				printf(<span class="string">"%d = %d + %d\n"</span>,n,i,n-i);</span><br><span class="line">				flag = true;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag)</span><br><span class="line">			printf(<span class="string">"Goldbach's conjecture is wrong.\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1730"><a href="#POJ1730" class="headerlink" title="POJ1730"></a>POJ1730</h4><p>问题描述:<br>我们知道25 = 5^2, 1073741824 = 2^30, 等等，现在给你一个32位的int型数n, 你需要找到最大的指数i使得n = a^i<br>这个题有个很巧妙的解法:<br>首先我们来思考一下<br>1.32位的int型数是包括正数和负数的, 我们知道负数是不可能等于某个数的偶数次方的。<br>2.我们知道双精度的double表示是1, 11, 52, 那么我们将一个double x强制转化成__int64 a, 显然如果abs(a-x)&lt; (1.0e-12)或者abs(a-x+1) &lt; (1.0e-12)(这个地方你可以自己检验一下), 就可以保证x == a。<br>3.可以直接对n进行开32~1次方根<br>代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;math.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define esp 1.0e-12        // 1 11 52 double型需要12位</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	long long n;</span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%I64d"</span>,&amp;n)==<span class="number">1</span> &amp;&amp; n!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		bool flag = false;</span><br><span class="line">		<span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			flag = true;</span><br><span class="line">			n = -n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (int i=<span class="number">32</span>;i &gt;= <span class="number">1</span>;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!flag || (flag &amp;&amp; (i&amp;<span class="number">1</span>)))   // 负数只能开奇数次方不能开偶数次方</span><br><span class="line">			&#123;</span><br><span class="line">				double x = pow((double)n, <span class="number">1.0</span>/i); // <span class="number">1</span> <span class="number">8</span> <span class="number">23</span>    <span class="number">1</span> <span class="number">11</span> <span class="number">52</span></span><br><span class="line">				long long a = x; </span><br><span class="line">				<span class="keyword">if</span> (abs(a-x) &lt; esp || abs(a-x+<span class="number">1</span>) &lt; esp)</span><br><span class="line">				&#123;</span><br><span class="line">					printf(<span class="string">"%d\n"</span>,i);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="POJ1183"><a href="#POJ1183" class="headerlink" title="POJ1183"></a>POJ1183</h4><p>问题描述:根据此题和反正切函数没有半毛钱关系<br>反正切等式: $$ arctan(p)+arctan(q)=arctan[(p+q)/(1-pq)] $$</p>
<p>我们将上述公式写成如下形式<br>$$ arctan(1/a)=arctan(1/b)+arctan(1/c) $$<br>其中a,b和c均为正整数。<br>我们的问题是：对于每一个给定的a(1&lt;=a&lt;=60000)，求b＋c的值。我们保证对于任意的a都存在整数解。如果有多个解，要求你给出b+c最小的解。<br>证明推导:<br>$$ 1/a = (1/b+1/c)/(1-1/b<em>1/c) $$<br>=&gt; $$a</em>(b+c) = b<em>c -1$$<br>利用均值不等式我们可以推出$$b+c &gt;= 2</em>(a+sqrt(a<em>a+1))$$<br>不妨设$$b = a + m, c = a + n$$<br>$$a</em>(b+c) = b<em>c -1 =&gt; m</em>n = a<em>a + 1$$<br>因为需要求b+c的最小值也就是m,n的最小值因而很容易理解m从a开始往下搜, (a</em>a+1)%m==0结束<br>最后$$b+c = 2*a + m + n$$<br>代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	__int64 a,b,c;</span><br><span class="line">	<span class="keyword">while</span> (scanf(<span class="string">"%I64d"</span>,&amp;a)==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		__int64 m,n;</span><br><span class="line">		<span class="keyword">for</span> (m=a;m&gt;=<span class="number">1</span>;m--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> ((a*a+<span class="number">1</span>) %m ==<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		n = (a*a+<span class="number">1</span>)/m;</span><br><span class="line">		printf(<span class="string">"%I64d\n"</span>,<span class="number">2</span>*a+m+n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="u6B27_u51E0_u91CC_u5F97_u7B97_u6CD5_u548C_u6269_u5C55_u6B27_u51E0_u91CC_u5F97_u7B97_u6CD5"><a href="#u6B27_u51E0_u91CC_u5F97_u7B97_u]]>
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ceph:可靠的, 可扩展的高性能分布式系统]]></title>
    <link href="http://yoursite.com/year/01/01/Ceph/"/>
    <id>http://yoursite.com/year/01/01/Ceph/</id>
    <published>2016-01-01T15:36:54.000Z</published>
    <updated>2016-03-05T12:39:39.000Z</updated>
    <content type="html"><![CDATA[<p>此文翻译于Sage Weil在2006年发表于OSDI上的文章(Ceph: A Scalable, High-Performance Distributed File System)，由于用于本人的毕业设计文献翻译，所以严禁复制和转载，违者必究! </p>
<h3 id="u6458_u8981"><a href="#u6458_u8981" class="headerlink" title="摘要"></a>摘要</h3><p>我们已经开发出ceph，一个能提供卓越的性能，可靠性和可扩展性的分布式文件系统。ceph通过一个伪随机数据分布函数(CRUSH)取代分配表来最大化分离数据和元数据的管理。CRUSH函数被设计用于异构，动态，由不可靠对象存储设备(OSDs)构成的集群中。我们通过将数据副本，错误检测和恢复功能分发给正在运行专门的本地对象文件系统的OSDs来利用设备的智能性。动态的分布式元数据集群提供极度高效地元数据管理和无缝地适应广泛的通用计算和科学计算文件系统工作负载。在各种工作负载下的性能测试表明，Ceph的具有优良的I/O性能和可扩展的元数据管理，支持每秒25万以上的元数据操作。</p>
<h3 id="u4ECB_u7ECD"><a href="#u4ECB_u7ECD" class="headerlink" title="介绍"></a>介绍</h3><p>系统设计者一直都在试图改善文件系统的性能，这对于极为广泛的一类应用的整体性能很重要。学术界尤其是高性能计算组织在分布式存储系统的性能和扩展性保持领先，一般预示着未来几年的更加通用的需要。传统的解决方案，比如NFS，提供一个直接的模型，服务器对外一个文件系统层次使得客户机可以映射到它们的本地名字空间。即使是被广泛使用，客户机/服务器的中心化本质已被证明是扩展性能的极大阻碍。</p>
<p>最近更多的分布式文件系统已经采用基于对象存储的架构，原先传统的硬盘已经被智能的对象存储设备(OSDs)替换，OSD是结合了一个CPU，网络接口和带有本地缓存的磁盘或阵列的设备。OSD替换传统的客户端进行读写字节的块层接口，使用读写字节数范围更大的对象，将底层块分配的决定给设备本身。客户端通常和元数据服务器(MDS)交互去进行元数据操作(open,rename)，同时直接和OSD交互进行文件的IO(read and write)，极大地提高了整体的性能。</p>
<p>由于元数据负载分布小或者没有时，采用这种模型的系统会遭受扩展的限制。受限于传统的文件系统设计原则比如分配列表和i节点表不倾向授权给OSD的智能分配，从而导致更加受限的扩展和性能，增加了可靠性的代价。</p>
<p>我们提出ceph，一个能提供优越性能和可靠性同时有望成为拥有独一无二扩展性的分布式文件系统。我们的架构是基于这样的假设:在PB级规模的系统本质上是动态，大型系统都不可避免的是逐步建成的，节点故障是常态而不是异常，工作负载的质量和特点是随着时间的推移不断变化的。</p>
<p>Ceph使用生成函数取代文件分配表来实现数据和元数据操作的分离。这样一来，Ceph可以利用OSD的智能性来分散数据访问，更新序列化，副本和可靠性，故障检测和恢复的复杂度。Ceph采用高度自适应的分布式元数据集群架构，显著提高了元数据访问的扩展性，从而提高整个系统的扩展性。我们讨论了架构设计时针对的目标和负载假设，分析其对系统的扩展性，性能和可靠性的影响，并结合相关的经验实现了功能系统的原型。</p>
<h3 id="u7CFB_u7EDF_u6982_u8FF0"><a href="#u7CFB_u7EDF_u6982_u8FF0" class="headerlink" title="系统概述"></a>系统概述</h3><p>ceph文件系统有三个组件:<strong>客户端</strong>其中每个实例开放了一个接近POSIX文件系统接口到主机或进程中; <strong>OSD集群</strong>OSDs共同存储所有数据和元数据; <strong>元数据服务器集群</strong>管理命名空间(文件名和目录)，同时协调安全性，一致性和连贯性。我们说ceph的接口是接近POSIX接口的是因为我们发现恰当地扩展接口和选择性放松一致性语义是为了更好贴近应用的需要，并且提高了系统的性能。</p>
<p>该架构的主要目标是扩展性(数百计的PB级或更多)，性能和可靠性。可扩展性在多个维度被考虑，包括整体的存储容量和系统的吞吐率以及单个客户端，目录或文件的表现。我们的目标工作量可能包括极端情况下成千上万的主机并发读取或写入到同一文件或在同一目录创建文件。这样的场景在运行科学应用的超级计算集群中很普遍，也越来越表明是未来的通用计算负载。更重要的是，我们认识到分布式文件系统的工作负载本质上是动态的，在活跃的应用程序和数据集随着时间改变的同时，数据和元数据的访问也会显著变化。ceph直接处理扩展性问题的同时，通过三个基本的设计特性:<strong>数据和元数据分离</strong>，<strong>动态分布式元数据管理</strong>，<strong>可靠的,自治的,分布式对象存储</strong>实现了高性能，可靠性和可用性。</p>
<p><strong>数据和元数据的分离</strong> ceph最大化分离文件元数据管理和文件数据存储。元数据操作(open,rename,etc.)被一个元数据服务器集群统一管理，与此同时客户端直接和OSDs交互实现文件IO(reads and writes)。基于对象的存储早已承诺通过授权底层的块分配决定给单个设备来提高文件系统的扩展性。然而，和现有的基于对象文件系统[4,7,8,32]所采用短对象列表取代长文件块表不同，ceph完全消除了分配表。ceph中的文件数据被条带化到可预见的对象上，通过专用的数据分布函数CRUSH[29]分配对象给存储设备。这允许任何一方来计算(而非查找)包含文件内容的对象名和对象位置，消除了维护和发布对象列表的需要，简化了系统的设计并减少了元数据集群负载。</p>
<p><strong>动态分布式元数据管理</strong> 因为文件系统元数据操作构成一般文件系统负载[22]的一半，所以高效的元数据管理对于系统整体性能很关键。ceph采用了基于动态子树划分的新型元数据集群架构，该架构能够在成十上百的MDSs中自适应，智能地分布管理文件系统目录层次的责任。一个动态的层次划分保留了在每个MDS负载里的局部性，方便高效的更新和积极地预取来提高对常见负载的性能。重要的是元数据服务器之间的工作负载分布是完全基于当前访问模式，允许ceph在任何负载下有效地利用可获得的MDS资源，从而实现MDS的近线性伸缩。</p>
<p><strong>可靠的,自治的分布式对象存储</strong> 由成千上万的设备构成的大系统本质上是动态的: 它们是逐步构建的，随着新存储的部署和旧设备的退下而伸缩，设备出错是频繁的和预期的，以及大型卷数据的被创建，移动和删除。所有这些因素都需要数据分布演变成能有效利用可获得资源并且保持数据副本所需要的水平。ceph将数据迁移，副本，错误检测和错误恢复的责任交给OSDs集群，OSDs集群存储数据的同时向上提供一个更高层的逻辑对象存储给客户端和元数据服务器。这个方法允许ceph更高效地利用每个OSD的智能(CPU和内存)来实现可靠的，可获得线性伸缩的对象存储。</p>
<p>我们描述了ceph客户端的操作，元数据服务器集群和分布式对象存储以及它们是如何被我们的架构关键特性所影响。也描述了我们原型机现状。</p>
<h3 id="u5BA2_u6237_u7AEF_u64CD_u4F5C"><a href="#u5BA2_u6237_u7AEF_u64CD_u4F5C" class="headerlink" title="客户端操作"></a>客户端操作</h3><p>我们通过描述Ceph的客户端操作介绍Ceph组件的整体运作以及与应用的交互。每个主机执行ceph客户端应用代码，提供给应用程序一个文件系统接口。在ceph原型中，客户端代码完全运行在用户空间，能够通过直接链接访问或者经过FUSE(一个用户空间文件系统接口)挂载文件系统访问。每个客户端维护自己的文件数据缓存，独立的内核页或缓冲区高速缓存，使得应用可以直接链接客户端访问。<br><img src="/about/ceph/1.png" alt="logo"></p>
<h4 id="u6587_u4EF6IO_u548C_u6743_u9650"><a href="#u6587_u4EF6IO_u548C_u6743_u9650" class="headerlink" title="文件IO和权限"></a>文件IO和权限</h4><p>当一个进程打开一个文件时，客户端发送一个请求到MDS集群。一个MDS遍历文件系统层次结构将文件名翻译成文件索引节点，该索引节点包含唯一的索引编号，文件持有者，模式，大小和关于如何将文件数据映射到对象的条带策略信息。MDS或许会询问客户端指定哪些操作是被允许的权限(如果没有指定的)。权限目前包含4位控制:客户端的读，缓存中读，写，和缓冲区写入。未来将会添加安全密匙权限需要客户端向OSDs证明他们有权限读写数据(目前原型认可所有客户端)[13,19]。后续MDS关于文件IO的工作仅限于保持文件一致性和实现正确语义的管理权限。</p>
<p>ceph概括了一些将文件数据映射到一系列对象上的条带化策略。为了避免文件分配元数据的使用，对象名字简单的取为文件索引编号+条带编号。通过使用全球知名的映射函数CRUSH将对象副本分配给OSDs。比如，如果一个或多个客户端打开一个文件进行读访问，一个MDS授予他们读和缓存文件的内容的权限。客户端利用索引节点编号，布局和文件大小能够命名对象和找到所有包含文件数据的对象，并且从OSD集群中直接读。任何不存在的对象和字节范围都被定义为文件空洞或零。类似地，如果一个客户端打开一个用于写的文件，它是被授权有缓冲的写权限，它产生在文件里任何偏移上的所有数据简单地被写入到合适的OSD中的合适的对象上。客户端放弃了文件关闭的权限并提供给MDS最大的文件大小(最大的写偏移)，该大小重新定义了对象集是否存在文件数据以及包含文件数据多少。</p>
<h4 id="u5BA2_u6237_u7AEF_u540C_u6B65"><a href="#u5BA2_u6237_u7AEF_u540C_u6B65" class="headerlink" title="客户端同步"></a>客户端同步</h4><p>POSIX语义符合实际地要求读必须是先前写过的数据，并且写是原子性(重叠和并发写的结果将反应在发生的特定顺序)。当一个文件被多个客户端打开同时写或者部分读部分写时，MDS将会撤销先前授权的读缓存或写缓冲的权限，强制客户端的文件IO保持同步。也就是说每个应用的读写操作会被堵塞直到被OSD承认，这样在OSD存储每个对象的同时高效地分摊了更新序列化和同步的负担。当写跨越对象边界时，客户端获得受影响对象(由各自的OSD提供)的独占锁，并立即提交写操作和解锁操作来实现所需要的序列化。对象锁类似地通过获取锁和异步刷新数据来屏蔽大写的延迟。</p>
<p>毫不惊讶的是异步IO是应用的性能杀手，尤其是那些小读和小写，由于至少是一个OSD的来回带来的延迟惩罚。虽然读写共享在通用的工作负载中相对少见，在科学计算中更加普遍，往往性能很关键。由于这个原因，经常需要在应用程序不需要严格标准一致性时放松一致性要求。虽然ceph支持通过全局切换实现放松一致性，并且很多其他的分布式文件系统在这个问题上冒险，这是一个不确定和不令人满意的解决方法:要么性能损失或者系统范围的丢失一致性。</p>
<p>正是这个原因，高性能计算组织提出了一组针对POSIX IO接口的高性能计算扩展集合，这个扩展子集是由ceph实现的。最值得注意的是，这其中就包括一个O_LAZY标志开放允许应用程序明确放宽共享写文件普通的一致性要求。当IO不是同步运行的时候，性能敏感的应用程序管理自身一致性(HPC负载中常见的模式是通过写同一文件的不同部分)允许缓冲写和缓存读。如果需要的话，应用程序可以使用另外两个系统调用明确同步:lazyio_propagate将在对象存储中刷新一个给定的字节范围，lazyio_synchronize将确保先前的传递会影响后续的读。ceph同步模型在同步IO的客户端之间提供正确的读写和共享写语义保留了简洁性，并且扩展了应用接口来放松性能敏感的分布式应用的一致性。</p>
<h4 id="u547D_u540D_u7A7A_u95F4_u64CD_u4F5C"><a href="#u547D_u540D_u7A7A_u95F4_u64CD_u4F5C" class="headerlink" title="命名空间操作"></a>命名空间操作</h4><p>客户端和文件系统的命名空间的交互是由元数据服务器集群管理。读操作(e.g.,readdir,stat)和更新(e.g.,unlink,chmod)是被MDS同步以后采用来确保序列化，一致性，正确的安保和安全性。为了简化，没有元数据锁和租赁权限给客户端。特别对于HPC的负载，回调提供了潜在较高复杂度开销的最小上界。</p>
<p>相反，ceph优化了最常见的元数据访问情形。一个readdir随后跟着每个文件的stat(e.g.,ls -l)是极为常见的访问模式并且是众所周知的性能杀手。ceph中的readdir只需要单个MDS请求就可以获取包含索引节点内容的整个目录。默认情况下，如果一个readdir后面紧接着一个或多个stat，简要的缓存信息被返回，否则这些信息被丢弃。虽然稍微放松一致性导致中间的索引节点修改被忽视，为了提高性能我们乐意这个交易。这个行为明确的被readdirplus扩展解决，能够返回目录项的lstat结果(就像一些具体的OS实现的getdir功能)。</p>
<p>ceph能够允许一致性通过缓存元数据进一步放宽，很像早期版本的NFS通常缓存30秒。然而这个方法在某种程度上破坏了对于应用很关键的连贯性，比如那些使用stat去决定一个文件是否更新的应用–它们要么表现不正确要么等待旧的缓存数据超时。</p>
<p>我们没有选择再次提供正确的行为和扩展实例的接口，因为这可能反过来影响性能。当多个客户端打开同一文件进行stat操作时很清楚地描述了这个选择。为了返回正确的文件大小和修改时间，MDS撤销所有写权限，暂时停止更新并且搜集写入者中最新的文件大小和修改时间。最高值随着stat回复被返回并且权限被发布允许进一步的进展。虽然停止多个写入者或许看起来很剧烈，但是有必要确保序列化。(对于单个写入者。一个正确的值可以无需打断进程的被写入客户端修复。)没有必要连贯性的应用(POSIX接口没有对准它们的需要的受害者)可以使用statlite，statlite采用一位掩码指定不需要保持一致的索引节点域。</p>
<h3 id="u52A8_u6001_u5730_u5206_u5E03_u5F0F_u5143_u6570_u636E"><a href="#u52A8_u6001_u5730_u5206_u5E03_u5F0F_u5143_u6570_u636E" class="headerlink" title="动态地分布式元数据"></a>动态地分布式元数据</h3><p>元数据操作往往占了一半的文件系统的工作负载并且处在关键路径，使得MDS集群对于整体性能至关重要。分布式文件系统中的元数据管理也呈现出紧张的扩展挑战: 虽然随着更多的存储设备的规模化，容量和总的IO率能够任意扩张，但是元数据的更大程度的依存关系将使得一致性和连贯性的扩展更加困难。</p>
<p>ceph中的文件和目录的元数据是很小的，几乎全部由目录项(文件名)和索引节点(80 bytes)组成。传统的文件系统中的文件分配元数据没有必要，因为对象名是由索引节点编号构造，使用CRUSH函数分配给OSDs。这个简化了元数据的工作负载并且允许MDS高效地管理很大的工作文件集，而不是文件的大小。我们设计通过两个分层的存储策略进一步寻求最小化和磁盘IO相关的元数据，以及通过使用动态子树分区最大化局部性和缓存效率。</p>
<h4 id="u5143_u6570_u636E_u5B58_u50A8"><a href="#u5143_u6570_u636E_u5B58_u50A8" class="headerlink" title="元数据存储"></a>元数据存储</h4><p>虽然MDS集群目标在于使用内存缓存满足大多数请求，但是为了安全，元数据更新一定得提交到磁盘。一组大的，有界的懒惰地冲刷日志允许MDS用高效和分布式的方式将更新的元数据流到OSD集群中。包含多个百兆字节的单个MDS日志也反复吸收(大多数通用负载)元数据更新以至于当旧日志项被最终冲刷到长期存储中时，很多已经过时。虽然MDS的恢复功能还没有被实现，日志被设计成在一个MDS故障时，其他的节点可以迅速重新扫描日志来恢复错误节点中的内存缓存(用于快速启动)中关键内容，这样一来恢复了文件系统的状态。</p>
<p>这个策略提供了两全其美: 流更新到硬盘是一个高效且串行的方式，大大减少了重写的工作负载，使得长期的磁盘存储布局可以得到优化来方便未来的读。特别的，索引节点嵌入到目录中能允许MDS预取整个目录用于单个OSD读请求和利用在大多数负载中存在的高度目录局部性。每个目录的内容使用和元数据日志以及文件数据一样的条带化和分布式策略写入OSD集群中。索引节点编号按范围分配到MDS，在我们原型中被认为是不变的，在未来，它们可能在文件删除时被很细的重排。辅助锚表维护罕见的有多个硬连接的索引节点，这些硬连接都可以按索引节点编号全局寻找到，而不会有一个巨大的，稀疏的且繁琐的索引节点表来拖累单链接文件。</p>
<h4 id="u52A8_u6001_u5B50_u6811_u5206_u533A"><a href="#u52A8_u6001_u5B50_u6811_u5206_u533A" class="headerlink" title="动态子树分区"></a>动态子树分区</h4><p>我们的主拷贝缓存策略使得每个权威的MDS都有责任管理缓存连贯性和任意片段元数据的串行更新。尽管大多数存在的分布式文件系统采用静态子树划分来下放这个权力(通常强制管理员将数据集雕刻成更小的静态卷)，最近一些实验室的文件系统已经使用Hash函数来分布目录和文件元数据，却牺牲了负载分布的局部性。这两种方法都有关键的限制: 静态子树划分未能处理动态负载和动态数据集，而Hash破坏了元数据的局部性和元数据高效预取和存储的关键机会。</p>
<p><img src="/about/ceph/2.png" alt="logo"></p>
<p>ceph的MDS集群是基于动态子树分区策略，能够自适应地在一组节点中分配分层的缓存元数据。每个MDS使用指数时间衰减的计数器来测量目录层次中的元数据的受欢迎度。任何操作都增加受影响索引节点和它到根目录所有祖先的计数器，提供每个MDS一棵描述最近负载分配的权重树。MDS负载值周期性地被比较，适当大小的目录层次子树被迁移来保持负载均衡。共享的长期存储和精心构造的命名空间锁的组合使得这种内存缓存适当内容迁移到新权威对连贯性锁和客户端权限影响最小。为了安全，导入的元数据被写入到新的MDS日志，同时两端附加的日志项确保权威的转换是不受中间错误的破坏(类似于两阶段提交)。基于子树分区的结果是最小化了前缀副本的开销并且维护了局部性。</p>
<p>当元数据在多个MDS节点中复制时，索引节点内容被划分到三组，每组有不同的一致性语义: 安全(持有者，模式)，文件(大小，修改时间)和不可变的(索引节点编号，改变时间，布局)。虽然不可变的领域是永远不会改变，安全和文件锁是由独立的有限状态机约束，每个不同的状态集和过渡设计都能容纳不同的访问和更新模式，同时最小化锁争用。比如，路径遍历时需要持有者和模式安全检查但是很少改变，因此需要很少的状态，而文件锁反映更广泛的客户端访问模式。因为它有管理MDS发布客户端权限的能力。</p>
<h4 id="u6D41_u91CF_u63A7_u5236"><a href="#u6D41_u91CF_u63A7_u5236" class="headerlink" title="流量控制"></a>流量控制</h4><p>在多个节点之间划分多个目录层次能够平衡广泛的工作负载，但是不能总是解决热点和多个客户端访问同一目录和文件导致的瞬间拥塞。当热点需要和不会引起一般情况下的相关开销和目录局部性的损失，ceph使用受欢迎度的知识来提供更宽的分布。经常被读目录的内容(e.g.,many opens)会被多个节点选择性地复制来负载均衡。特别大的目录或者经历相当大的写负载时(e.g.,many file creations)会按照包含的文件名在集群中映射，以损失目录局部性为代价实现负载均衡。这个自适应方法允许ceph涵盖更广的分区粒度，捕捉到文件系统中具体情况和分配的粗细分区的好处。</p>
<p>每个MDS响应时提供给客户端授权的更新信息和相关的索引节点的所有副本和它的祖先，允许客户端知道与它们交互的文件系统的部分元数据分区。未来的元数据操作直接针对权威(对于更新)或者基于给定路径最深的已知前缀随机副本(对于读)。通常客户端知道不受欢迎的元数据位置并且能够直接和适当的MDS联系。然而，客户端访问流行的元数据时会被告知元数据驻留在不同的或多个MDS节点上，有效地限定了客户端相信特定元数据片段驻留在特定MDS的数量，在它们并发之前就已经分散了潜在的热点和瞬间的拥塞。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>此文翻译于Sage Weil在2006年发表于OSDI上的文章(Ceph: A Scalable, High-Performance Distributed File System)，由于用于本人的毕业设计文献翻译，所以严禁复制和转载，违者必究! </p>
<h3 id="]]>
    </summary>
    
      <category term="Storage" scheme="http://yoursite.com/tags/Storage/"/>
    
      <category term="cloud computing" scheme="http://yoursite.com/tags/cloud-computing/"/>
    
      <category term="ceph" scheme="http://yoursite.com/categories/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://yoursite.com/year/01/01/hello-world/"/>
    <id>http://yoursite.com/year/01/01/hello-world/</id>
    <published>2016-01-01T02:20:30.000Z</published>
    <updated>2016-01-11T13:17:52.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.]]>
    </summary>
    
  </entry>
  
</feed>
